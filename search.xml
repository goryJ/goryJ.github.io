<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>LC振荡器</title>
    <url>/2020/12/13/LC-oscillator/</url>
    <content><![CDATA[<blockquote>
<p>前言：虽然这是一篇课内的（老师说非常过时技术的）学习笔记，但是笔者认为把振荡器电路学好了，顺带把反馈、三极管、LC谐振器等概念都复习起来了</p>
</blockquote>
<h2 id="LC振荡器类型"><a href="#LC振荡器类型" class="headerlink" title="LC振荡器类型"></a>LC振荡器类型</h2><p>振荡器的组成基本都是3个部分：信号放大电路、选频（滤波）网络、反馈电路。使用LC选频的就是本文的LC振荡器，使用晶振选频的就是晶体振荡器。</p>
<p>对于LC振荡器，采用不同的反馈策略，就有了不同的电路结构以及带来的性能优缺，本文讨论的有：</p>
<ul>
<li>变压器（互感）耦合振荡器</li>
<li>电感反馈三端式振荡器</li>
<li>电容反馈三端式振荡器</li>
<li>串联型改进电容三端式</li>
<li>并联型改进电容三端式</li>
</ul>
<p>由于采用的都是LC谐振选频，所以振荡器的频率都是谐振频率（注意进行相应的串并联等效）</p>
<p>$$<br>f_o &#x3D; \frac 1 {2\pi} \sqrt{\frac{1}{LC}}<br>$$</p>
<h2 id="变压器（互感）耦合振荡器"><a href="#变压器（互感）耦合振荡器" class="headerlink" title="变压器（互感）耦合振荡器"></a>变压器（互感）耦合振荡器</h2><p>由选频网络工作的位置不同，如下图可分为</p>
<ul>
<li>调基电路</li>
<li>调发电路</li>
<li>调射电路</li>
</ul>
<p><img src="https://blog-img-goryj.oss-rg-china-mainland.aliyuncs.com/blogpost/20201213-LC-1.png" alt="互感耦合"></p>
<span id="more"></span>

<p>耦合时的同名端决定了正反馈（相位）是否成立，而互感量M决定了反馈量的大小。由选频网络易得</p>
<p>$$<br>f_o &#x3D; \frac 1{2\pi} \sqrt{\frac{1}{LC}}<br>$$</p>
<p>起振条件为</p>
<p>$$<br>h_f \gt \frac{h_i R_L C + L\Delta h_b}{M}<br>$$</p>
<blockquote>
<p>由于变压器在绕制的时候，线圈匝间存在分布电容，且不好控制量值，所以不适用于高频场合</p>
</blockquote>
<h2 id="三端式反馈振荡器"><a href="#三端式反馈振荡器" class="headerlink" title="三端式反馈振荡器"></a>三端式反馈振荡器</h2><p><img src="https://blog-img-goryj.oss-rg-china-mainland.aliyuncs.com/blogpost/20201213-LC-5.png" alt="三端式原理"></p>
<p>忽略三极管的IO阻抗，依据谐振理论可知电路要振荡需要满足条件</p>
<p>$$<br>x_{be}+ x_{ce}+ x_{cb} &#x3D;0<br>$$</p>
<p>并且由上图可知</p>
<p>$$<br>如果x_{be}和x_{ce}都是阻性元件<br>\<br>那么v_i &#x3D; v_f &#x3D; - v_o<br>$$</p>
<p>也就是说相角恰好差了180度，那么为了形成正反馈和稳定的振荡，就需要这两个元件具有同样的电抗特性。两个电抗元件各带来方向相同的90度相移，也就是总共180度相移</p>
<blockquote>
<p>总结：ce和be同抗，cb反抗</p>
</blockquote>
<h3 id="电感反馈三端式振荡器"><a href="#电感反馈三端式振荡器" class="headerlink" title="电感反馈三端式振荡器"></a>电感反馈三端式振荡器</h3><blockquote>
<p>Hartley</p>
</blockquote>
<p><img src="https://blog-img-goryj.oss-rg-china-mainland.aliyuncs.com/blogpost/20201213-LC-2.png" alt="电感反馈"></p>
<p>上图中左图为完整振荡电路，右图进行了交流等效，可见满足上面讨论的三端谐振条件。重要元件说明：</p>
<p>$$<br>反馈电容兼隔直电容C_b<br>\\<br>高频旁路电容C_e<br>\\<br>放大器工作点偏置电阻R_{b1}和R_{b2}<br>$$</p>
<p>电路的起振条件为</p>
<p>$$<br>h_{fe} \gt \frac{h_{ie}}{FR_P’} &#x3D; \frac{h_{ie}}{R_P’} \cdot \frac{L_1 + M}{L_2 + M} \gt \frac{h_{ie}}{h_{fe}R_p’}<br>\\<br>负载回路谐振电阻R_p’<br>\\<br>反馈系数F<br>$$</p>
<p>作如下所示的等效谐振回路图可知，若F大，则接入系数增大，晶体管输入阻抗折合到谐振等效回路中的阻抗减少，使得Q值减少，也就是谐振电阻减少。那么从起振条件可知，要求的电流增益需求变大了，使得电路难以起振</p>
<p><img src="https://blog-img-goryj.oss-rg-china-mainland.aliyuncs.com/blogpost/20201213-LC-3.png" alt="电感反馈等效"></p>
<blockquote>
<p>因为采用的是电感作反馈，所以高频谐波的反馈较强，波形失真大</p>
</blockquote>
<h3 id="电容反馈三端式振荡器"><a href="#电容反馈三端式振荡器" class="headerlink" title="电容反馈三端式振荡器"></a>电容反馈三端式振荡器</h3><blockquote>
<p>Coplitts</p>
</blockquote>
<p><img src="https://blog-img-goryj.oss-rg-china-mainland.aliyuncs.com/blogpost/20201213-LC-4.png" alt="电容反馈"></p>
<ol>
<li>采用电容反馈的好处就是高频谐波得到了抑制，振荡波形接近正弦波；</li>
<li>如果把两个谐振反馈电容数量级取大，那么分布电容的影响就很小；</li>
<li>一般在电感边上并联一个电容来调谐振点频率</li>
</ol>
<h2 id="串联型改进电容三端式"><a href="#串联型改进电容三端式" class="headerlink" title="串联型改进电容三端式"></a>串联型改进电容三端式</h2><blockquote>
<p>Clapp</p>
</blockquote>
<p><img src="https://blog-img-goryj.oss-rg-china-mainland.aliyuncs.com/blogpost/20201213-LC-6.png" alt="串联改进"></p>
<p>$$<br>\because C_3 \ll C_1, C_3 \ll C_2<br>\\ \therefore<br>等效串联电容 C \simeq C_3<br>\\ \Rightarrow<br>\omega_o &#x3D; \frac{1}{\sqrt{LC_3}}<br>$$</p>
<p>此时晶体管的输入输出电容和反馈电容网络对电路的谐振频率影响都非常的小。但是注意电路的接入系数：</p>
<p>$$<br>P_{ce} &#x3D; \frac{C_3}{C_1}<br>,<br>P_{be} &#x3D; \frac{C_3}{C_2}<br>$$</p>
<blockquote>
<p>因为调谐的时候，会改变接入系数，所以过度地调整电容（调谐振点）会导致振荡器不满足起振条件</p>
<blockquote>
<p>该电路适用于固定谐振点的电路</p>
</blockquote>
</blockquote>
<h2 id="并联型改进电容三端式"><a href="#并联型改进电容三端式" class="headerlink" title="并联型改进电容三端式"></a>并联型改进电容三端式</h2><blockquote>
<p>Selier</p>
</blockquote>
<p><img src="https://blog-img-goryj.oss-rg-china-mainland.aliyuncs.com/blogpost/20201213-LC-7.png" alt="并列改进"></p>
<p>等效电容</p>
<p>$$<br>C \simeq C_3 + C_4<br>$$</p>
<p>在该电路中，调整电容（调谐振点）并不会影响接入系数，所以这个电路可以作为波段振荡器</p>
]]></content>
      <categories>
        <category>硬件&amp;物理</category>
      </categories>
      <tags>
        <tag>振荡器</tag>
      </tags>
  </entry>
  <entry>
    <title>基于FIR的高效插值器</title>
    <url>/2024/08/20/FIR4Interpolator/</url>
    <content><![CDATA[<blockquote>
<p>在超声相控接收系统中，需要对采样的超声信号做超分辨率处理。考虑超声回波信号具有明显的窄带特性，就可以使用DSP课堂中的插0滤波法，选FIR的原因是可具有线性相移并且更加稳定。</p>
</blockquote>
<h2 id="FIR实现内插的数学原理"><a href="#FIR实现内插的数学原理" class="headerlink" title="FIR实现内插的数学原理"></a>FIR实现内插的数学原理</h2><p>N阶FIR滤波器的时域输入输出关系为：</p>
<p>$$<br>y[n] &#x3D; \sum^{N-1}_{k&#x3D;0} h[k]x[n-k]<br>$$</p>
<p>式中$y$是输出，$x$是输入，$h$是滤波器的系数。本文中不对FIR的DSP知识进行回顾，直接使用Matlab工具设计滤波器。但是有必要分析一下，为什么可以使用补0+FIR方案实现超分辨率，以及FIR滤波器的参数如何确定。</p>
<p>首先，我们对原信号$x[n]$做有限长离散傅里叶变换，得到频谱$X$：</p>
<p>$$<br>X[k] &#x3D; DFT(x[n])&#x3D;\sum_{n&#x3D;0}^{N-1} x[n]\cdot W_N^{kn}, 0\le k \le N-1<br>$$</p>
<p>同时逆变换有：</p>
<p>$$<br>x[n] &#x3D; IDFT(X[k]) &#x3D; \frac 1N \sum^{N-1}_{k&#x3D;0} X[k]W_N^{-kn},  0\le n\le N-1<br>$$</p>
<p>式中，$W_N&#x3D;e^{-j2\pi &#x2F;N}$是离散的旋转因子。如果在$x[i-1]$和$x[i]$之间插入$L-1$个0，那么插值后原本长度为$N$的序列$x[n]$变为了长度$(N-1)L+1$的序列$x_{ip}[n]$，注意$x_{ip}[jL]&#x3D;x[j]$，做DFT有：</p>
<p>$$<br>X_{ip}[k]&#x3D;DFT(x_{ip}[n]) &#x3D; \sum_{n&#x3D;0}^{(N-1)L} x_{ip}[n]\cdot W_{NL}^{kn}, 0\le k \le (N-1)L<br>$$</p>
<p>因为除了$n&#x3D;jL, 0\le j \le N-1$之外其他都是0，因此有：</p>
<p>$$<br>X_{ip}[k] &#x3D; \sum_{j&#x3D;0}^{N-1} x_{ip} [jL] \cdot W_{NL}^{kjL}, 0 \le k \le (N-1)L<br>$$</p>
<p>$$<br>&#x3D;\sum^{N-1}_{j&#x3D;0} x[j]\cdot W_N^{kj}，0\le k \le (N-1)L<br>\\<br>&#x3D;\begin{cases}<br>    X[k], &amp; 0 \le k \le N-1 \\<br>    X[k-N], &amp; N \le k \le 2N-1 \\<br>    \vdots<br>\end{cases}<br>$$</p>
<p>因此我们可以发现原频谱$X$和内插0后频谱$X_{ip}$发生了对应内插倍数的频谱复制。从信号与系统的角度，只要我们的频谱没有发生混叠，那就一定可以恢复出原信号，这里可以看出频谱复制后是绝对不可能发生频谱重叠，但是如果原本信号的频谱两端并不为0，那么因为滤波器的不理想性也会导致还原信号错误。</p>
<span id="more"></span>

<p>为了演示，笔者使用高斯幅度调制正弦信号的超声脉冲回波信号作为原信号$x[n]$，进行插0、FIR操作，并在每一步做FFT，如下图读者就可以很简单地理解到具体原理。</p>
<p><img src="https://blog-img-goryj.oss-rg-china-mainland.aliyuncs.com/blogpost/202408_FIR_1.jpg" alt="FIR内插原理"></p>
<p>对应的matlab分析代码：</p>
<figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line"><span class="built_in">figure</span>()</span><br><span class="line"></span><br><span class="line"><span class="comment">%% 生成脉冲数据</span></span><br><span class="line">F0 = <span class="number">2e6</span>;  <span class="comment">% 谐振频率</span></span><br><span class="line">bw_ratio = <span class="number">0.9</span>; <span class="comment">% 带宽分数</span></span><br><span class="line"></span><br><span class="line">Fs = <span class="number">10e6</span>; <span class="comment">% 采样频率</span></span><br><span class="line">T = <span class="number">6</span>*(<span class="number">1</span>/F0);  <span class="comment">% 信号采样时间范围，6个周期</span></span><br><span class="line"></span><br><span class="line"><span class="comment">% 创建时间向量</span></span><br><span class="line">t = -T:<span class="number">1</span>/Fs:T;</span><br><span class="line">t_length = <span class="built_in">size</span>(t);</span><br><span class="line">t_length = t_length(<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">% 产生高斯脉冲</span></span><br><span class="line">[yi, ~, ye] = gauspuls(t, F0, bw_ratio);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">% FFT分析</span></span><br><span class="line">[y_power,y_freq] = myEventFFT(yi,Fs/<span class="number">1e6</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">% 绘制高斯脉冲</span></span><br><span class="line">subplot(<span class="number">2</span>,<span class="number">3</span>,<span class="number">1</span>)</span><br><span class="line"><span class="built_in">plot</span>(t+T, yi, t+T, ye);</span><br><span class="line">title(<span class="string">&#x27;Gaussian Modulated Ultrasonic Signal&#x27;</span>);</span><br><span class="line">xlabel(<span class="string">&#x27;Time (s)&#x27;</span>);</span><br><span class="line">ylabel(<span class="string">&#x27;x[n] Amplitude&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">% 绘制频谱</span></span><br><span class="line">subplot(<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>)</span><br><span class="line"><span class="built_in">plot</span>(y_freq, y_power, <span class="string">&quot;LineWidth&quot;</span>,<span class="number">2</span>);</span><br><span class="line">title(<span class="string">&#x27;FFT(x[n])&#x27;</span>);</span><br><span class="line">xlabel(<span class="string">&quot;f /MHz&quot;</span>);</span><br><span class="line">ylabel(<span class="string">&quot;|P(f)|&quot;</span> );</span><br><span class="line"></span><br><span class="line"><span class="comment">%% 插0</span></span><br><span class="line"></span><br><span class="line">inter_mult = <span class="number">10</span>; <span class="comment">% 数据插值倍率</span></span><br><span class="line"></span><br><span class="line">y_after_inter = <span class="built_in">zeros</span>(<span class="number">1</span>,inter_mult*t_length);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> id = <span class="number">1</span>: t_length</span><br><span class="line">    y_after_inter(id*inter_mult) = yi(id);</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">t_after_inter = (<span class="number">1</span>:<span class="built_in">length</span>(y_after_inter))/<span class="built_in">length</span>(y_after_inter)*<span class="number">2</span>*T;</span><br><span class="line"></span><br><span class="line"><span class="comment">% FFT分析</span></span><br><span class="line">[y_inter_power,y_inter_freq] = myEventFFT(y_after_inter,Fs/<span class="number">1e6</span>*inter_mult);</span><br><span class="line"></span><br><span class="line"><span class="comment">% 绘制插值后的图像和频谱</span></span><br><span class="line">subplot(<span class="number">2</span>,<span class="number">3</span>,<span class="number">2</span>)</span><br><span class="line"><span class="built_in">plot</span>(t_after_inter,y_after_inter)</span><br><span class="line">title(<span class="string">&#x27;after interpolate&#x27;</span>);</span><br><span class="line">xlabel(<span class="string">&#x27;Time (s)&#x27;</span>);</span><br><span class="line">ylabel(<span class="string">&#x27;x_&#123;ip&#125;[n] Amplitude&#x27;</span>);</span><br><span class="line"></span><br><span class="line">subplot(<span class="number">2</span>,<span class="number">3</span>,<span class="number">5</span>)</span><br><span class="line"><span class="built_in">plot</span>(y_inter_freq, y_inter_power, <span class="string">&quot;LineWidth&quot;</span>,<span class="number">2</span>);</span><br><span class="line">title(<span class="string">&#x27;FFT(x_&#123;ip&#125;[n])&#x27;</span>);</span><br><span class="line">xlabel(<span class="string">&quot;f /MHz&quot;</span>);</span><br><span class="line">ylabel(<span class="string">&quot;|P(f)|&quot;</span> );</span><br><span class="line"></span><br><span class="line"><span class="comment">%% FIR带通滤波</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">% 设置滤波器的频率点</span></span><br><span class="line"><span class="comment">% 归一化： 实际频率/(采样率/2)</span></span><br><span class="line">f_fir_lp = [<span class="number">0</span> (F0*bw_ratio)/(Fs*inter_mult/<span class="number">2</span>) (F0*bw_ratio)/(Fs*inter_mult/<span class="number">2</span>) ...</span><br><span class="line">            (F0*(<span class="number">2</span>-bw_ratio))/(Fs*inter_mult/<span class="number">2</span>) (F0*(<span class="number">2</span>-bw_ratio))/(Fs*inter_mult/<span class="number">2</span>) <span class="number">1</span>];</span><br><span class="line">m_fir_lp = [<span class="number">0</span> <span class="number">0</span> <span class="number">1</span> <span class="number">1</span> <span class="number">0</span> <span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">b_fir_lp = fir2(<span class="number">80</span>,f_fir_lp,m_fir_lp);</span><br><span class="line"></span><br><span class="line"><span class="comment">% 换带通方案更好</span></span><br><span class="line">f_fir_bp = [(F0*bw_ratio)/(Fs*inter_mult/<span class="number">2</span>) (F0*(<span class="number">2</span>-bw_ratio))/(Fs*inter_mult/<span class="number">2</span>)];</span><br><span class="line">b_fir_bp = fir1(<span class="number">80</span>,f_fir_bp);</span><br><span class="line"></span><br><span class="line"><span class="comment">%显示滤波器特性</span></span><br><span class="line"><span class="comment">% freqz(b_fir_bp,1)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">% 滤波</span></span><br><span class="line">y_after_filter = filter(b_fir_bp,<span class="number">1</span>,y_after_inter);</span><br><span class="line"></span><br><span class="line"><span class="comment">% FFT分析</span></span><br><span class="line">[y_fil_power,y_fil_freq] = myEventFFT(y_after_filter,Fs/<span class="number">1e6</span>*inter_mult);</span><br><span class="line"></span><br><span class="line"><span class="comment">% 绘制滤波后的图像和频谱</span></span><br><span class="line">subplot(<span class="number">2</span>,<span class="number">3</span>,<span class="number">3</span>)</span><br><span class="line"><span class="built_in">plot</span>(t_after_inter,y_after_filter)</span><br><span class="line">title(<span class="string">&#x27;after filter&#x27;</span>);</span><br><span class="line">xlabel(<span class="string">&#x27;Time (s)&#x27;</span>);</span><br><span class="line">ylabel(<span class="string">&#x27;x_&#123;f&#125;[n] Amplitude&#x27;</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">subplot(<span class="number">2</span>,<span class="number">3</span>,<span class="number">6</span>)</span><br><span class="line"><span class="built_in">plot</span>(y_fil_freq, y_fil_power, <span class="string">&quot;LineWidth&quot;</span>,<span class="number">2</span>);</span><br><span class="line">title(<span class="string">&#x27;FFT(x_&#123;f&#125;[n])&#x27;</span>);</span><br><span class="line">xlabel(<span class="string">&quot;f /MHz&quot;</span>);</span><br><span class="line">ylabel(<span class="string">&quot;|P(f)|&quot;</span> );</span><br><span class="line"></span><br><span class="line"><span class="comment">%% 定义辅助函数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="params">[vec_power,vec_freq]</span> = <span class="title">myEventFFT</span><span class="params">(vec_smpData, F_s)</span></span></span><br><span class="line"><span class="comment">%求采样数据的FFT变换，绘图，返回格式 [单边功率, 频率]</span></span><br><span class="line"><span class="comment">%   采样率共用导入数据时候的全局参数 F_s</span></span><br><span class="line"><span class="comment">% </span></span><br><span class="line"><span class="comment">% global F_s;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">% 数据长度</span></span><br><span class="line">L_smpData = <span class="built_in">length</span>(vec_smpData);</span><br><span class="line"></span><br><span class="line"><span class="comment">% 求频谱</span></span><br><span class="line">vec_freq = F_s/L_smpData*(<span class="number">0</span>:(L_smpData/<span class="number">2</span>));  <span class="comment">% 频率轴</span></span><br><span class="line"></span><br><span class="line">P2 = <span class="built_in">abs</span>( fft(vec_smpData) / L_smpData);  <span class="comment">%FFT</span></span><br><span class="line">P1 = P2(<span class="number">1</span> : L_smpData/<span class="number">2</span>+<span class="number">1</span>); <span class="comment">% 取单边</span></span><br><span class="line">P1(<span class="number">2</span>:<span class="keyword">end</span><span class="number">-1</span>) = <span class="number">2</span>*P1(<span class="number">2</span>:<span class="keyword">end</span><span class="number">-1</span>);</span><br><span class="line"></span><br><span class="line">vec_power = P1;</span><br><span class="line"></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="内插器RTL框图"><a href="#内插器RTL框图" class="headerlink" title="内插器RTL框图"></a>内插器RTL框图</h2><p>用于内插的FIR滤波器都可以做运算优化，因为插0后有很多运算都是0乘操作。比如上例中设计了<code>N=80</code>阶滤波器，数据倍率为<code>L=10</code>，若此时推入滤波器的$x_{ip}[n]$为有效采样数据，则：</p>
<p>$$<br>y[n]  &#x3D; \sum_{k&#x3D;0}^{79} h[k]x_{ip}[n-k] \\<br>&#x3D; \sum_{k}^{0,10,20,\cdots,70} h[k]x_{ip}[n-k] \\<br>&#x3D;\sum_{i&#x3D;0}^{7} h[i\cdot 10] x_{ip}[n-i \cdot 10]<br>$$</p>
<p>也就是可以优化为只有<code>N/L=8</code>次乘法操作。类似的，考虑前一时钟推入的为有效采样数据，此时时钟推入的为插值的0，那么：</p>
<p>$$<br>y[n]&#x3D; \sum_{i&#x3D;0}^{7} h[i\cdot 10-1]x_{ip}[n-i \cdot 10-1]<br>$$</p>
<p>还是只进行<code>8</code>次乘法操作，并且会发现在<code>L=10</code>次运算中，有效的$x_{ip}$是同一组数据。因此，作如下图设计，首先每隔<code>L</code>次时钟，滑动更新<code>smpData</code>寄存器数据；而系数全部存在RAM中，总共有<code>N/L=8</code>个RAM读端口，RAM地址由一个计数器提供，从而实现滑动系数；计数器给每个RAM的地址依次相差<code>L</code>。</p>
<p>根据上述优化分析，可以设计如下插值器的框图。</p>
<p><img src="https://blog-img-goryj.oss-rg-china-mainland.aliyuncs.com/blogpost/202408_FIR_2.jpg" alt="插值器框图"></p>
<h2 id="具体实现"><a href="#具体实现" class="headerlink" title="具体实现"></a>具体实现</h2><h3 id="使用DSP48E2原语"><a href="#使用DSP48E2原语" class="headerlink" title="使用DSP48E2原语"></a>使用DSP48E2原语</h3><p>Ultrascale系列的DSP单元，如下图支持加法、乘法、逻辑判断。</p>
<p><img src="https://blog-img-goryj.oss-rg-china-mainland.aliyuncs.com/blogpost/202408_FIR_3.png" alt="DSP简图"></p>
<p>直接基于DSP48E2原语进行设计，能够获得很多硬件层面的加速优势和功耗优势，比如：</p>
<ul>
<li>实现更低能耗和高性能的流水线设计</li>
<li>使用BRAM或者UltraRAM来存储滤波器参数，从而优化CLB的使用</li>
<li>如果不用乘法可以<code>USE_MUL=NONE</code>来减小功耗</li>
<li>当多个DSP间有数据传递的关系，可以使用专用的级联（Cascade）资源从而减小对通用布线资源的占用。专用资源也能够获得更好的运算性能和更低的功耗</li>
<li>可以使用时间复用的方法，在低速应用时</li>
</ul>
<p><img src="https://blog-img-goryj.oss-rg-china-mainland.aliyuncs.com/blogpost/202408_FIR_4.png" alt="DSP48E2"></p>
<h2 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h2><ul>
<li>PG323 DSP Macro LogiCORE IP Product Guide</li>
<li><strong>UG579</strong> UltraScale Architecture DSP Slice User Guide</li>
</ul>
]]></content>
      <categories>
        <category>FPGA&amp;计算加速&amp;芯片设计</category>
      </categories>
      <tags>
        <tag>FPGA</tag>
        <tag>DSP</tag>
        <tag>FIR</tag>
      </tags>
  </entry>
  <entry>
    <title>固定翼飞行器动力学分析</title>
    <url>/2022/02/05/airplane-Model/</url>
    <content><![CDATA[<blockquote>
<p>前言：固定翼飞行器相对多旋翼飞行器具有载荷大、航程远等特性，在B端、C端、M端皆占大半江山。此次新年之际，笔者亲手搭建了一台性价比较高的“冲浪者”，并且尝试一下午就成功使用日本手首飞成功，有些玩航模的朋友夸俺天赋好😆但这其实离不开笔者在上手之前学习的固定翼相关空气动力学，所以个人认为很有必要记录一下，以便日后其他小伙伴借鉴快速入门</p>
<blockquote>
<p>本次飞行视频已上次至<strong>BiliBili</strong>视频平台，欢迎点击<a href="https://www.bilibili.com/video/BV1rS4y1y7YG/">传送门</a>观看</p>
</blockquote>
</blockquote>
<h2 id="机翼的空气动力特性"><a href="#机翼的空气动力特性" class="headerlink" title="机翼的空气动力特性"></a>机翼的空气动力特性</h2><p>为了方便分析，一般取机翼的切面形状进行空气动力学计算，即翼型。</p>
<p><img src="https://blog-img-goryj.oss-rg-china-mainland.aliyuncs.com/blogpost/20220205-airplane-1.png" alt="翼型概念"></p>
<p>下图为几种常见的翼型，在不同用途的飞行器上有着各自的优势，具体我们留到下方<strong>常见翼型特性</strong>一节讲解分析。</p>
<p><img src="https://blog-img-goryj.oss-rg-china-mainland.aliyuncs.com/blogpost/20220205-airplane-2.png" alt="各种翼型"></p>
<p>笔者玩的<em><strong>冲浪者</strong></em>主机翼显然采用的是超临界型翼型设计，下图展示的为将机翼拆下后翅根处的截面。（都这么努力了😁是不是要扫描文末的二维码请咖啡呀☕）</p>
<p><img src="https://blog-img-goryj.oss-rg-china-mainland.aliyuncs.com/blogpost/20220205-airplane-3.jpg" alt="冲浪者翼型"></p>
<p>接下来，对翼型进行理论分析，介绍各项重要参数以及升力计算方法。图中，贯穿中央的水平<strong>实</strong>直线名为<code>展弦</code>；还有一根从前缘到后缘，贯穿内切圆圆心的<strong>虚</strong>线名为<code>中弧线</code>；翼型的上包实线名为<code>上弧线</code>；翼型的下包实线名为<code>下弧线</code>；其他关键机械设计参数皆标于图上。</p>
<span id="more"></span>

<p><img src="https://blog-img-goryj.oss-rg-china-mainland.aliyuncs.com/blogpost/20220205-airplane-4.png" alt="机翼参数"></p>
<p>设计参数可引出以下参数：</p>
<ul>
<li>相对弯度：表示翼型的不对称程度，现代飞机的相对弯度为<code>0~2%</code><br>  $$<br>  \overline{f} &#x3D; \frac{f_{\max}}{c_w} \times 100%<br>  $$</li>
<li>最大弯度位置<br>  $$<br>  \overline{x_f} &#x3D; \frac{x_f}{c_w} \times 100 %<br>  $$</li>
<li>厚弦比：翼型的最大厚度与翼弦的比值，现代飞机参数范围一般<code>3~16%</code>，超声速采用厚弦比较小的薄翼，低速飞机用参数较大的厚翼<br>  $$<br>  \overline{c} &#x3D; \frac{c_{\max}}{c_w} \times 100%<br>  $$</li>
<li>最大厚度位置：该参数同采用相对翼弦的表示法，现代飞机参数范围一般<code>30~50%</code>，亚声速<code>25~30</code>，超声速<code>40~50%</code><br>  $$<br>  \overline{x_c} &#x3D; \frac{x_c}{c_w} \times 100 %<br>  $$</li>
</ul>
<p>还有一个重要的实时参数名为<em><strong>迎角</strong></em>，如下图所示为吹来的气流与机翼的夹角，该参数有正负，一般取翼弦方向为<code>0</code>。正如接下来的计算过程展现的，该参数将极大地影响飞机的升力，并且飞行时大多数工作于正迎角状态。</p>
<p><img src="https://blog-img-goryj.oss-rg-china-mainland.aliyuncs.com/blogpost/20220205-airplane-5.png" alt="迎角"></p>
<p>我们将使用到最简单的<a href="https://baike.baidu.com/item/%E4%BC%AF%E5%8A%AA%E5%88%A9%E5%8E%9F%E7%90%86">伯努利原理</a>：</p>
<p>$$<br>p_1+\frac{1}{2} \rho v_1^2 + \rho gh_1 &#x3D; p_2+\frac{1}{2} \rho v_2^2 + \rho gh_2<br>$$</p>
<blockquote>
<p>NOTE⚠：伯努利方程只能用在粘度忽略、不可压缩的理想流体，所以基于此的分析只能用在低速飞行，超声速飞行后面专门讲解</p>
</blockquote>
<p><img src="https://blog-img-goryj.oss-rg-china-mainland.aliyuncs.com/blogpost/20220205-airplane-6.png" alt="升力原理"></p>
<p>由于机翼一般较薄，所以如上图所示的流管，在远处来流与翼上切面有关系：<br>$$<br>p_\infty + \frac{1}{2} \rho_\infty v^2_\infty &#x3D; p +\frac{1}{2} \rho v^2<br>$$</p>
<p>整理：</p>
<p>$$<br>p-p_\infty &#x3D; \frac 12 \rho_\infty v^2_\infty - \frac{1}{2} \rho v^2<br>\\<br>\frac{p-p_\infty}{\frac 12 \rho_\infty v^2_\infty} &#x3D; 1-\frac{\rho v^2}{\rho_\infty v^2_\infty}<br>$$</p>
<p>低速飞行时，密度变化不明显；且根据连续性方程。得到压力系数表示：<br>$$<br>\because \rho \simeq \rho_\infty , v_\infty \cdot S_\infty &#x3D; v \cdot S<br>\\<br>\therefore \overline{p} &#x3D; \frac{p-p_\infty}{\frac 12 \rho_\infty v^2_\infty} \simeq 1-\frac{v^2}{v^2_\infty} &#x3D; 1-(\frac{S_\infty}{S})^2<br>$$</p>
<p><strong>重要结论</strong>：压力系数只与流管切面积有关，而流管的情况可以通过<a href="https://baike.baidu.com/item/%E7%83%9F%E9%A3%8E%E6%B4%9E">烟线风洞实验</a>获知。</p>
<p>则此时可以将机翼上表面需要求解的点的压力表示为：</p>
<p>$$<br>p_{上} &#x3D; p_\infty + \frac12 \rho v^2_\infty\overline{p}_{上}<br>$$</p>
<p>下表面表示为：</p>
<p>$$<br>p_{下} &#x3D; p_\infty + \frac12 \rho v^2_\infty\overline{p}_{下}<br>$$</p>
<p>则某个翼型受升力为：</p>
<p>$$<br>L(b) &#x3D; \int_0^{c_w} ( p_{下} - p_{上}) \cdot dx<br>&#x3D; \int_0^{c_w} \frac12 \rho v^2_\infty ( \overline{p} _{下} - \overline{p} _{上} ) \cdot dx<br>$$</p>
<p>那么想要得到<strong>整个机翼受到的升力</strong>，在沿翼展方向（垂直于翼型）作积分即可：</p>
<p>$$<br>F &#x3D; \int_0^{b_w} L(b) \cdot dy &#x3D; \int_0^{b_w} \int_0^{c_w} \frac12 \rho v^2_\infty ( \overline{p} _{下} - \overline{p} _{上}) \cdot dx \cdot dy<br>$$</p>
<blockquote>
<p>总结一下：要设计出一个好的机翼，首先要先搞到每个点的压力系数，然后作二维积分；还有：</p>
<ol>
<li>若飞行器在太空中，没有介质（密度0），无法获得升力；</li>
<li>若飞行器相对介质（空气）速度为0，也无法获得升力；</li>
<li>机翼越大（面积越大），获得的升力越大，所以滑翔机等最求续航的飞行器一般机翼很大；</li>
<li>机翼获得的不一定就是朝机翼向上力！非常显然迎角不同时，力的方向可能是升力也是压力。一般正迎角是升力，但还有特殊情况，比如下面将讲到的失速以及飞机倒飞（压力变升力）</li>
</ol>
</blockquote>
<h3 id="机翼平面形状"><a href="#机翼平面形状" class="headerlink" title="机翼平面形状"></a>机翼平面形状</h3><p>上面算的升力公式要作二维积分，对下图所示的各种奇怪形状的机翼来说简直是计算灾难。</p>
<p><img src="https://blog-img-goryj.oss-rg-china-mainland.aliyuncs.com/blogpost/20220205-airplane-7.png" alt="机翼平面形状"></p>
<p>在简化计算之前，先介绍几个用来定义机翼平面形状的参数：</p>
<ul>
<li>机翼面积$S$：机翼垂直投影面积大小</li>
<li>翼展$b_w$：机翼最左翼尖到最右翼尖之间距离</li>
<li>平均翼弦<br>  $$<br>  c_w &#x3D; \frac{S}{b_w}<br>  $$</li>
<li>展弦比$\lambda$：翼展$b_w$与平均翼弦$c_w$之比，现代歼击机范围<code>2~5</code>，轰炸机、运输机<code>7~12</code>，滑翔机<code>12~16</code></li>
<li>根尖比$\eta$：机翼根部（靠近机身）的翼弦$c_g$于位于翼尖处翼弦$c_s$之比</li>
<li>后掠角$\chi$：这个参数常见于讨论一些外型炫酷的<a href="https://baike.baidu.com/item/%E5%90%8E%E6%8E%A0%E7%BF%BC/7960782">后掠翼现代飞机</a>，具体吧又有很多种后掠角，比如下图中标有的前缘后掠角$\chi_0$，1&#x2F;4弦线后掠角$\chi_{0.25}$，后缘后掠角$\chi_1$</li>
<li><strong>平均空气动力弦</strong>$c_A$：对后掠翼这种从翼根到翼尖一直在变化的形状计算升力，简直是灾难，所以人们定义了该参数，假设存在一个等效的矩形机翼（等效要求：面积相同、俯仰力矩相同、气动力合力相同）。这样呢，一次设计，多次使用，不然风洞一吹多贵啊，超算一开更贵</li>
</ul>
<p><img src="https://blog-img-goryj.oss-rg-china-mainland.aliyuncs.com/blogpost/20220205-airplane-8.png" alt="机翼形状参数"></p>
<h3 id="升力系数"><a href="#升力系数" class="headerlink" title="升力系数"></a>升力系数</h3><p>有了平均空气动力弦，原本升力公式就可以简化为：</p>
<p>$$<br>F &#x3D; \frac12 \rho v^2_\infty c_A \int_0^{c_w} ( \overline{p} _{下} - \overline{p} _{上}) \cdot dx<br>\\<br>\overset{\overline{x}&#x3D;\frac{x}{c_w}}{&#x3D;}<br>\frac12 \rho v^2_\infty c_A c_w \int_0^{1} ( \overline{p} _{下} - \overline{p} _{上}) \cdot d\overline{x}<br>$$</p>
<p>所以我们提出升力系数：</p>
<p>$$<br>C_L &#x3D; \int_0^{1} ( \overline{p} _{下} - \overline{p} _{上}) \cdot d\overline{x}<br>$$</p>
<p>再用等效机翼面积替换$c_A c_w$，得到：</p>
<p>$$<br>F &#x3D; C_L \cdot \frac{1}{2} \rho v^2_\infty S<br>$$</p>
<p>这样嘞，就可以为移植机翼提供一个参考了。比如同一款机翼，缩放后升力系数是一样的。并且，我们可以测定绘制出下图所示的升力系数随迎角变化的规律，$\delta$是襟翼角度。</p>
<p><img src="https://blog-img-goryj.oss-rg-china-mainland.aliyuncs.com/blogpost/20220205-airplane-9.png" alt="升力系数曲线"></p>
<p>这里注意几个一般性原则：</p>
<ul>
<li>迎角不大时，升力系数与迎角成线性关系<br>  $$<br>  C_L &#x3D; k(\alpha - \alpha_0)<br>  $$</li>
<li>迎角较大时，升力系数导数随迎角增大开始减小</li>
<li>迎角越过某个<strong>临界迎角</strong>时，升力系数导数开始变为负</li>
</ul>
<p>还有几个关键的参数：</p>
<ul>
<li>零升力迎角$\alpha_0$：不同翼型该参数不同，与相对弯度参数相关性很大，对称翼型的$\alpha_0 &#x3D; 0$</li>
<li>临界迎角$\alpha_{临}$与对应的$C_{L-\max}$：主要与相对弯度、最大弯度位置、厚弦比、前缘半径有关</li>
</ul>
<h3 id="失速"><a href="#失速" class="headerlink" title="失速"></a>失速</h3><ol>
<li>小迎角时：机翼上表面最低压力点靠后，涡流区小</li>
<li>逐渐增大迎角：最低压力点前移，涡流区扩大</li>
<li>迎角增大至临界迎角：分离点急速前移，涡流区急剧扩大，气流贴着机翼表面稳定流动被破坏</li>
<li>继续增大迎角：升力降低+阻力急剧增大，飞机剧烈抖动，高度快速下降，前进速度锐减（特别离谱的会坠入螺旋）</li>
</ol>
<p>所以，失速迎角就是临界迎角。</p>
<h3 id="翼尖涡流"><a href="#翼尖涡流" class="headerlink" title="翼尖涡流"></a>翼尖涡流</h3><p>如下图所示，机翼正常工作时，下表面的压力大于上表面的压力，所以气流会绕过翼尖流到上表面，形成了翼尖涡流。</p>
<p><img src="https://blog-img-goryj.oss-rg-china-mainland.aliyuncs.com/blogpost/20220205-airplane-10.png" alt="涡流产生原理"></p>
<p>下图所示，是大型客机降落时产生的涡流。所以机场的飞机起飞和降落时，机与机之间需要等待一段时间，直至上一架产生的涡流衰减至不影响安全飞行。</p>
<p><img src="https://blog-img-goryj.oss-rg-china-mainland.aliyuncs.com/blogpost/20220205-airplane-11.png" alt="大型客机涡流"></p>
<p>同样的，冲浪者的机翼设计也是充分考虑到了翼尖涡流，做成两边翘起的形状，这样可以较好地减小涡流作用带来的诱导阻力。</p>
<p><img src="https://blog-img-goryj.oss-rg-china-mainland.aliyuncs.com/blogpost/20220205-airplane-12.jpg" alt="冲浪者翼尾"></p>
<h3 id="副翼与襟翼"><a href="#副翼与襟翼" class="headerlink" title="副翼与襟翼"></a>副翼与襟翼</h3><p>冲浪者的主机翼控制较为简单，只有靠近翅膀端点处的副翼（提供横滚控制）。而复杂的现代飞行器，如下图一般由副翼、襟翼、扰流板等构成。</p>
<p><img src="https://blog-img-goryj.oss-rg-china-mainland.aliyuncs.com/blogpost/20220205-airplane-13.png" alt="机翼构成"></p>
<p>为了提供较大的横滚力矩（$\vec T &#x3D; \vec F\times \vec l$），所以副翼一般设置在靠近主机翼外侧；而襟翼（下图所示各种常见结构）是为了在降落或起飞时提供大的升力，而又不产生影响稳定性的力矩，所以一般靠近内部；扰流板从结构上来看，方向与襟翼相反，所以在降落的时候打开，可以抵消大量升力，同时又提供了大量阻力，使得减速更快。</p>
<p><img src="https://blog-img-goryj.oss-rg-china-mainland.aliyuncs.com/blogpost/20220205-airplane-14.png" alt="各种襟翼"></p>
<h3 id="常见翼型特性"><a href="#常见翼型特性" class="headerlink" title="常见翼型特性"></a>常见翼型特性</h3><blockquote>
<p>推荐一个软件：<code>profili</code>，这里面有很多大组织开源的翼型参考设计。</p>
</blockquote>
<p>这玩意我也还在琢磨中，因为论文上说<strong>超临界翼型</strong>超声速性能更好（激波少），但是冲浪者是属于滑翔机类型，所以笔者后续边玩边学，搞清楚了再写哈😄</p>
<h2 id="固定翼飞行控制原理"><a href="#固定翼飞行控制原理" class="headerlink" title="固定翼飞行控制原理"></a>固定翼飞行控制原理</h2><p>在开始之前，我们先补充一下常规飞机的尾部控制结构，如下图分别是：</p>
<ol>
<li>方向舵：位于垂直尾翼（对称翼型）上，控制飞行器的左右偏转</li>
<li>升降舵：位于水平尾翼（不一定是对称翼型）上，控制飞行器抬头和低头</li>
</ol>
<p><img src="https://blog-img-goryj.oss-rg-china-mainland.aliyuncs.com/blogpost/20220205-airplane-20.jpeg" alt="机尾结构"></p>
<p>如下图所示，当升降舵<strong>向下</strong>偏转时，产生向上的升力，此时相对飞机的重心来说提供的力矩使飞机<strong>低头</strong>；当升降舵<strong>向上</strong>时，同理受力，飞机<strong>抬头</strong>。这里注意，左右升降舵是同向运动的（如果左右平尾升力不同，会给飞机一个横滚力矩，并且是多少会出现的）。</p>
<p><img src="https://blog-img-goryj.oss-rg-china-mainland.aliyuncs.com/blogpost/20220205-airplane-21.gif" alt="升降舵"></p>
<p>下图所示是方向舵工作原理，舵面<strong>左偏</strong>（从机身后向前看）则垂尾压力向右，到飞机的重心产生的力矩使飞机整体向<strong>左转</strong>；同理，舵面<strong>右偏</strong>，飞机<strong>右转</strong>。</p>
<p><img src="https://blog-img-goryj.oss-rg-china-mainland.aliyuncs.com/blogpost/20220205-airplane-22.gif" alt="方向舵"></p>
<p>横滚舵，就是主机翼的副翼，之前已经说过原理不再赘述。需要值得一提的是，根据网友经验以及笔者亲测，对于冲浪者这类飞行器来说，打方向舵效果在低速的时候转向效果不明显，如果需要大幅度地回旋，建议采用：</p>
<ol>
<li>往预偏转方向横滚机身，使原本朝上的升力倾斜（可分解为水平的向心力和垂直的部分升力）</li>
<li>理论上此时升力必定比原本小，所以操作升降舵抬高机头，获得更多的升力；或者适当加大油门</li>
</ol>
<p><img src="https://blog-img-goryj.oss-rg-china-mainland.aliyuncs.com/blogpost/20220205-airplane-23.gif" alt="横滚舵"></p>
<h2 id="高速飞行特性"><a href="#高速飞行特性" class="headerlink" title="高速飞行特性"></a>高速飞行特性</h2><p>为了不误人子弟，研究透了再补充这一部分。并且玩航模一般也玩不到声速吧</p>
<h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><ul>
<li>李国辉. 飞行原理与仿真建模.北京理工大学出版社.</li>
<li>刘子敬. 超临界翼型优化设计关键技术研究[D].南京航空航天大学,2018.DOI:10.27239&#x2F;d.cnki.gnhhu.2018.000265.</li>
<li>陆超. 翼型改型对超临界翼型气动性能影响的研究[D].沈阳航空工业学院,2009.</li>
</ul>
]]></content>
      <categories>
        <category>硬件&amp;物理</category>
      </categories>
      <tags>
        <tag>动力学分析</tag>
        <tag>固定翼</tag>
      </tags>
  </entry>
  <entry>
    <title>天线</title>
    <url>/2021/08/07/antenna/</url>
    <content><![CDATA[<blockquote>
<p>前言：继上一篇<a href="/2021/06/23/%E9%98%BB%E6%8A%97%E5%8C%B9%E9%85%8D%E5%92%8C%E6%9E%9D%E8%8A%82%E5%8C%B9%E9%85%8D/">传输线阻抗匹配</a>文章后，笔者又接了一个智能医疗项目（内容保密），用到一款集成蓝牙射频功能的MCU，需要做的就是设计一个PCB板载微带天线。由于需要自学通信天线设计，所以就顺手将学习内容记录下来以供有兴趣速成的朋友学习和后续查阅</p>
</blockquote>
<h2 id="天线的那些事"><a href="#天线的那些事" class="headerlink" title="天线的那些事"></a>天线的那些事</h2><blockquote>
<p>要自学本文，需要先完全掌握（上一篇文章中的）微波传输线相关知识和基础的大学物理电磁学</p>
</blockquote>
<p>天线理论的基础是对称振子（有磁基本振子和电基本振子两种），下图是天线的原理简图。可以大概观察到，天线的大小是和信号波长相当的</p>
<p><img src="https://blog-img-goryj.oss-rg-china-mainland.aliyuncs.com/blogpost/20210807-ANT-1.png" alt="原理简图"></p>
<p>目前人类正在使用的无线电波频率，下至Hz，上至百GHz不等。</p>
<span id="more"></span>

<ul>
<li>频率越低，传播损耗越小，覆盖距离越远，绕射能力也越强。但是低频段的频率资源紧张，系统容量有限，因此低频段的无线电波主要应用于广播、电视、寻呼等系统。注意：超长波（Hz数量级）一般是军事上用的，比如核潜艇</li>
<li>频率越高，传播损耗越大，覆盖距离越近，绕射能力越弱，但是<strong>天线越小越容易集成</strong>。另外，频率越高，技术难度也越大，系统的成本相应提高。我们一般用的蓝牙、WiFi的频率是2.4GHz，通信范围就是几个房间</li>
</ul>
<blockquote>
<p>Tips：这些频率不是你想用就用的，<strong>无线电频谱资源也属于国家资源的一种</strong>，合法使用是要交钱的！只有2.4GHz比较特别，这是专门一个小频带在通信领域中叫做ISM（Industry Science Medicine）全世界公开通用使用的无线频段，是免费无需申请就可以使用的，这也是为什么蓝牙和普通版Wifi是这个频率，而5GHz的Wifi普遍贵很多的原因。（附：<a href="http://www.srrc.org.cn/kindeditor/attached/file/20190704/20190704100047_2979.pdf">中国频率划分政府文件</a>)</p>
<blockquote>
<p>经常在新闻上看到5G网络成本高、基站密度相比4G更大也是和频谱有关，移动数据网络4G的频率和频段是：1880-1900MHz、2320-2370MHz、2575-2635MHz；5G的频率和频段频段：3300-3400MHz（原则上限室内使用）、3400-3600MHz和4800-5000MHz。</p>
</blockquote>
</blockquote>
<p>接下来进入硬核的天线分析环节，且本文中讨论的内容将主要围绕消费电子领域的天线设计</p>
<h2 id="天线分类"><a href="#天线分类" class="headerlink" title="天线分类"></a>天线分类</h2><p>根据天线结构分：</p>
<ul>
<li>线天线：半径远小于信号波长的金属导线，长度远大于半径；用于长、中、短波通信</li>
<li>面天线：整块金属板或者导线栅格组成的面型天线阵列，面积远大于波长的平方；用于微波</li>
</ul>
<p>也可以根据天线波长分：</p>
<ul>
<li>微波天线</li>
<li>超短波天线</li>
<li>短波天线</li>
<li>中波天线</li>
<li>长波天线</li>
<li>超长波天线</li>
</ul>
<p>还有一种和我们最息息相关的，方向性：</p>
<ul>
<li>全向天线：我们常常希望WiFi天线是全向的，否则走两步信号就变差了</li>
<li>定向天线：雷达的重要部分</li>
</ul>
<h2 id="重要参数指标"><a href="#重要参数指标" class="headerlink" title="重要参数指标"></a>重要参数指标</h2><h3 id="方向图"><a href="#方向图" class="headerlink" title="方向图"></a>方向图</h3><p>天线的方向图表征天线的方向特征，有：振幅、功率、相位等方向图。这个玩意一般是三维的，像下面这样：</p>
<p><img src="https://blog-img-goryj.oss-rg-china-mainland.aliyuncs.com/blogpost/20210807-ANT-5.png" alt="三维方向图"></p>
<p>但为了方便分析，我们选用通过天线最大辐射方向上的两个互相垂直的刨面图（主平面）来描述，如下：</p>
<p><img src="https://blog-img-goryj.oss-rg-china-mainland.aliyuncs.com/blogpost/20210807-ANT-2.jpeg" alt="二维方向剖图"></p>
<p>辐射区域最大强度最强的称为主瓣（主波束），其他是旁瓣。正如图中标注的，一个天线在方向特性上可引出参数：</p>
<ul>
<li>波瓣宽度和主瓣宽度<br>  主瓣的波瓣宽度就是主瓣宽度，如果把主瓣场强最大的位置强度归一化为1，那么场强为0.707（即半功率点）的两个点之间的宽度，称为主瓣宽度</li>
<li>天线副瓣电平<br>  天线最大辐射强度与天线最大副瓣辐射强度之比</li>
<li>方向系数<blockquote>
<p>表征天线辐射能量集中程度的参数</p>
</blockquote>
  在某一距离处，天线某方向（一般是最大辐射方向）上的辐射功率流密度与<strong>相同辐射功率</strong>的理想无向天线的功率流密度比：<br>  $$<br>  D &#x3D; \frac{S(\theta,\phi)}{S_0} &#x3D; \frac{|E(\theta,\phi)|^2}{|E_0|^2}<br>  $$<br>  可以分析，无向天线发出的是均匀球面波，所以有：<br>  $$<br>  D &#x3D; \frac{S(\theta,\phi)}{P&#x2F;(4\pi r^2)} &#x3D; \frac{4\pi}{\int^{2\pi}_0\int^{\pi}_0 |F(\theta,\phi)|^2 \sin\theta d\theta d\phi}<br>  $$<br>  其中F为归一化的天线电场方向函数。在工程上，一般用分贝表示：<br>  $$<br>  D(dBi) &#x3D; 10\lg D<br>  $$</li>
</ul>
<h3 id="能量和效益"><a href="#能量和效益" class="headerlink" title="能量和效益"></a>能量和效益</h3><ul>
<li><p>天线辐射效率<br>  天线辐射功率与天线输入功率之比<br>  $$<br>  \eta_{rad} &#x3D; \frac{P_{rad}}{P_{in}} &#x3D; \frac{P_{rad}}{P_{rad}+P_{L}}<br>  $$<br>  因为天线辐射出去的能量，是向空间中不断传播的，永远不会回到发射天线上，所以也可以使用天线（等效）的辐射电阻和损耗电阻进行度量<br>  $$<br>  \eta_{rad} &#x3D; \frac{R_{rad}}{R_{rad}+R_{L}}<br>  $$</p>
</li>
<li><p>天线增益<br>  上面的天线方向增益体现了天线方向图的特性，不能很好的考虑到天线效率的影响。所以有天线增益定义，天线在<strong>空间某点</strong>（一般选主瓣中心方向）产生的功率（电场强平方）与理想无方向点源天线在同点产生功率比：<br>  $$<br>  G(\theta,\phi) &#x3D; \frac{|E(\theta,\phi)|^2}{|E_0|^2}<br>  $$<br>  显然有：<br>  $$<br>  G &#x3D; D\cdot \eta_{rad}<br>  $$<br>  也就是如果没有天线损耗，天线增益和方向系数是一样的</p>
</li>
<li><p>接收和发射功率</p>
<p>  在工程上，天线发送和接收电磁波的功率，常常采用dB法：</p>
<p>  $$<br>  P(dBm) &#x3D; 10\lg(\frac{P}{1mW})<br>  $$</p>
<blockquote>
<p>接收灵敏度：虽然这个指标并不只是由天线决定的，而是整个接收机，但还是要提一下，因为在工程和日常使用时常常见到。接收灵敏度是指无线电可靠接收数据的最低功率，接收器灵敏度高通俗点讲就是很微弱的信号也能被检测到。</p>
<blockquote>
<p>一般来说，这个指标是负值，比如<code>802.15.4</code>标准规定<code>2.4GHz</code>射频的最低接收器灵敏度为<code>-85 dBm</code>（相当于<code>3pW</code>），<code>900 MHz</code>为<code>-92 dBm</code>。这个值越负，代表接收机正常通信能接收的信号越微弱，射频间隔距离越大，所需射频功率也更少</p>
</blockquote>
</blockquote>
</li>
</ul>
<h3 id="天线的连接"><a href="#天线的连接" class="headerlink" title="天线的连接"></a>天线的连接</h3><blockquote>
<p>注意：在PCB上走线时，天线和射频芯片之间的传输线要做好阻抗匹配设计，并且在端接点处小心阻抗变化带来的影响</p>
</blockquote>
<ul>
<li><p>输入阻抗：天线输入端看进去的阻抗值<br>  那么就存在天线的馈线（也就是连接到信号源的传输线）和天线间的匹配问题，有反射系数：</p>
<p>  $$<br>  \Gamma &#x3D; \frac{Z_{in}-Z_0}{Z_{in}+Z_0}<br>  $$<br>  电压驻波比：<br>  $$<br>  VSWR &#x3D; \frac{1+|\Gamma|}{1-|\Gamma|}<br>  $$</p>
<blockquote>
<p>线天线，天线输入端的电压与电流的比值称为天线的输入阻抗；面天线，则常用馈线上电压驻波比来表示天线的阻抗特性</p>
</blockquote>
</li>
<li><p>天线带宽：天线参数不超出规定范围的频率范围，比如增益-3dB带宽等</p>
</li>
<li><p>回波损耗：指的是射频输入信号反射回来的功率与输入信号功率的比值。一般采用dB法：</p>
<p>  $$<br>  \text{RL} &#x3D; 10\lg\frac{P_{反射}}{P_{入射}} &#x3D; 20\lg\Gamma<br>  $$</p>
<p>  因为反射功率总是小于（或等于）入射功率，所以回波损耗算出来都是负值。并且根据上式，在实际工程中可以直接用矢网仪测反射系数（<code>S11</code>)并求对数坐标就得到回损了。</p>
<blockquote>
<p>在理想情况下，天线与射频电路的阻抗完全匹配，完全没有反射功率，这时的回波损耗为无限小。但是在工程上阻抗不可能完全匹配，因此反射功率是一定存在的。最差的情况是输入功率完全被反射，此时回波损耗为0。因此对回波损耗这个技术参数，数值越低表示天线性能越好。</p>
</blockquote>
<p>  下图是笔者截取自Cypress公司《天线设计与射频布局指南》中推荐的MIFA天线设计方案的回波损耗曲线，在图中有一个最低损耗点就是这个天线工作的中心频率，我们要设计天线的目标也就是这个点的位置和大小；同时还可以在最低点两端选取相应的回损截止点作为带宽评价指标。</p>
<p>  <img src="https://blog-img-goryj.oss-rg-china-mainland.aliyuncs.com/blogpost/20210807-ANT-7.png" alt="回波损耗"></p>
</li>
</ul>
<h3 id="极化方式"><a href="#极化方式" class="headerlink" title="极化方式"></a>极化方式</h3><p>天线的极化就是指天线辐射时形成的电场强度方向。当电场强度方向垂直于地面时，此电波就称为垂直极化波;当电场强度方向平行于地面时，此电波就称为水平极化波。</p>
<p><img src="https://blog-img-goryj.oss-rg-china-mainland.aliyuncs.com/blogpost/20210807-ANT-3.jpeg" alt="极化方向"></p>
<p>双极化天线是由极化彼此正交的两根天线封装在同一天线罩中组成的。由于性能原因，两根天线采用±45度的极化方式。</p>
<p><img src="https://blog-img-goryj.oss-rg-china-mainland.aliyuncs.com/blogpost/20210807-ANT-4.jpeg" alt="双极化方式"></p>
<blockquote>
<p>要注意，天线极化就类似光的偏振，如果两个天线极化不匹配，接收效果将会大打折扣甚至收不到信号</p>
</blockquote>
<h2 id="非理想天线的影响"><a href="#非理想天线的影响" class="headerlink" title="非理想天线的影响"></a>非理想天线的影响</h2><p><img src="https://blog-img-goryj.oss-rg-china-mainland.aliyuncs.com/blogpost/20210807-ANT-6.jpg" alt="天线方向"></p>
<p>这就是一个经典的非全向性天线带来的盲区问题，所以这就是为什么我们常常看到蜂窝网络一般是有好几个天线绕一圈组成一个电信塔。</p>
<p>但是方向性在通信上也有一定的好处，比如使用一个功率为10W的理想无向天线可以与某点进行通信，而使用功率为1W的增益为10的天线就可以在最大辐射方向上具有同样效果。</p>
<h2 id="天线的设计"><a href="#天线的设计" class="headerlink" title="天线的设计"></a>天线的设计</h2><p>天线的设计是一个非常困难的事情，一般很难求出解析解，通常采用的是计算机软件进行设计。</p>
<blockquote>
<p>这个数理知识太多了，后面有机会再学习补充吧。暂时先用现成设计好的特定参数天线，试了一下HFSS，从入门到入土😭</p>
</blockquote>
<h2 id="板载天线的使用设计"><a href="#板载天线的使用设计" class="headerlink" title="板载天线的使用设计"></a>板载天线的使用设计</h2><blockquote>
<p>DOING</p>
</blockquote>
]]></content>
      <categories>
        <category>硬件&amp;物理</category>
      </categories>
      <tags>
        <tag>天线</tag>
        <tag>调谐</tag>
      </tags>
  </entry>
  <entry>
    <title>速通Linux驱动程序</title>
    <url>/2023/02/22/LinuxDriver/</url>
    <content><![CDATA[<blockquote>
<p>痛苦，非常的痛苦！学Linux的驱动要么上天要么入土，因此笔者决定写这篇博客帮所有想入门Linux驱动的读者走地更安详。😇另外的，笔者在学习时具有一定程度的硬件知识储备和嵌入式裸机开发经验，因此本文将不会太多地帮助硬件小白，建议阅读学习笔者之前的硬件相关博客或其他大神的入门教程。</p>
</blockquote>
<h2 id="Linux设备驱动概念篇"><a href="#Linux设备驱动概念篇" class="headerlink" title="Linux设备驱动概念篇"></a>Linux设备驱动概念篇</h2><h3 id="驱动类型"><a href="#驱动类型" class="headerlink" title="驱动类型"></a>驱动类型</h3><p>Linux天下无敌，支持所有的硬件外设，所以提出了3个类别的驱动程序。</p>
<table>
<thead>
<tr>
<th align="center">驱动类型</th>
<th align="center">特点</th>
<th align="center">常见设备</th>
</tr>
</thead>
<tbody><tr>
<td align="center">字符设备</td>
<td align="center">操作字节数据</td>
<td align="center">GPIO、I2C、SPI、音频、显卡</td>
</tr>
<tr>
<td align="center">块设备</td>
<td align="center">一次操作一组（块）数据</td>
<td align="center">EMMC、NAND、SD Card</td>
</tr>
<tr>
<td align="center">网络设备</td>
<td align="center">套接字（socket）操作</td>
<td align="center">以太网</td>
</tr>
</tbody></table>
<p>字符设备常常被创建为设备节点，以类似文件的形式存在于<code>/dev/</code>目录下（例如串口<code>/dev/tty</code>），这种形式操作起来和对普通文件的操作极其相似，同时字符设备类驱动是最常见的，做项目时写的最多的，但是3种驱动里最简单的。<br>另外两种驱动，块设备和网络设备，驱动模型写起来又臭又长，一般IC器件的厂家都把驱动写好了，属于Linux高手的玩物。</p>
<p>因此，本文中将主要分享字符设备驱动的开发。</p>
<h3 id="内核态"><a href="#内核态" class="headerlink" title="内核态"></a>内核态</h3><p>Linux在隔离业务应用和硬件这块做的非常好，操作系统上分为了：<strong>用户态</strong>和<strong>内核态</strong>。内核态提供服务给用户态调用，具有统一的抽象接口，使得用户态程序可以在不了解硬件的情况下很好地运行并操作所需硬件。显然，我们要编写的驱动程序就是工作在内核态，所以编写时要满足Linux的模型。</p>
<p><img src="https://blog-img-goryj.oss-rg-china-mainland.aliyuncs.com/blogpost/20230222-Linux-1.jpeg" alt="用户态与内核态"></p>
<h3 id="驱动程序运行方式"><a href="#驱动程序运行方式" class="headerlink" title="驱动程序运行方式"></a>驱动程序运行方式</h3><span id="more"></span>

<p>Linux驱动有两种运行的方法：</p>
<ul>
<li><strong>静态转载</strong>：驱动程序源码和Linux内核代码放一起，编译进Linux内核，启动Linux时自动运行驱动程序。</li>
<li>动态装载（<strong>模块机制</strong>）：驱动程序单独编译成<code>.ko</code>模块，Linux内核正常运行时，在需要的情况下使用<code>insmod</code>或<code>modprobe</code>等方式加载驱动模块。</li>
</ul>
<blockquote>
<p>使用<code>modprobe</code>需要先在<code>/lib/modules/内核版本号/modules.dep</code>文件中注册和声明模块依赖关系；若没有依赖其他驱动，直接使用<code>depmod</code>命令，也可以使用<code>insmod</code>。另外的，动态驱动<code>.ko</code>模块要放置于该驱动目录中</p>
</blockquote>
<p>将驱动跑起来后，在<code>/dev</code>目录下会出现相应的设备，这是Linux将“设备作为文件”处理的思想。当应用程序（或SDK）要操作对应的硬件时，使用对应的系统调用接口即可，如<code>open</code>、<code>write</code>等。</p>
<p><img src="https://blog-img-goryj.oss-rg-china-mainland.aliyuncs.com/blogpost/20230222-Linux-2.png" alt="dev目录"></p>
<h2 id="驱动编写TIPs"><a href="#驱动编写TIPs" class="headerlink" title="驱动编写TIPs"></a>驱动编写TIPs</h2><ul>
<li>不能使用标准C库！因为驱动程序运行在内核态，C库是基于系统调用实现在用户态。<blockquote>
<p>可以使用内核版接口，比如<code>printf</code>打印函数在驱动程序中对应调用<code>printk</code>内核实现的打印函数。</p>
</blockquote>
</li>
<li>必须用GUN C编译！</li>
<li>内核只有很小的定长堆栈！32位机内核栈8KB，64位机16KB。</li>
<li>小心指针！内核理解为裸机程序，没内存保护机制，一旦访问非法内存可能直接死机</li>
<li>避免用浮点！</li>
<li>小心字节序！</li>
</ul>
<h2 id="小试牛刀——字符设备驱动"><a href="#小试牛刀——字符设备驱动" class="headerlink" title="小试牛刀——字符设备驱动"></a>小试牛刀——字符设备驱动</h2><blockquote>
<p>环境声明：</p>
<ul>
<li>Ubuntu 18.04</li>
<li>GUN Make 4.1</li>
<li>gcc 7.5.0</li>
</ul>
</blockquote>
<h3 id="Demo跑一下"><a href="#Demo跑一下" class="headerlink" title="Demo跑一下"></a>Demo跑一下</h3><p>这边演示的是最常见而简单的字符型设备驱动，文件名为chrDriver.c</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/module.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/init.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/fs.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/cdev.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/slab.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**********************************</span></span><br><span class="line"><span class="comment"> *  以下为驱动级的实现接口</span></span><br><span class="line"><span class="comment"> * 装载进 file_operations 结构体</span></span><br><span class="line"><span class="comment">**********************************/</span></span><br><span class="line"></span><br><span class="line"><span class="type">ssize_t</span> <span class="title function_">mydev_read</span><span class="params">(<span class="keyword">struct</span> file *file, <span class="type">char</span> __user *data, <span class="type">size_t</span> size, <span class="type">loff_t</span> * loff)</span></span><br><span class="line">&#123;</span><br><span class="line">    printk(KERN_INFO <span class="string">&quot;mydev_read\n&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">ssize_t</span> <span class="title function_">mydev_write</span><span class="params">(<span class="keyword">struct</span> file *file, <span class="type">const</span> <span class="type">char</span> __user *data, <span class="type">size_t</span> size, <span class="type">loff_t</span> *loff)</span></span><br><span class="line">&#123;</span><br><span class="line">    printk(KERN_INFO <span class="string">&quot;mydev_write\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">mydev_open</span><span class="params">(<span class="keyword">struct</span> inode *inode, <span class="keyword">struct</span> file *file)</span></span><br><span class="line">&#123;</span><br><span class="line">    printk(KERN_INFO <span class="string">&quot;mydev_open\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**********************************</span></span><br><span class="line"><span class="comment"> *  以下为系统级的接口适配</span></span><br><span class="line"><span class="comment"> * 实现驱动模块的注册和注销</span></span><br><span class="line"><span class="comment">**********************************/</span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">dev_t</span> dev_id;    <span class="comment">// 设备号</span></span><br><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">cdev</span> *<span class="title">mydev</span>;</span>  <span class="comment">// 设备信息汇总</span></span><br><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="keyword">class</span> *<span class="title">mydev_class</span>;</span> <span class="comment">// 设备文件化类</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 文件操作集合 */</span></span><br><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">file_operations</span> <span class="title">mydev_fops</span> =</span> &#123;</span><br><span class="line">	.owner = THIS_MODULE,</span><br><span class="line">    .read   = mydev_read,</span><br><span class="line">    .open   = mydev_open,</span><br><span class="line">    .write  = mydev_write,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> __init <span class="type">int</span> <span class="title function_">mydev_init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/* 申请设备号 */</span></span><br><span class="line">    alloc_chrdev_region(&amp;dev_id, <span class="number">1</span>, <span class="number">1</span>, <span class="string">&quot;mydev&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 分配字符设备 */</span></span><br><span class="line">    mydev = cdev_alloc();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 设置字符设备 */</span></span><br><span class="line">    cdev_init(mydev, &amp;mydev_fops);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 注册字符设备 */</span></span><br><span class="line">    cdev_add(mydev, dev_id, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 打印申请到的主次设备号 */</span></span><br><span class="line">    printk(KERN_INFO <span class="string">&quot;major:%d; minor:%d\n&quot;</span>, MAJOR(dev_id), MINOR(dev_id));</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 设备 文件化*/</span></span><br><span class="line">    mydev_class = class_create(THIS_MODULE, <span class="string">&quot;chrDevFile&quot;</span>);</span><br><span class="line">    <span class="comment">/* 创建/dev/mydev*/</span></span><br><span class="line">	device_create(mydev_class, <span class="literal">NULL</span>, dev_id, <span class="literal">NULL</span>, <span class="string">&quot;chrDevFile&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> __exit <span class="type">void</span> <span class="title function_">mydev_exit</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/* 注销 文件化的 /dev/mydev */</span></span><br><span class="line">    device_destroy(mydev_class, dev_id);</span><br><span class="line">    class_destroy(mydev_class);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 归还系统资源*/</span></span><br><span class="line">    cdev_del(mydev);</span><br><span class="line">    kfree(mydev);</span><br><span class="line">    unregister_chrdev_region(dev_id, <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">module_init(mydev_init);        <span class="comment">// 生成模块时，指明哪个接口用于 注册驱动</span></span><br><span class="line">module_exit(mydev_exit);    <span class="comment">// 生成模块时，指明哪个接口用于 注销驱动</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**********************************</span></span><br><span class="line"><span class="comment"> *  Linux 体系下的小九九</span></span><br><span class="line"><span class="comment">**********************************/</span></span><br><span class="line">MODULE_LICENSE(<span class="string">&quot;GPL&quot;</span>);</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>Makefile的编写</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 内核源码</span></span><br><span class="line">KERNELDIR := /lib/modules/<span class="variable">$(<span class="built_in">shell</span> uname -r)</span>/build</span><br><span class="line"><span class="comment"># 当前目录</span></span><br><span class="line">CURRENT_PATH := <span class="variable">$(<span class="built_in">shell</span> pwd)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 取消签名认证</span></span><br><span class="line">CONFIG_MODULE_SIG=n</span><br><span class="line"></span><br><span class="line">obj-m := chrDriver.o</span><br><span class="line"> </span><br><span class="line"><span class="section">build: kernel_modules</span></span><br><span class="line"> </span><br><span class="line"><span class="section">kernel_modules:</span></span><br><span class="line">	<span class="comment"># 下面第2项，M=$(CURRENT_PATH) 告知源码编译时，驱动程序在这</span></span><br><span class="line">	<span class="variable">$(MAKE)</span> -C <span class="variable">$(KERNELDIR)</span> M=<span class="variable">$(CURRENT_PATH)</span> modules</span><br><span class="line"><span class="section">clean:</span></span><br><span class="line">	<span class="variable">$(MAKE)</span> -C <span class="variable">$(KERNELDIR)</span> M=<span class="variable">$(CURRENT_PATH)</span> clean</span><br></pre></td></tr></table></figure>

<p>我们先把这个程序跑起来，有个直观感受再分析代码内容。首先是编译这个驱动程序，当然 上面的<code>.c</code>源文件和Makefile文件要放在同一目录下，跑命令也在同一目录：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ make</span><br></pre></td></tr></table></figure>

<p>接着加载驱动，并观察驱动的加载情况：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ <span class="built_in">sudo</span> insmod chrDriver.ko</span><br><span class="line">$ lsmod | grep chrDriver</span><br></pre></td></tr></table></figure>

<p>加载后，可以查看驱动运行时的信息：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ dmesg</span><br><span class="line"></span><br><span class="line">[ 7937.803754] major:240; minor:1</span><br></pre></td></tr></table></figure>
<p>使用<code>dmesg</code>命令会打印开机以来所有的驱动动作信息，上面展示了和我们驱动有关的一条。执行<code>insmod</code>命令本质上执行源文件中的<code>mydev_init</code>接口，在该接口中我们调用<code>printk</code>打印了两个号码，所以这边我们能够就看到：在<code>[ 7937.803754]</code>这个时刻系统记录了<code>major:240; minor:1</code>信息。</p>
<p>这个小小的驱动程序还实现了“设备文件化”，在<code>/dev/</code>目录下，是可以找到<code>chrDevFile</code>这个“文件”哒，执行：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ <span class="built_in">ls</span> /dev</span><br></pre></td></tr></table></figure>

<p>最后，测试完成或不需要时，可以卸载驱动：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ <span class="built_in">sudo</span> rmmod chrDriver</span><br></pre></td></tr></table></figure>

<h3 id="具体原理"><a href="#具体原理" class="headerlink" title="具体原理"></a>具体原理</h3><p>上面的<code>.c</code>源文件中，我们用到了3个Linux系统内核的结构&#x2F;类型：<code>dev_t</code>、<code>struct cdev</code>和<code>struct file_operations</code>。具体来看他们的内容与功能：</p>
<ul>
<li>dev_t：<ul>
<li>存放设备号，高12位为主设备号，低20位为次设备号，共为32位</li>
<li>调用宏可获取主<code>MAJOR(dev_id)</code>、次设备号<code>MINOR(dev_id)</code>，这就是上面<code>mydev_init</code>接口里<code>printk</code>打印的东西。</li>
</ul>
</li>
<li>cdev：<ul>
<li>把 驱动模块、字符设备操作接口集、设备号 关联起来</li>
<li>所有东西准备好后，这个家伙负责汇总了统一报告给内核</li>
<li>位于<code>cdev.h</code>文件中的定义：<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">cdev</span> &#123;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">kobject</span> <span class="title">kobj</span>;</span>    <span class="comment">// 内核对象，所有内核操作都要有这个，类似C++的继承</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">module</span> *<span class="title">owner</span>;</span>   <span class="comment">// 所属模块</span></span><br><span class="line">  <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">file_operations</span> *<span class="title">ops</span>;</span>  <span class="comment">// 文件操作集</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">list</span>;</span></span><br><span class="line">  <span class="type">dev_t</span> dev;          <span class="comment">// 设备号</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> count;</span><br><span class="line">&#125; __randomize_layout;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li>file_operations<ul>
<li>位于<code>fs.h</code>文件中的定义：<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">file_operations</span> &#123;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">module</span> *<span class="title">owner</span>;</span> <span class="comment">// 所属模块</span></span><br><span class="line">  <span class="type">loff_t</span> (*llseek) (<span class="keyword">struct</span> file *, <span class="type">loff_t</span>, <span class="type">int</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 基础文件操作：读、写*/</span></span><br><span class="line">  <span class="type">ssize_t</span> (*read) (<span class="keyword">struct</span> file *, <span class="type">char</span> __user *, <span class="type">size_t</span>, <span class="type">loff_t</span> *);</span><br><span class="line">  <span class="type">ssize_t</span> (*write) (<span class="keyword">struct</span> file *, <span class="type">const</span> <span class="type">char</span> __user *, <span class="type">size_t</span>, <span class="type">loff_t</span> *);</span><br><span class="line">  <span class="type">ssize_t</span> (*read_iter) (<span class="keyword">struct</span> kiocb *, <span class="keyword">struct</span> iov_iter *);</span><br><span class="line">  <span class="type">ssize_t</span> (*write_iter) (<span class="keyword">struct</span> kiocb *, <span class="keyword">struct</span> iov_iter *);</span><br><span class="line">  </span><br><span class="line">  <span class="type">int</span> (*iopoll)(<span class="keyword">struct</span> kiocb *kiocb, <span class="type">bool</span> spin);</span><br><span class="line">  <span class="type">int</span> (*iterate) (<span class="keyword">struct</span> file *, <span class="keyword">struct</span> dir_context *);</span><br><span class="line">  <span class="type">int</span> (*iterate_shared) (<span class="keyword">struct</span> file *, <span class="keyword">struct</span> dir_context *);</span><br><span class="line">  <span class="type">__poll_t</span> (*poll) (<span class="keyword">struct</span> file *, <span class="keyword">struct</span> poll_table_struct *);</span><br><span class="line">  <span class="type">long</span> (*unlocked_ioctl) (<span class="keyword">struct</span> file *, <span class="type">unsigned</span> <span class="type">int</span>, <span class="type">unsigned</span> <span class="type">long</span>);</span><br><span class="line">  <span class="type">long</span> (*compat_ioctl) (<span class="keyword">struct</span> file *, <span class="type">unsigned</span> <span class="type">int</span>, <span class="type">unsigned</span> <span class="type">long</span>);</span><br><span class="line">  <span class="type">int</span> (*mmap) (<span class="keyword">struct</span> file *, <span class="keyword">struct</span> vm_area_struct *);</span><br><span class="line">  <span class="type">unsigned</span> <span class="type">long</span> mmap_supported_flags;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/*基础打开、关闭等*/</span></span><br><span class="line">  <span class="type">int</span> (*open) (<span class="keyword">struct</span> inode *, <span class="keyword">struct</span> file *);</span><br><span class="line">  <span class="type">int</span> (*flush) (<span class="keyword">struct</span> file *, <span class="type">fl_owner_t</span> id);</span><br><span class="line">  <span class="type">int</span> (*release) (<span class="keyword">struct</span> inode *, <span class="keyword">struct</span> file *);</span><br><span class="line"></span><br><span class="line">  <span class="type">int</span> (*fsync) (<span class="keyword">struct</span> file *, <span class="type">loff_t</span>, <span class="type">loff_t</span>, <span class="type">int</span> datasync);</span><br><span class="line">  <span class="type">int</span> (*fasync) (<span class="type">int</span>, <span class="keyword">struct</span> file *, <span class="type">int</span>);</span><br><span class="line">  <span class="type">int</span> (*lock) (<span class="keyword">struct</span> file *, <span class="type">int</span>, <span class="keyword">struct</span> file_lock *);</span><br><span class="line">  <span class="type">ssize_t</span> (*sendpage) (<span class="keyword">struct</span> file *, <span class="keyword">struct</span> page *, <span class="type">int</span>, <span class="type">size_t</span>, <span class="type">loff_t</span> *, <span class="type">int</span>);</span><br><span class="line">  <span class="type">unsigned</span> <span class="title function_">long</span> <span class="params">(*get_unmapped_area)</span><span class="params">(<span class="keyword">struct</span> file *, <span class="type">unsigned</span> <span class="type">long</span>, <span class="type">unsigned</span> <span class="type">long</span>, <span class="type">unsigned</span> <span class="type">long</span>, <span class="type">unsigned</span> <span class="type">long</span>)</span>;</span><br><span class="line">  <span class="type">int</span> (*check_flags)(<span class="type">int</span>);</span><br><span class="line">  <span class="type">int</span> (*setfl)(<span class="keyword">struct</span> file *, <span class="type">unsigned</span> <span class="type">long</span>);</span><br><span class="line">  <span class="type">int</span> (*flock) (<span class="keyword">struct</span> file *, <span class="type">int</span>, <span class="keyword">struct</span> file_lock *);</span><br><span class="line">  <span class="type">ssize_t</span> (*splice_write)(<span class="keyword">struct</span> pipe_inode_info *, <span class="keyword">struct</span> file *, <span class="type">loff_t</span> *, <span class="type">size_t</span>, <span class="type">unsigned</span> <span class="type">int</span>);</span><br><span class="line">  <span class="type">ssize_t</span> (*splice_read)(<span class="keyword">struct</span> file *, <span class="type">loff_t</span> *, <span class="keyword">struct</span> pipe_inode_info *, <span class="type">size_t</span>, <span class="type">unsigned</span> <span class="type">int</span>);</span><br><span class="line">  <span class="type">int</span> (*setlease)(<span class="keyword">struct</span> file *, <span class="type">long</span>, <span class="keyword">struct</span> file_lock **, <span class="type">void</span> **);</span><br><span class="line">  <span class="type">long</span> (*fallocate)(<span class="keyword">struct</span> file *file, <span class="type">int</span> mode, <span class="type">loff_t</span> offset,</span><br><span class="line">        <span class="type">loff_t</span> len);</span><br><span class="line">  <span class="type">void</span> (*show_fdinfo)(<span class="keyword">struct</span> seq_file *m, <span class="keyword">struct</span> file *f);</span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> CONFIG_MMU</span></span><br><span class="line">  <span class="type">unsigned</span> (*mmap_capabilities)(<span class="keyword">struct</span> file *);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">  <span class="type">ssize_t</span> (*copy_file_range)(<span class="keyword">struct</span> file *, <span class="type">loff_t</span>, <span class="keyword">struct</span> file *,</span><br><span class="line">      <span class="type">loff_t</span>, <span class="type">size_t</span>, <span class="type">unsigned</span> <span class="type">int</span>);</span><br><span class="line">  <span class="type">loff_t</span> (*remap_file_range)(<span class="keyword">struct</span> file *file_in, <span class="type">loff_t</span> pos_in,</span><br><span class="line">          <span class="keyword">struct</span> file *file_out, <span class="type">loff_t</span> pos_out,</span><br><span class="line">          <span class="type">loff_t</span> len, <span class="type">unsigned</span> <span class="type">int</span> remap_flags);</span><br><span class="line">  <span class="type">int</span> (*fadvise)(<span class="keyword">struct</span> file *, <span class="type">loff_t</span>, <span class="type">loff_t</span>, <span class="type">int</span>);</span><br><span class="line">  <span class="type">bool</span> may_pollfree;</span><br><span class="line">&#125; __randomize_layout;</span><br></pre></td></tr></table></figure></li>
<li>这个结构体里，我们最基础的就是把实现的<code>read</code>、<code>write</code>、<code>open</code>、<code>release</code>函数指针附上。</li>
</ul>
</li>
</ul>
<p>了结了这3个关键数据类型后，再去看源码就很简单了。我们采取自顶向下的方式，好理解一个驱动模块的工作原理和编写模型：</p>
<ul>
<li>我们前面提到过，<code>insmod</code>加载<code>.ko</code>驱动模块本质上调用了<code>mydev_init</code>，向内核申请资源和注册驱动程序的信息。依次为：<ol>
<li>申请设备号<code>alloc_chrdev_region</code></li>
<li>分配字符设备<code>cdev_alloc</code></li>
<li>设置字符设备<code>cdev_init</code>，关联<code>cdev</code>和<code>file_operations</code>两个结构体</li>
<li>注册字符设备<code>cdev_add</code></li>
<li>设备文件化<code>device_create</code></li>
</ol>
</li>
<li>当驱动程序不用时，<code>rmmod</code>本质上调用了<code>mydev_exit</code>，依次：<ol>
<li>在内核中删除字符设备<code>cdev_del</code>;</li>
<li>释放申请的字符设备资源<code>kfree</code>;</li>
<li>归还申请的设备号资源<code>unregister_chrdev_region</code>;</li>
<li>注销文件化对象<code>device_destroy</code></li>
</ol>
</li>
</ul>
<blockquote>
<p>文件化驱动对象，的专业术语应该是<strong>创建设备节点</strong>，这边笔者是为了好理解这么叫的。</p>
</blockquote>
<h3 id="在应用层使用这个字符驱动"><a href="#在应用层使用这个字符驱动" class="headerlink" title="在应用层使用这个字符驱动"></a>在应用层使用这个字符驱动</h3><p>上面已经说明了，加载驱动模块后在文件系统中我们可以找到<code>/dev/chrDevFile</code>，所以可以把这个设备当作文件一样去处理。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>* argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> val = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> fd = open(<span class="string">&quot;/dev/chrDevFile&quot;</span>, O_RDWR);</span><br><span class="line"></span><br><span class="line">    write(fd, &amp;val, <span class="keyword">sizeof</span>(val));</span><br><span class="line"></span><br><span class="line">    read(fd, &amp;val, <span class="keyword">sizeof</span>(val));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>编译后运行：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ gcc test_chrDriver.c -o test_chrDriver</span><br><span class="line">$ <span class="built_in">sudo</span> <span class="built_in">chmod</span> 777 /dev/chrDevFile</span><br><span class="line">$ ./test_chrDriver</span><br></pre></td></tr></table></figure>

<p>再次使用<code>dmesg</code>查看：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ dmesg</span><br><span class="line"></span><br><span class="line">[13192.810102] major:240; minor:1</span><br><span class="line">[13306.403353] mydev_open</span><br><span class="line">[13306.403354] mydev_write</span><br><span class="line">[13306.403354] mydev_read</span><br></pre></td></tr></table></figure>

<p>这些驱动打印的信息说明：用户层调用的标准文件操作接口，Linux一一对接到了驱动层我们实现的驱动接口。</p>
<h2 id="进阶前必备利器"><a href="#进阶前必备利器" class="headerlink" title="进阶前必备利器"></a>进阶前必备利器</h2><ul>
<li><p><a href="https://www.kernel.org/doc/html/">Linux Kernel Document</a>：内核API在线速查。</p>
<blockquote>
<p>笔者在接下来的进阶部分，将不对每个结构体和接口做具体说明。因为官方的说明是最准确的，而本文将侧重于开发思想的学习，建议读者边查边学。</p>
</blockquote>
</li>
<li><p>Source Insight：阅读Linux内核代码必备神器</p>
<p>  因为这个SourceInsight是Windows软件，所以想在Linux上跑地先下一个类似虚拟机但不是虚拟机的东西——Wine</p>
  <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ <span class="built_in">sudo</span> apt install wine-development -y</span><br><span class="line">$ <span class="built_in">sudo</span> apt install wine64 -y</span><br><span class="line">$ wine --version</span><br></pre></td></tr></table></figure>
<p>  然后就可以正式下载安装了</p>
  <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ wget https://s3-us-west-2.amazonaws.com/assets.sourceinsight.com/download/v4/release/sourceinsight40126-setup.exe</span><br><span class="line"></span><br><span class="line">$ wine sourceinsight40126-setup.exe</span><br></pre></td></tr></table></figure>
<p>  安装的时候，这个软件要导入License，网络上很多，笔者支持正版不提供。如果采用的默认路径(<code>C://Program Files (x86)</code>)安装，那么运行以下代码启动Source Insight：</p>
  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ wine ~/.wine/drive_c/Program\ Files\ \(x86\)/Source\ Insight\ 4.0/sourceinsight4.exe</span><br></pre></td></tr></table></figure>
<p>  可以在桌面建立一个这样的sh脚本，后面一键运行更方便。</p>
</li>
</ul>
<h2 id="Linux驱动中的高级武器"><a href="#Linux驱动中的高级武器" class="headerlink" title="Linux驱动中的高级武器"></a>Linux驱动中的高级武器</h2><h3 id="线程间同步"><a href="#线程间同步" class="headerlink" title="线程间同步"></a>线程间同步</h3><h4 id="互斥量Mutex"><a href="#互斥量Mutex" class="headerlink" title="互斥量Mutex"></a>互斥量Mutex</h4><p><img src="https://blog-img-goryj.oss-rg-china-mainland.aliyuncs.com/blogpost/20230222-Linux-3.jpeg" alt="Mutex"></p>
<ul>
<li>作用：同一时刻，只能有一个线程持有该锁</li>
<li>具体实现方式为：<ol>
<li>申请占有资源：每个线程在对共享资源操作前都尝试先加锁</li>
<li>使用资源：成功加锁后才可以对共享资源进行读写操作，</li>
<li>释放资源：操作结束后解锁</li>
</ol>
</li>
<li>主要应用函数：<ul>
<li>初始化<em>动态</em>互斥量对象<code>pthread_mutex_init</code></li>
<li>初始化<em>静态</em>互斥量对象<code>PTHREAD_MUTEX_INITIALIZER</code>。注意这是一个宏</li>
<li>摧毁互斥量对象<code>pthread_mutex_destroy</code></li>
<li>必上锁<code>pthread_mutex_lock</code>。注意：这是一个阻塞接口，如果加锁不成功，会等待直到信号量可用</li>
<li>尝试锁<code>pthread_mutex_trylock</code>。注意：这是一个非阻塞接口，如果调用时，加锁不成功，会直接退出并返回对应的值</li>
<li>解锁&#x2F;释放信号量<code>pthread_mutex_unlock</code></li>
</ul>
</li>
</ul>
<h4 id="信号量Semaphore"><a href="#信号量Semaphore" class="headerlink" title="信号量Semaphore"></a>信号量Semaphore</h4><p><img src="http://imgjry.fangyikuan.xyz/20230222/20230222-Linux-4.png" alt="Semaphore"></p>
<ul>
<li>本质：计数器</li>
<li>特质：<ul>
<li>适用于占用资源较久的情况。因为等待资源线程会进入休眠状态</li>
<li>中断里不能用。因为信号量会引起休眠，中断不能休眠</li>
<li>占有时间短的，不适合使用信号量。因为频繁的休眠、切换线程引起的开销要远大于信号量带来的优势</li>
</ul>
</li>
<li>主要应用函数：<ul>
<li>初始化<em>动态</em>信号量对象<code>sema_init </code></li>
<li>初始化<em>静态</em>信号量对象<code>__SEMAPHORE_INITIALIZER</code>。注意这是一个宏</li>
<li>阻塞式获取信号量<code>down</code></li>
<li>中断式等待信号量<code>down_interruptible</code></li>
<li>尝试获取信号量<code>down_trylock</code></li>
<li>释放&#x2F;提升信号量<code>up</code></li>
</ul>
</li>
</ul>
<h4 id="临界资源、临界区、事件"><a href="#临界资源、临界区、事件" class="headerlink" title="临界资源、临界区、事件"></a>临界资源、临界区、事件</h4><p><strong>临界资源</strong>：多线程之间需要<em>互斥</em>访问的全局变量&#x2F;共享字段</p>
<p><strong>临界区</strong>：加锁区间的代码！</p>
<p><strong>事件</strong>：类似于硬件里说的中断，但是Linux里用信号量这些软中断实现的</p>
<ul>
<li>临界区在任意时刻只允许一个线程对共享资源进行访问</li>
<li>如果有多个线程试图同时访问临界区，那么有线程进入后，其他线程试图访问时将被挂起，直到进入临界区的线程离开。</li>
</ul>
<h3 id="进程间通信"><a href="#进程间通信" class="headerlink" title="进程间通信"></a>进程间通信</h3><h4 id="管道pipe"><a href="#管道pipe" class="headerlink" title="管道pipe"></a>管道pipe</h4><p><img src="https://blog-img-goryj.oss-rg-china-mainland.aliyuncs.com/blogpost/20230222-Linux-5.png" alt="pipe"></p>
<p>在学习Linux的过程中，包括上面我们查驱动表的时候，都用到了<code>|</code>这个符号，也就是管道：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ lsmod | grep chrDriver</span><br></pre></td></tr></table></figure>

<p>在使用的角度来看，管道这一工具使得我们能够把<strong>一个程序的结果 转给 另一个程序作为输入</strong>。比如上面执行的这行命令，把<code>lsmod</code>查到的驱动结果列表 通过<code>|</code>管道输送给 <code>grep</code>查找‘chrDriver’字符。</p>
<p>管道基于文件描述符的通信方式，当一个管道建立时，它会创建两个文件描述符fd[0]和fd[1],其中fd[0]固定用于读管道，而fd[1]则固定用于写管道，这样就构成了一个半双工的通道。</p>
<ul>
<li>主要接口函数<ul>
<li>创建管道<code>pipe</code></li>
<li>关闭管道<code>close</code></li>
</ul>
</li>
</ul>
<h4 id="信号（signal）"><a href="#信号（signal）" class="headerlink" title="信号（signal）"></a>信号（signal）</h4><p><img src="https://blog-img-goryj.oss-rg-china-mainland.aliyuncs.com/blogpost/20230222-Linux-6.png" alt="signal"></p>
<p><a href="https://blog.csdn.net/w903414/article/details/109802539">CSDN一篇很细致的信号</a></p>
<h4 id="共享内存（shared-memory）"><a href="#共享内存（shared-memory）" class="headerlink" title="共享内存（shared memory）"></a>共享内存（shared memory）</h4><p><img src="https://blog-img-goryj.oss-rg-china-mainland.aliyuncs.com/blogpost/20230222-Linux-7.png" alt="shared memory"></p>
<p>Linux操作系统给每个进程都单独开了不同的虚拟内存空间，但有时需要进程间一起共享大量数据，这就出了<strong>共享内存</strong>功能，本质上也就是把两边的虚拟内存一起映射到一片共同的真内存上。使用的接口有：</p>
<ol>
<li>生成系统IPC资源标识<code>ftok</code></li>
<li>获取共享内存<strong>的标识符</strong><code>shmget</code></li>
<li>关联共享内存和虚拟内存地址<code>shmat</code></li>
<li>取消关联共享内存<code>shmdt</code></li>
</ol>
<p>以下为共享内存使用的具体实例，线程A和B通过共同读写<code>/tmp/shm</code>实现数据交互。</p>
<p>线程A代码：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/ipc.h&gt;</span>  <span class="comment">// 申请IPC资源 的接口</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/shm.h&gt;</span>  <span class="comment">// 共享内存 的接口</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SHM_PATH <span class="string">&quot;/tmp/shm&quot;</span> <span class="comment">// 共享内存挂载文件系统的路径</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SHM_SIZE 128        <span class="comment">// 空间大小</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> shmid;  <span class="comment">// 共享内存标识符</span></span><br><span class="line">    <span class="type">char</span> *addr; <span class="comment">// 实际操作的 虚拟地址</span></span><br><span class="line">    <span class="type">key_t</span> key = ftok(SHM_PATH, <span class="number">0x6666</span>);  <span class="comment">// IPC 资源号</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">/*创建 共享内存 标识符*/</span></span><br><span class="line">    shmid = shmget(key, SHM_SIZE, IPC_CREAT|IPC_EXCL|<span class="number">0666</span>);</span><br><span class="line">    <span class="keyword">if</span> (shmid &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;failed to create share memory\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* 获得 操作的虚拟地址 */</span></span><br><span class="line">    addr = shmat(shmid, <span class="literal">NULL</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (addr &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;failed to map share memory\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* 往共享内存 写 */</span></span><br><span class="line">    <span class="built_in">sprintf</span>(addr, <span class="string">&quot;%s&quot;</span>, <span class="string">&quot;Hello World\n&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>线程B代码：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/ipc.h&gt;</span>  <span class="comment">// 申请IPC资源 的接口</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/shm.h&gt;</span>  <span class="comment">// 共享内存 的接口</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SHM_PATH <span class="string">&quot;/tmp/shm&quot;</span> <span class="comment">// 共享内存挂载文件系统的路径</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SHM_SIZE 128        <span class="comment">// 空间大小</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> shmid;</span><br><span class="line">    <span class="type">char</span> *addr;</span><br><span class="line">    <span class="type">key_t</span> key = ftok(SHM_PATH, <span class="number">0x6666</span>);  <span class="comment">// IPC 资源号</span></span><br><span class="line">    </span><br><span class="line">    <span class="type">char</span> buf[<span class="number">128</span>];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/*获取！ 共享内存 标识符*/</span></span><br><span class="line">    shmid = shmget(key, SHM_SIZE, IPC_CREAT);</span><br><span class="line">    <span class="keyword">if</span> (shmid &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;failed to get share memory\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* 获得 操作的虚拟地址 */</span></span><br><span class="line">    addr = shmat(shmid, <span class="literal">NULL</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (addr &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;failed to map share memory\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* 从共享内存 读 */</span></span><br><span class="line">    <span class="built_in">strcpy</span>(buf, addr, <span class="number">128</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s&quot;</span>, buf);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>跑了A进程再跑B进程，B会打印A写入的”Hello World”。</p>
<h3 id="扩展自定义功能接口IOCTL"><a href="#扩展自定义功能接口IOCTL" class="headerlink" title="扩展自定义功能接口IOCTL"></a>扩展自定义功能接口IOCTL</h3><p>上面讲基础字符设备时，’struct file_operations’里定义的除了开关读写等常规接口，还有ioctl相关的接口。这是因为肯定有硬件会细分出特殊功能，比如打一个命令让LED灯变成呼吸灯，这时就要用到<code>ioctl</code>来扩展新功能。</p>
<p>这个ioctl有两个使用的角度：用户（态&#x2F;程序）和内核（态&#x2F;驱动）。</p>
<ul>
<li><p>用户程序调用ioctl来命令硬件：</p>
<p>如下是使用的函数原型，第一个是<code>open</code>设备后得到的文件描述符，第二个是这个驱动告知用户可以使用的命令（一般是宏），第三个是配套的变长参数。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">ioctl</span><span class="params">(<span class="type">int</span> fd, <span class="type">int</span> cmd, ...)</span> ;</span><br></pre></td></tr></table></figure></li>
<li><p>驱动程序实现ioctl的相关接口：</p>
<p>作为驱动程序，则负责解析按约定协议解析用户发下来的命令。从<code>file_operations</code>结构体声明里抠的函数原型如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">long</span> (*unlocked_ioctl) (<span class="keyword">struct</span> file *, <span class="type">unsigned</span> <span class="type">int</span>, <span class="type">unsigned</span> <span class="type">long</span>);</span><br><span class="line"><span class="type">long</span> (*compat_ioctl) (<span class="keyword">struct</span> file *, <span class="type">unsigned</span> <span class="type">int</span>, <span class="type">unsigned</span> <span class="type">long</span>);</span><br></pre></td></tr></table></figure>

<p>都是ioctl，这两个接口的区别是啥呢？</p>
<ul>
<li>unlocked_ioctl：在无大内核锁（BKL）的情况下调用</li>
<li>compat_ioctl：兼容版（compatible）ioctl，主要目的是为 64 位系统提供 32 位 ioctl 的兼容方法，也是在无大内核锁的情况下调用</li>
</ul>
<p>再看参数，用户态里调用<code>ioctl</code>的参数通过系统调用，依次对应于上面两个接口的参数，第一个是<code>fd</code>，第二个是<code>cmd</code>，第三个是变长数据的指针。<br>说到命令<code>cmd</code>，在设计驱动程序时，并不是宏定义（define）命令们为1、2、3…这样的int数据，Linux制定了一个生成cmd的标准：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> _IOC(dir,type,nr,size) \</span></span><br><span class="line"><span class="meta">  (((dir)  &lt;&lt; _IOC_DIRSHIFT) | \</span></span><br><span class="line"><span class="meta">   ((type) &lt;&lt; _IOC_TYPESHIFT) | \</span></span><br><span class="line"><span class="meta">   ((nr)   &lt;&lt; _IOC_NRSHIFT) | \</span></span><br><span class="line"><span class="meta">   ((size) &lt;&lt; _IOC_SIZESHIFT))</span></span><br></pre></td></tr></table></figure>
<ul>
<li><strong>dir</strong>（direction），标志数据方向，占据2bit，取值为：<ul>
<li>_IOC_NONE：无数据</li>
<li>_IOC_READ：读数据</li>
<li>_IOC_WRITE：写数据</li>
<li>_IOC_READ | _IOC_WRITE：读写数据</li>
</ul>
</li>
<li><strong>type</strong>（device type），设备类型，占据8bit，可以为任意ASCII码，作用是使命令有唯一的设备标识</li>
<li><strong>nr</strong>（number），命令编号&#x2F;序数，占据8bit，取值范围 0~255</li>
<li><strong>size</strong>，涉及到ioctl接口的第三个可边长参数arg，占据13bit或者14bit（体系相关，ARM架构一般为14位），指定arg的数据类型及长度（如果在驱动ioctl实现中不检查，可以忽略该参数）</li>
</ul>
<p>既然有编码，肯定就有解码，Linux提供对应的解码方法（宏）为：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> _IOC_DIR(nr)        (((nr) &gt;&gt; _IOC_DIRSHIFT) &amp; _IOC_DIRMASK)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _IOC_TYPE(nr)       (((nr) &gt;&gt; _IOC_TYPESHIFT) &amp; _IOC_TYPEMASK)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _IOC_NR(nr)     (((nr) &gt;&gt; _IOC_NRSHIFT) &amp; _IOC_NRMASK)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _IOC_SIZE(nr)       (((nr) &gt;&gt; _IOC_SIZESHIFT) &amp; _IOC_SIZEMASK)</span></span><br></pre></td></tr></table></figure></li>
</ul>
<p>最后，总结一下ioctl的使用全流程：</p>
<ol>
<li>阅读硬件外设的技术手册</li>
<li>确定要实现的细分功能，开一个头文件，基于<code>_IOC</code>逐个功能定义cmd值</li>
<li>实现<code>unlocked_ioctl</code>，<code>compat_ioctl</code>；在里面解析匹配cmd值，执行对应的硬件操作</li>
<li>将实现的<code>unlocked_ioctl</code>两个接口，通过函数指针的形式赋值给<code>file_operations</code>结构体</li>
<li>正如“小试牛刀”章节中，申请、注册驱动，创建设备节点</li>
<li>用户使用<code>open</code>接口打开设备，调用<code>ioctl</code>执行相应的<code>cmd</code>。</li>
</ol>
<p>具体的演示，我们有3个文件：<code>demo.c</code>驱动源码文件，<code>test.c</code>用户源码文件，<code>chrdev.h</code>头文件。请读者自行学习：</p>
<ul>
<li><p>demo.c</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/module.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/fs.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/device.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/io.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/uaccess.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/gpio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;chrdev.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MY_LED_NUM 4</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> major;</span><br><span class="line"><span class="type">const</span> <span class="type">char</span> *name = <span class="string">&quot;demoname&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="keyword">class</span> *<span class="title">cls</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">device</span> *<span class="title">dev</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">unsigned</span> <span class="type">int</span> led_gpio_id[MY_LED_NUM] = &#123;</span><br><span class="line">  (<span class="number">1</span>*<span class="number">32</span>+<span class="number">4</span>),	<span class="comment">/* GPIO1_4 */</span></span><br><span class="line">  (<span class="number">1</span>*<span class="number">32</span>+<span class="number">5</span>),	<span class="comment">/* GPIO1_5 */</span></span><br><span class="line">  (<span class="number">1</span>*<span class="number">32</span>+<span class="number">6</span>),</span><br><span class="line">  (<span class="number">1</span>*<span class="number">32</span>+<span class="number">7</span>),</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">gpio</span> <span class="title">led_struct</span>[<span class="title">MY_LED_NUM</span>] =</span>&#123;</span><br><span class="line">  &#123;(<span class="number">1</span>*<span class="number">32</span>+<span class="number">4</span>), <span class="number">0</span>, <span class="string">&quot;led1&quot;</span>&#125;,</span><br><span class="line">  &#123;(<span class="number">1</span>*<span class="number">32</span>+<span class="number">5</span>), <span class="number">0</span>, <span class="string">&quot;led2&quot;</span>&#125;,</span><br><span class="line">  &#123;(<span class="number">1</span>*<span class="number">32</span>+<span class="number">6</span>), <span class="number">0</span>, <span class="string">&quot;led3&quot;</span>&#125;,</span><br><span class="line">  &#123;(<span class="number">1</span>*<span class="number">32</span>+<span class="number">7</span>), <span class="number">0</span>, <span class="string">&quot;led4&quot;</span>&#125;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">demo_open</span><span class="params">(<span class="keyword">struct</span> inode *inode, <span class="keyword">struct</span> file *filp)</span></span><br><span class="line">&#123;</span><br><span class="line">  printk(<span class="string">&quot;%s -- %d.\n&quot;</span>, __FUNCTION__, __LINE__);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">demo_release</span><span class="params">(<span class="keyword">struct</span> inode *inode, <span class="keyword">struct</span> file *filp)</span></span><br><span class="line">&#123;</span><br><span class="line">  printk(<span class="string">&quot;%s -- %d.\n&quot;</span>, __FUNCTION__, __LINE__);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">ssize_t</span> <span class="title function_">demo_read</span><span class="params">(<span class="keyword">struct</span> file *filp, <span class="type">char</span> __user *userbuf, <span class="type">size_t</span> size, <span class="type">loff_t</span> *offset)</span></span><br><span class="line">&#123;</span><br><span class="line">  printk(<span class="string">&quot;%s -- %d.\n&quot;</span>, __FUNCTION__, __LINE__);</span><br><span class="line">  <span class="comment">//copy_to_user(void __user * to, const void * from, size_t n);</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">ssize_t</span> <span class="title function_">demo_write</span><span class="params">(<span class="keyword">struct</span> file *filp, <span class="type">const</span> <span class="type">char</span> __user *userbuf, <span class="type">size_t</span> size, <span class="type">loff_t</span> *offset)</span></span><br><span class="line">&#123;</span><br><span class="line">  printk(<span class="string">&quot;%s -- %d.\n&quot;</span>, __FUNCTION__, __LINE__);</span><br><span class="line">  <span class="comment">//copy_from_user(void * to, const void __user * from, unsigned long n);</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">long</span> <span class="title function_">demo_ioctl</span><span class="params">(<span class="keyword">struct</span> file *filp, <span class="type">unsigned</span> <span class="type">int</span> cmd, <span class="type">unsigned</span> <span class="type">long</span> args)</span></span><br><span class="line">&#123;	</span><br><span class="line">  <span class="type">led_node_t</span> <span class="type">led_t</span>;</span><br><span class="line">  <span class="type">int</span> ret, led_num;</span><br><span class="line"></span><br><span class="line">  ret = copy_from_user(&amp;<span class="type">led_t</span>, (<span class="type">led_node_t</span> *)args, <span class="keyword">sizeof</span>(<span class="type">led_t</span>));	<span class="comment">//成功返回0，失败返回有多少个Bytes未完成copy。</span></span><br><span class="line">  <span class="keyword">if</span> (ret)</span><br><span class="line">  &#123;</span><br><span class="line">    printk(<span class="string">&quot;copy_from_user failed.\n&quot;</span>);</span><br><span class="line">    <span class="keyword">goto</span> err0;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  printk(<span class="string">&quot;%s -- %d.\n&quot;</span>, __FUNCTION__, __LINE__);</span><br><span class="line"></span><br><span class="line">  led_num = <span class="type">led_t</span>.which;</span><br><span class="line">  <span class="keyword">switch</span>(cmd)</span><br><span class="line">  &#123;</span><br><span class="line">  <span class="keyword">case</span> LEDON:</span><br><span class="line">    <span class="keyword">if</span> (led_num == <span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      printk(<span class="string">&quot;led%d on.\n&quot;</span>, led_num);</span><br><span class="line">      gpio_set_value(led_gpio_id[led_num<span class="number">-1</span>], <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (led_num == <span class="number">2</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      printk(<span class="string">&quot;led%d on.\n&quot;</span>, led_num);</span><br><span class="line">      gpio_set_value(led_gpio_id[led_num<span class="number">-1</span>], <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (led_num == <span class="number">3</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      printk(<span class="string">&quot;led%d on.\n&quot;</span>, led_num);</span><br><span class="line">      gpio_set_value(led_gpio_id[led_num<span class="number">-1</span>], <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (led_num == <span class="number">4</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      printk(<span class="string">&quot;led%d on.\n&quot;</span>, led_num);</span><br><span class="line">      gpio_set_value(led_gpio_id[led_num<span class="number">-1</span>], <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  <span class="keyword">case</span> LEDOFF:</span><br><span class="line">    <span class="keyword">if</span> (led_num == <span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      printk(<span class="string">&quot;led%d off.\n&quot;</span>, led_num);</span><br><span class="line">      gpio_set_value(led_gpio_id[led_num<span class="number">-1</span>], <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (led_num == <span class="number">2</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      printk(<span class="string">&quot;led%d off.\n&quot;</span>, led_num);</span><br><span class="line">      gpio_set_value(led_gpio_id[led_num<span class="number">-1</span>], <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (led_num == <span class="number">3</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      printk(<span class="string">&quot;led%d off.\n&quot;</span>, led_num);</span><br><span class="line">      gpio_set_value(led_gpio_id[led_num<span class="number">-1</span>], <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (led_num == <span class="number">4</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      printk(<span class="string">&quot;led%d off.\n&quot;</span>, led_num);</span><br><span class="line">      gpio_set_value(led_gpio_id[led_num<span class="number">-1</span>], <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  <span class="keyword">default</span>:</span><br><span class="line">    printk(<span class="string">&quot;cmd id error.\n&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">err0:</span><br><span class="line">  <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">file_operations</span> <span class="title">fops</span> =</span> &#123;</span><br><span class="line">  .open = demo_open,</span><br><span class="line">  .release = demo_release,</span><br><span class="line">  .read = demo_read,</span><br><span class="line">  .write = demo_write,</span><br><span class="line">  .unlocked_ioctl = demo_ioctl,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">led_init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> i, retval;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (i=<span class="number">0</span>; i&lt;MY_LED_NUM; i++)</span><br><span class="line">  &#123;</span><br><span class="line">    retval = gpio_is_valid(led_gpio_id[i]);</span><br><span class="line">    <span class="keyword">if</span> (retval == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      printk(<span class="string">&quot;gpio is not valid.\n&quot;</span>);</span><br><span class="line">      <span class="keyword">goto</span> err0;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  retval = gpio_request_array(led_struct, MY_LED_NUM);</span><br><span class="line">  <span class="keyword">if</span> (retval &lt; <span class="number">0</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    printk(<span class="string">&quot;retvla = %d.\n&quot;</span>, retval);</span><br><span class="line">    printk(<span class="string">&quot;gpio_request_array failed.\n&quot;</span>);</span><br><span class="line">    <span class="keyword">goto</span> err1;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (i=<span class="number">0</span>; i&lt;MY_LED_NUM; i++)</span><br><span class="line">  &#123;</span><br><span class="line">    gpio_direction_output(led_gpio_id[i], <span class="number">0</span>);	<span class="comment">// 将引脚设置为输出，并初始化为低电平</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">err1:</span><br><span class="line">  <span class="keyword">return</span> retval;</span><br><span class="line">err0:</span><br><span class="line">  <span class="keyword">return</span> retval;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> __init <span class="title function_">demo_init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  printk(<span class="string">&quot;%s -- %d.\n&quot;</span>, __FUNCTION__, __LINE__);</span><br><span class="line"></span><br><span class="line">  major = register_chrdev(<span class="number">0</span>, name, &amp;fops);</span><br><span class="line">  <span class="keyword">if</span> (major &lt;= <span class="number">0</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    printk(<span class="string">&quot;register_chrdev failed.\n&quot;</span>);</span><br><span class="line">    <span class="keyword">goto</span> err0;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  cls = class_create(THIS_MODULE, <span class="string">&quot;char_class&quot;</span>);</span><br><span class="line">  <span class="keyword">if</span> (cls == <span class="literal">NULL</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    printk(<span class="string">&quot;class_create failed.\n&quot;</span>);</span><br><span class="line">    <span class="keyword">goto</span> err1;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  dev = device_create(cls, <span class="literal">NULL</span>, MKDEV(major, <span class="number">0</span>), <span class="literal">NULL</span>, <span class="string">&quot;chrdev%d&quot;</span>, <span class="number">0</span>);</span><br><span class="line">  <span class="keyword">if</span> (dev ==<span class="literal">NULL</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    printk(<span class="string">&quot;device_create failed.\n&quot;</span>);</span><br><span class="line">    <span class="keyword">goto</span> err2;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  led_init();	<span class="comment">// 设置为输出模式</span></span><br><span class="line">  </span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">err2:</span><br><span class="line">  class_destroy(cls);</span><br><span class="line">err1:</span><br><span class="line">  unregister_chrdev(major, name);</span><br><span class="line">err0:</span><br><span class="line">  <span class="keyword">return</span> major;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> __exit <span class="title function_">demo_exit</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  printk(<span class="string">&quot;%s -- %d.\n&quot;</span>, __FUNCTION__, __LINE__);</span><br><span class="line"></span><br><span class="line">  gpio_free_array(led_struct, MY_LED_NUM);</span><br><span class="line"></span><br><span class="line">  device_destroy(cls, MKDEV(major, <span class="number">0</span>));</span><br><span class="line">  class_destroy(cls);</span><br><span class="line">  unregister_chrdev(major, name);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">module_init(demo_init);</span><br><span class="line">module_exit(demo_exit);</span><br><span class="line">MODULE_LICENSE(<span class="string">&quot;GPL&quot;</span>);</span><br><span class="line"></span><br></pre></td></tr></table></figure>
</li>
<li><p>test.c</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/ioctl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;chrdev.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">char</span> *pathname = <span class="string">&quot;/dev/chrdev0&quot;</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LED_NUM 4</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> fd, i;</span><br><span class="line">  <span class="type">led_node_t</span> led;</span><br><span class="line"></span><br><span class="line">  fd = open(pathname, O_RDWR, <span class="number">0666</span>);</span><br><span class="line">  <span class="keyword">if</span> (fd &lt;= <span class="number">0</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;open failed.\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (i=<span class="number">1</span>; i&lt;=LED_NUM; i++)</span><br><span class="line">  &#123;</span><br><span class="line">    led.which  = i;</span><br><span class="line">    </span><br><span class="line">    led.status = <span class="number">0</span>; <span class="comment">// 0表示灭</span></span><br><span class="line">    ioctl(fd, LEDOFF, &amp;led);</span><br><span class="line">    sleep(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    led.status = <span class="number">1</span>;	<span class="comment">// 1表示亮</span></span><br><span class="line">    ioctl(fd, LEDON, &amp;led);</span><br><span class="line">    sleep(<span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  close(fd);</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>chrdev.h</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> _CHRDEV_H_</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _CHRDEV_H_</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">led_node</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="type">int</span> which;</span><br><span class="line">  <span class="type">int</span> status;</span><br><span class="line">&#125;<span class="type">led_node_t</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LED_MAGIC <span class="string">&#x27;q&#x27;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LEDON  _IOW(LED_MAGIC, 0, struct led_node)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LEDOFF _IOW(LED_MAGIC, 1, struct led_node)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">/* chrdev.h */</span></span></span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="平台？总线？驱动？设备？"><a href="#平台？总线？驱动？设备？" class="headerlink" title="平台？总线？驱动？设备？"></a>平台？总线？驱动？设备？</h3><blockquote>
<p>笔者叹：学到这一关，真不容易啊~🤯马上就要拿下Linux驱动的最后一块高地了！</p>
</blockquote>
<p>因为Linux发展的太好了，Linux在服务器、PC机、嵌入式都可战可为，随着现代数字系统越来越复杂，接入CPU的外设越来越多，接口种类也各不尽相同，在<code>/dev/</code>目录中映射设备节点的方法，看的人眼花缭乱，在管理驱动上造成了极大的不便。因此类似Windows的<strong>设备管理器</strong>，Linux采用<strong>总线</strong>（Bus）模型来描述和管理，并且映射在了文件系统中，可以查看<code>/sys/bus/</code>目录：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ <span class="built_in">ls</span> /sys/bus/</span><br><span class="line"></span><br><span class="line">ac97         edac          machinecheck  parport      sdio     workqueue</span><br><span class="line">acpi         eisa          mdio_bus      pci          serial   xen</span><br><span class="line">cec          event_source  memory        pci-epf      serio    xen-backend</span><br><span class="line">clockevents  gameport      mipi-dsi      pci_express  snd_seq</span><br><span class="line">clocksource  gpio          mmc           platform     spi</span><br><span class="line">container    hid           nd            pnp          usb</span><br><span class="line">cpu          i2c           node          rapidio      virtio</span><br><span class="line">dax          isa           nvmem         scsi         vme</span><br></pre></td></tr></table></figure>

<p>眼尖的硬件选手，已经发现这里的子项就是一个个总线名字，耳熟能详的如：USB、PCI、SPI。再随便挑一个子项<code>ls</code>或者<code>tree</code>展开看看，发现每个里头都是统一的2个文件夹（devices、drivers）+3个文件（drivers_autoprobe、drivers_probe、uevent）：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ tree -L2 /sys/bus</span><br><span class="line"></span><br><span class="line">/sys/bus</span><br><span class="line">├── spi</span><br><span class="line">│   ├── devices</span><br><span class="line">│   ├── drivers</span><br><span class="line">│   ├── drivers_autoprobe</span><br><span class="line">│   ├── drivers_probe</span><br><span class="line">│   └── uevent</span><br><span class="line">├── usb</span><br><span class="line">│   ├── devices</span><br><span class="line">│   ├── drivers</span><br><span class="line">│   ├── drivers_autoprobe</span><br><span class="line">│   ├── drivers_probe</span><br><span class="line">│   └── uevent</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p>如果读者查看<em>iic</em>总线下的<em>devices</em>和<em>drivers</em>，并和笔者一样在虚拟机里跑的<em>Ubuntu</em>会发现：在drivers目录下有很多不同的项（驱动程序），但devices是空的。再观察<em>cpu</em>总线的<em>devices</em>和<em>drivers</em>，会发现drivers里只有一个processor，而devices里有很多个cpu。</p>
<p>此时，读者应该对这个Linux的“驱动&amp;设备管理器”有些直觉上的认知了吧？</p>
<p>没错，正如下图（的上部分）所绘制的</p>
<ol>
<li>Linux<strong>总线（Bus）模型</strong>将所有内容先是按照<strong>通信总线</strong>进行分类（因为同类的总线，往往有很多共性，这是OOP思想）；</li>
<li>接着在每个总线下划分了<strong>驱动（Driver）</strong>和<strong>设备（Device）</strong></li>
<li>把所有安装的驱动程序（包括使用中的、未来使用的），放到<strong>Driver</strong>目录下；</li>
<li>把实际检测到插入的设备，或虚拟的设备，注册后放到<strong>Device</strong>下；</li>
</ol>
<p>这样做的好处有：</p>
<ul>
<li>整体结构清晰，方便查找</li>
<li>多个相同的设备接入，共用一个驱动程序（比如3个一样的MP3通过USB一起插到电脑），特定参数在device中，不在driver中，适应性更强</li>
</ul>
<p>但有个特殊情况，有些设备本身是没有总线的。比如LED，就是SoC的一个GPIO口子。所以Linux提供了一个专门放杂物的总线——<strong>平台platform</strong>。下图完整地展示了 总线模型下的 platform总线下的 驱动和设备 分别是如何实现的：</p>
<p><img src="https://blog-img-goryj.oss-rg-china-mainland.aliyuncs.com/blogpost/20230222-Linux-8.png" alt="platform"></p>
<p>NOTE：这边引用了大佬“火山上的企鹅”发表于CSDN上的文章<a href="https://blog.csdn.net/qq_16504163/article/details/118562670">一张图掌握 Linux platform 平台设备驱动框架</a></p>
<hr>
<p>分清楚了总线、平台、驱动、设备这4个概念后，我们来看具体原理和如何使用：</p>
<h4 id="总线原理"><a href="#总线原理" class="headerlink" title="总线原理"></a>总线原理</h4><p>Linux内核实现<strong>总线</strong>的方式是，管理两个链表：设备链表、驱动链表。</p>
<ul>
<li>向内核注册一个驱动时，便插入到总线的<strong>驱动链表</strong>。</li>
<li>向内核注册一个设备时，便插入到总线的<strong>设备链表</strong>。</li>
<li>在插入链表后（驱动和设备都会），总线会执行<code>bus_type</code>结构体中的<code>match</code>方法对新插入的 设备&#x2F;驱动 进行匹配。（以<code>name</code>名字的方式匹配，具体见上面大图中的调用）</li>
<li>匹配成功后，会调用注册驱动时<code>device_driver</code>结构体中的<code>probe</code>方法。</li>
<li>同理，移除设备或驱动时，调用<code>device_driver</code>结构体中的<code>remove</code>方法。</li>
</ul>
<h4 id="总线的使用"><a href="#总线的使用" class="headerlink" title="总线的使用"></a>总线的使用</h4><ul>
<li>相关数据类型：<ul>
<li>总线结构体： <code>bus_type</code></li>
<li>设备结构体： <code>device</code></li>
<li>驱动结构体： <code>device_driver</code></li>
</ul>
</li>
<li>相关接口：<ul>
<li>注册总线：<code>bus_register</code>。其实Linux已经编好了大部分的总线驱动</li>
<li>注销总线：<code>bus_unregister</code></li>
<li>注册设备：<code>device_register</code></li>
<li>注销设备：<code>device_unregister</code></li>
<li>注册驱动：<code>driver_register</code></li>
<li>注销驱动：<code>driver_unregister</code></li>
</ul>
</li>
</ul>
<p>考虑到使用过程和平台总线很相似，为了节省篇幅，此处不上代码，读者看下小节的代码就懂了。</p>
<h4 id="平台总线（platform-bus）使用"><a href="#平台总线（platform-bus）使用" class="headerlink" title="平台总线（platform bus）使用"></a>平台总线（platform bus）使用</h4><ul>
<li><p>驱动</p>
<ol>
<li>填充<code>struct platform_driver</code></li>
<li>向系统注册驱动<code>platform_driver_register</code></li>
<li>注销驱动<code>platform_driver_unregister</code></li>
</ol>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//btn_drv.c</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/init.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/module.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/platform_device.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;btn_desc.h&quot;</span></span></span><br><span class="line"></span><br><span class="line">MODULE_LICENSE(<span class="string">&quot;GPL&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//1）填充 struct platform_driver  的各个成员:  .probe = btn_probe</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">btn_probe</span><span class="params">(<span class="keyword">struct</span> platform_device *dev)</span></span><br><span class="line">&#123;</span><br><span class="line">    printk(<span class="string">&quot;call %s\n&quot;</span>, __func__);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//1）填充 struct platform_driver  的各个成员:  .remove = btn_remove</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">btn_remove</span><span class="params">(<span class="keyword">struct</span> platform_device *dev)</span></span><br><span class="line">&#123;</span><br><span class="line">    printk(<span class="string">&quot;call %s\n&quot;</span>, __func__);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//1）填充 struct platform_driver  的各个成员:  绑定</span></span><br><span class="line"><span class="comment">//继承于device_driver的 platform_driver 设备驱动</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">platform_driver</span> <span class="title">btn_drv</span> =</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">//struct device_driver driver</span></span><br><span class="line">    .driver =</span><br><span class="line">    &#123;</span><br><span class="line">        .name = <span class="string">&quot;mybuttons&quot;</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">    </span><br><span class="line">  <span class="comment">//int (*probe)(struct platform_device *)</span></span><br><span class="line">    .probe = btn_probe,</span><br><span class="line">    <span class="comment">//int (*remove)(struct platform_device *)</span></span><br><span class="line">    .remove = btn_remove,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//2）向系统注册驱动：platform_driver_register</span></span><br><span class="line"><span class="type">int</span> __init <span class="title function_">btn_drv_init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    platform_driver_register(&amp;btn_drv);  <span class="comment">//1.向dev中加入一个节点， 2.与device设备匹配</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//3）注销驱动：platform_driver_unregister</span></span><br><span class="line"><span class="type">void</span> __exit <span class="title function_">btn_drv_exit</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    platform_driver_unregister(&amp;btn_drv);</span><br><span class="line">&#125;</span><br><span class="line">module_init(btn_drv_init);</span><br><span class="line">module_exit(btn_drv_exit);</span><br></pre></td></tr></table></figure>
</li>
<li><p>设备</p>
<ol>
<li>填充<code>struct platform_device</code></li>
<li>向系统注册设备<code>platform_device_register</code></li>
<li>注销设备<code>platform_device_unregister</code></li>
</ol>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//btn_dev.c</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/init.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/module.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/input.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/platform_device.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;mach/platform.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;btn_desc.h&quot;</span></span></span><br><span class="line"></span><br><span class="line">MODULE_LICENSE(<span class="string">&quot;GPL&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//1) 填充 struct platform_device 的各个成员：初始化 resource 结构变量。</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span>  <span class="title">resource</span> <span class="title">btn_resource</span>[]=</span></span><br><span class="line">&#123;</span><br><span class="line">    &#123;</span><br><span class="line">        .start = IRQ_GPIO_A_START + <span class="number">28</span>,</span><br><span class="line">        .end   = IRQ_GPIO_A_START + <span class="number">28</span>,  <span class="comment">//可以不赋值</span></span><br><span class="line">        .flags = IORESOURCE_IRQ,         <span class="comment">//中断类型资源</span></span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">        .start = IRQ_GPIO_B_START + <span class="number">30</span>,</span><br><span class="line">        .end   = IRQ_GPIO_B_START + <span class="number">30</span>,  <span class="comment">//可以不赋值</span></span><br><span class="line">        .flags = IORESOURCE_IRQ,</span><br><span class="line">    &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//1) 填充 struct platform_device 的各个成员：初始化 私有资源 结构变量。</span></span><br><span class="line"><span class="type">btn_desc_t</span> buttons[] =  <span class="comment">//私有资源，描述信息</span></span><br><span class="line">&#123;</span><br><span class="line">    &#123;<span class="string">&quot;up&quot;</span>,   PAD_GPIO_A+<span class="number">28</span>, KEY_UP&#125;,</span><br><span class="line">    &#123;<span class="string">&quot;down&quot;</span>, PAD_GPIO_B+<span class="number">30</span>, KEY_DOWN&#125;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//1) 填充 struct platform_device 的各个成员：  注销设备时，调用</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">btn_release</span><span class="params">(<span class="keyword">struct</span> device *dev)</span>  </span><br><span class="line">&#123;</span><br><span class="line">    printk(<span class="string">&quot;call %s\n&quot;</span>, __func__);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//1) 填充 struct platform_device 的各个成员：</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">platform_device</span> <span class="title">btn_dev</span> =</span></span><br><span class="line">&#123;</span><br><span class="line">    .name = <span class="string">&quot;mybuttons&quot;</span>,</span><br><span class="line">    .dev =</span><br><span class="line">    &#123;</span><br><span class="line">        .release = btn_release,</span><br><span class="line">        .platform_data = (<span class="type">void</span> *)buttons,  <span class="comment">//私有，平台设备总线</span></span><br><span class="line">    &#125;,</span><br><span class="line">    .resource = btn_resource,</span><br><span class="line">    .num_resources = ARRAY_SIZE(btn_resource), <span class="comment">//资源个数</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2）向系统注册设备：platform_device_register</span></span><br><span class="line"><span class="type">int</span> __init <span class="title function_">btn_dev_init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    platform_device_register(&amp;btn_dev);  <span class="comment">//1.向dev中加入一个节点， 2.与driver设备匹配</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//3）注销设备：platform_device_unregister</span></span><br><span class="line"><span class="type">void</span> __exit <span class="title function_">btn_dev_exit</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    platform_device_unregister(&amp;btn_dev);</span><br><span class="line">&#125;</span><br><span class="line">module_init(btn_dev_init);</span><br><span class="line">module_exit(btn_dev_exit);</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="设备树Device-Tree"><a href="#设备树Device-Tree" class="headerlink" title="设备树Device Tree"></a>设备树Device Tree</h2><p>为什么设备树放最后呢？因为设备树其实用的最多，改起来简单方便（对着Datasheet输参数），但是出bug的时候，前面的所有知识缺一不可。</p>
<p>设备树作用：硬件细节不写驱动里，外设数量、参数和总线拓扑关系等，放设备树里随改随用，提高了灵活性和内核的整洁性。</p>
<blockquote>
<p>关于设备树在Linux（ARM）的起源，有一句“This whole ARM thing is a f*cking pain in the ass”典故。有兴趣自查。</p>
</blockquote>
<p>本质上，设备树模型其实和上面的总线模型很像，如下图，设备树的根节点就是系统总线。</p>
<p><img src="https://blog-img-goryj.oss-rg-china-mainland.aliyuncs.com/blogpost/20230222-Linux-9.png" alt="DeviceTree"></p>
<p>三个常见词：</p>
<ul>
<li>DTS：设备树的源文件<code>.dts</code>，类似JSON格式，给人读写的</li>
<li>DTSI：设备树头文件<code>.dtsi</code>，放通用配置，比如ARM Cortex-A7的配置对于一批SoC都能用</li>
<li>DTC：编译器，把<code>.dts</code>文件编译成<code>.dtb</code>文件</li>
<li>DTB：二进制设备树文件<code>.dtb</code>，给Linux读的</li>
</ul>
<h3 id="设备树源文件写法"><a href="#设备树源文件写法" class="headerlink" title="设备树源文件写法"></a>设备树源文件写法</h3><p>先看后学：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;common_part_board_header.dtsi&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;common_part_header_2.h&gt;</span></span></span><br><span class="line"><span class="string"><span class="meta"></span></span></span><br><span class="line"><span class="string"><span class="meta">/ &#123;</span></span></span><br><span class="line"><span class="string"><span class="meta"></span></span></span><br><span class="line"><span class="string"><span class="meta">  #address-cells = &lt;1&gt;;</span></span></span><br><span class="line"><span class="string"><span class="meta">  #size-cells = &lt;1&gt;;</span></span></span><br><span class="line"><span class="string"><span class="meta"></span></span></span><br><span class="line"><span class="string"><span class="meta">  aliases &#123;</span></span></span><br><span class="line"><span class="string"><span class="meta">    serial0 = &amp;uart4;</span></span></span><br><span class="line"><span class="string"><span class="meta">  &#125;;</span></span></span><br><span class="line"><span class="string"><span class="meta"></span></span></span><br><span class="line"><span class="string"><span class="meta">  cpus &#123;</span></span></span><br><span class="line"><span class="string"><span class="meta">    #address-cells = &lt;1&gt;;</span></span></span><br><span class="line"><span class="string"><span class="meta">    #size-cells = &lt;0&gt;;</span></span></span><br><span class="line"><span class="string"><span class="meta"></span></span></span><br><span class="line"><span class="string"><span class="meta">    cpu0: cpu@0 &#123;</span></span></span><br><span class="line"><span class="string"><span class="meta">      compatible = &quot;</span>arm,cortex-a7<span class="string">&quot;;</span></span></span><br><span class="line"><span class="string"><span class="meta">      device_type = &quot;</span>cp<span class="string">u&quot;;</span></span></span><br><span class="line"><span class="string"><span class="meta">      reg = &lt;0&gt;;</span></span></span><br><span class="line"><span class="string"><span class="meta">      clocks = &lt;&amp;scmi0_clk CK_SCMI0_MPU&gt;;</span></span></span><br><span class="line"><span class="string"><span class="meta">      clock-names = &quot;</span>cp<span class="string">u&quot;;</span></span></span><br><span class="line"><span class="string"><span class="meta">      operating-points-v2 = &lt;&amp;cpu0_opp_table&gt;;</span></span></span><br><span class="line"><span class="string"><span class="meta">      nvmem-cells = &lt;&amp;part_number_otp&gt;;</span></span></span><br><span class="line"><span class="string"><span class="meta">      nvmem-cell-names = &quot;</span>part_number<span class="string">&quot;;</span></span></span><br><span class="line"><span class="string"><span class="meta">      #cooling-cells = &lt;2&gt;;</span></span></span><br><span class="line"><span class="string"><span class="meta">    &#125;;</span></span></span><br><span class="line"><span class="string"><span class="meta">  &#125;;</span></span></span><br><span class="line"><span class="string"><span class="meta"></span></span></span><br><span class="line"><span class="string"><span class="meta">  soc &#123;</span></span></span><br><span class="line"><span class="string"><span class="meta">    compatible = &quot;</span>simple-bus<span class="string">&quot;;</span></span></span><br><span class="line"><span class="string"><span class="meta">    #address-cells = &lt;1&gt;;</span></span></span><br><span class="line"><span class="string"><span class="meta">    #size-cells = &lt;1&gt;;</span></span></span><br><span class="line"><span class="string"><span class="meta">    interrupt-parent = &lt;&amp;intc&gt;;</span></span></span><br><span class="line"><span class="string"><span class="meta">    ranges;</span></span></span><br><span class="line"><span class="string"><span class="meta"></span></span></span><br><span class="line"><span class="string"><span class="meta">    sram: sram@10000000 &#123;</span></span></span><br><span class="line"><span class="string"><span class="meta">      compatible = &quot;</span>mmio-sram<span class="string">&quot;;</span></span></span><br><span class="line"><span class="string"><span class="meta">      reg = &lt;0x10000000 0x60000&gt;;</span></span></span><br><span class="line"><span class="string"><span class="meta">      #address-cells = &lt;1&gt;;</span></span></span><br><span class="line"><span class="string"><span class="meta">      #size-cells = &lt;1&gt;;</span></span></span><br><span class="line"><span class="string"><span class="meta">      ranges = &lt;0 0x10000000 0x60000&gt;;</span></span></span><br><span class="line"><span class="string"><span class="meta">    &#125;;</span></span></span><br><span class="line"><span class="string"><span class="meta">  &#125;;</span></span></span><br><span class="line"><span class="string"><span class="meta">&#125;;</span></span></span><br></pre></td></tr></table></figure>

<ul>
<li>可包含<code>.dtsi</code>头文件引入通用的属性，也可以包含标准C形式的头文件<code>.h</code></li>
<li>每个dts文件只有一个根节点<code>/</code>，包含了其他文件中的设备树之后自动合并根节点</li>
<li>每个设备必是子节点</li>
<li>节点命名方式：<code>node-name@address</code>，后半部分地址（@address）记录设备地址或寄存器首地址，不用可以不要</li>
<li>节点可起标签（label）：<code>label: node-name@unit-address</code></li>
<li>标签可在其他地方快速索引节点：<code>@label</code></li>
<li>每个节点都可以有：子节点，属性（键值对，如<code>reg=&lt;0&gt;;</code>）</li>
<li>属性中的数值可以是：<ul>
<li>字符串<code>compatible = &quot;arm,cortex-a7&quot;;</code></li>
<li>字符串列表<code>compatible = &quot;arm,cortex-a7&quot;,&quot;arm,cortex-a53&quot;;</code></li>
<li>无符号整数<code>reg = &lt;0 0x123456 100&gt;;</code></li>
</ul>
</li>
<li>Linux内核使用的标准属性<ul>
<li>compatible，兼容性属性：用来匹配驱动程序</li>
<li>model，模块信息：描述模块名字</li>
<li>status，设备状态，取值（字符串）为：<ul>
<li>“okay”：可用</li>
<li>“disabled”：不可用，但未来可用。常见于热拔插接口</li>
<li>“fail”：出错</li>
<li>“fail-sss”：sss是出错内容</li>
</ul>
</li>
<li>#address-cells，reg属性中地址的字长，字为32位</li>
<li>#size-cells，reg属性中长度信息的字长</li>
<li>reg，描述设备地址空间，写法：<code>reg = &lt;address1 length1 address2 length2 address3 length3……&gt;</code></li>
<li>ranges，地址映射&#x2F;转换表，写法：<code>ranges = &lt;child-bus-address parent-bus-address length&gt;;</code></li>
</ul>
</li>
</ul>
<h3 id="追加-修改节点内容"><a href="#追加-修改节点内容" class="headerlink" title="追加&#x2F;修改节点内容"></a>追加&#x2F;修改节点内容</h3><p>使用<code>#include</code>包含了通用<code>.dtsi</code>头文件的内容后，如果要对其中的某个节点内容进行修改，或者增加，应该使用<strong>引用</strong>：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">&amp;i2c1 &#123;</span><br><span class="line"><span class="comment">/* 要追加或修改的内容 */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="设备树如何作用于驱动"><a href="#设备树如何作用于驱动" class="headerlink" title="设备树如何作用于驱动"></a>设备树如何作用于驱动</h3><p>设备树二进制文件<code>.dtb</code>被Linux内核解读后，相关参数就可以被驱动程序读取了。驱动程序实现中，基础的硬件交互操作都不用改动，主要是模块初始化函数中，加入读取设备树、匹配设备、获取参数的功能。关键接口：</p>
<ul>
<li>获取节点：<code>of_find_node_by_path</code></li>
<li>读属性：<code>of_find_property</code></li>
<li>读字符：<code>of_property_read_string</code></li>
<li>读数组：<code>of_property_read_u32_array</code></li>
<li>内存映射：<code>of_iomap</code></li>
</ul>
<p>具体见下代码：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> __init <span class="title function_">led_init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  u32 val = <span class="number">0</span>;</span><br><span class="line">  <span class="type">int</span> ret;</span><br><span class="line">  u32 regdata[<span class="number">12</span>];</span><br><span class="line">  <span class="type">const</span> <span class="type">char</span> *str;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">property</span> *<span class="title">proper</span>;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 获取设备树中的属性数据 */</span></span><br><span class="line">  <span class="comment">/* 1、获取设备节点：stm32mp1_led */</span></span><br><span class="line">  dtsled.nd = of_find_node_by_path(<span class="string">&quot;/stm32mp1_led&quot;</span>);</span><br><span class="line">  <span class="keyword">if</span>(dtsled.nd == <span class="literal">NULL</span>) &#123;</span><br><span class="line">    printk(<span class="string">&quot;stm32mp1_led node nost find!\r\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> -EINVAL;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    printk(<span class="string">&quot;stm32mp1_lcd node find!\r\n&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 2、获取 compatible 属性内容 */</span></span><br><span class="line">  proper = of_find_property(dtsled.nd, <span class="string">&quot;compatible&quot;</span>, <span class="literal">NULL</span>);</span><br><span class="line">  <span class="keyword">if</span>(proper == <span class="literal">NULL</span>) &#123;</span><br><span class="line">    printk(<span class="string">&quot;compatible property find failed\r\n&quot;</span>);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    printk(<span class="string">&quot;compatible = %s\r\n&quot;</span>, (<span class="type">char</span>*)proper-&gt;value);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 3、获取 status 属性内容 */</span></span><br><span class="line">  ret = of_property_read_string(dtsled.nd, <span class="string">&quot;status&quot;</span>, &amp;str);</span><br><span class="line">  <span class="keyword">if</span>(ret &lt; <span class="number">0</span>)&#123;</span><br><span class="line">    printk(<span class="string">&quot;status read failed!\r\n&quot;</span>);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    printk(<span class="string">&quot;status = %s\r\n&quot;</span>,str);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 4、获取 reg 属性内容 */</span></span><br><span class="line">  ret = of_property_read_u32_array(dtsled.nd, <span class="string">&quot;reg&quot;</span>, regdata, <span class="number">12</span>);</span><br><span class="line">  <span class="keyword">if</span>(ret &lt; <span class="number">0</span>) &#123;</span><br><span class="line">    printk(<span class="string">&quot;reg property read failed!\r\n&quot;</span>);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    u8 i = <span class="number">0</span>;</span><br><span class="line">    printk(<span class="string">&quot;reg data:\r\n&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; <span class="number">12</span>; i++)</span><br><span class="line">    printk(<span class="string">&quot;%#X &quot;</span>, regdata[i]);</span><br><span class="line">    printk(<span class="string">&quot;\r\n&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 初始化 LED */</span></span><br><span class="line">  <span class="comment">// 略</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 注册字符设备驱动 */</span></span><br><span class="line">  <span class="comment">/* 1、创建设备号 */</span></span><br><span class="line">  <span class="keyword">if</span> (dtsled.major) &#123; <span class="comment">/* 定义了设备号 */</span></span><br><span class="line">    dtsled.devid = MKDEV(dtsled.major, <span class="number">0</span>);</span><br><span class="line">    ret = register_chrdev_region(dtsled.devid, DTSLED_CNT,DTSLED_NAME);</span><br><span class="line">    <span class="keyword">if</span>(ret &lt; <span class="number">0</span>) &#123;</span><br><span class="line">      pr_err(<span class="string">&quot;cannot register %s char driver [ret=%d]\n&quot;</span>,DTSLED_NAME, DTSLED_CNT);</span><br><span class="line">      <span class="keyword">goto</span> fail_map;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123; <span class="comment">/* 没有定义设备号 */</span></span><br><span class="line">    ret = alloc_chrdev_region(&amp;dtsled.devid, <span class="number">0</span>, DTSLED_CNT,DTSLED_NAME); <span class="comment">/* 申请设备号 */</span></span><br><span class="line">    <span class="keyword">if</span>(ret &lt; <span class="number">0</span>) &#123;</span><br><span class="line">      pr_err(<span class="string">&quot;%s Couldn&#x27;t alloc_chrdev_region, ret=%d\r\n&quot;</span>,DTSLED_NAME, ret);</span><br><span class="line">      <span class="keyword">goto</span> fail_map;</span><br><span class="line">    &#125;</span><br><span class="line">    dtsled.major = MAJOR(dtsled.devid); <span class="comment">/* 获取分配号的主设备号 */</span></span><br><span class="line">    dtsled.minor = MINOR(dtsled.devid); <span class="comment">/* 获取分配号的次设备号 */</span></span><br><span class="line">  &#125;</span><br><span class="line">  printk(<span class="string">&quot;dtsled major=%d,minor=%d\r\n&quot;</span>,dtsled.major,</span><br><span class="line">  dtsled.minor); </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 2、初始化 cdev */</span></span><br><span class="line">  dtsled.cdev.owner = THIS_MODULE;</span><br><span class="line">  cdev_init(&amp;dtsled.cdev, &amp;dtsled_fops);</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 3、添加一个 cdev */</span></span><br><span class="line">  ret = cdev_add(&amp;dtsled.cdev, dtsled.devid, DTSLED_CNT);</span><br><span class="line">  <span class="keyword">if</span>(ret &lt; <span class="number">0</span>)</span><br><span class="line">  <span class="keyword">goto</span> del_unregister;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 4、创建类 */</span></span><br><span class="line">  dtsled.class = class_create(THIS_MODULE, DTSLED_NAME);</span><br><span class="line">  <span class="keyword">if</span> (IS_ERR(dtsled.class)) &#123;</span><br><span class="line">  <span class="keyword">goto</span> del_cdev;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 5、创建设备 */</span></span><br><span class="line">  dtsled.device = device_create(dtsled.class, <span class="literal">NULL</span>, dtsled.devid, <span class="literal">NULL</span>, DTSLED_NAME);</span><br><span class="line">  <span class="keyword">if</span> (IS_ERR(dtsled.device)) &#123;</span><br><span class="line">    <span class="keyword">goto</span> destroy_class;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  destroy_class:</span><br><span class="line">  class_destroy(dtsled.class);</span><br><span class="line">  del_cdev:</span><br><span class="line">  cdev_del(&amp;dtsled.cdev);</span><br><span class="line">  del_unregister:</span><br><span class="line">  unregister_chrdev_region(dtsled.devid, DTSLED_CNT);</span><br><span class="line">  fail_map:</span><br><span class="line">  led_unmap();</span><br><span class="line">  <span class="keyword">return</span> -EIO;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> __exit <span class="title function_">led_exit</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">  led_unmap();</span><br><span class="line"></span><br><span class="line">  cdev_del(&amp;dtsled.cdev);</span><br><span class="line"></span><br><span class="line">  unregister_chrdev_region(dtsled.devid, DTSLED_CNT);</span><br><span class="line">  device_destroy(dtsled.class, dtsled.devid);</span><br><span class="line">  class_destroy(dtsled.class);</span><br><span class="line">&#125;</span><br><span class="line">module_init(led_init);</span><br><span class="line">module_exit(led_exit);</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="设备树从上电到下岗"><a href="#设备树从上电到下岗" class="headerlink" title="设备树从上电到下岗"></a>设备树从上电到下岗</h3><p>上面我们说过U-Boot的作用是进行简单基础的初始化，然后引导系统，其实设备树也就是在这个时候开始被加载的，并在内存中被作为参数一样传递给启动的Linux内核。具体过程为：</p>
<ol>
<li>系统上电后，U-Boot从SDMMC&#x2F;EMMC中读取设备树文件（编译好的dtb），并放在内存中；</li>
<li>U-Boot引导Linux内核启动，传递设备树的内存地址（指针）给Linux；</li>
<li>Linux内核解析设备树内容，转换成<code>platform_device</code>类型数据，并注册“设备”进系统；</li>
<li>驱动程序模块逐个加载，基于<code>platform_driver_register</code>接口注册<code>platform_driver</code>的“驱动”进系统；</li>
<li>系统通过匹配OF表，在<code>probe</code>方法中，把真正的硬件驱动程序跑起来。（详细匹配原理见上面讲平台的那张大图）。</li>
</ol>
]]></content>
      <categories>
        <category>嵌入式&amp;控制算法</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>驱动程序</tag>
      </tags>
  </entry>
  <entry>
    <title>LVDS接收数据流（这一篇就够了）</title>
    <url>/2024/06/13/lvdsRecv/</url>
    <content><![CDATA[<blockquote>
<p>本文将以驱动AFE5832高速模拟前端为开发目标，依次分析设计需求、方案原理、在Zynq Ultrascale+上的Verilog实现，最后扩展分享更通用、更有鲁棒性的LVDS Receiver。注：本文针对具有Verilog语言基础和FPGA基础概念的用户。</p>
</blockquote>
<h2 id="接口设计需求简析"><a href="#接口设计需求简析" class="headerlink" title="接口设计需求简析"></a>接口设计需求简析</h2><p><a href="https://www.ti.com.cn/product/cn/AFE5832">AFE5832</a>是TI公司的一款适用于超声应用的模拟前端芯片，内含从LNA、LPF、到ADC的完整信号链和其他超声需要的辅助模块。采样方面，总共有32路输入，16个ADC，每个ADC支持12bit@40MSPS或者10bit@50MSPS采样，每个ADC的结果分别用一个LVDS的Lane串行输出。配置方面使用SPI接口，可以直接用AXI-SPI的IP核控制，不作介绍，所以接下来的篇幅将开始集中在LVDS方面。</p>
<blockquote>
<p>NOTE：笔者使用ZYNQ的PS的SPI，发现有BUG，只能EMIO出信号，MIO一样的代码不行</p>
</blockquote>
<p><img src="https://blog-img-goryj.oss-rg-china-mainland.aliyuncs.com/blogpost/202406_LVDS_1.png" alt="AFE5832"></p>
<p>AFE5832的LVDS数据输出接口如下图，有16对Data Lane（<strong>DOUT</strong>），和1对串行数据时钟Serial Data CLK Lane（<strong>DCLK</strong>），以及1对用来划分数据帧的Frame CLK Lane（<strong>FCLK</strong>）。</p>
<span id="more"></span>

<p><img src="https://blog-img-goryj.oss-rg-china-mainland.aliyuncs.com/blogpost/202406_LVDS_2.png" alt="AFE832LVDS"></p>
<p>为了更好地理解这18对Lane的用途，下图截取了Datasheet上的时序说明。注意，这里手册上说明时序是使用单端信号表征，并且名字不是很统一（DCLK这里又变成Bit Clock output了，但这好像更好理解了）。很明显，数据Lane是工作在DDR（Double-Data Rate）的模式，在DCLK的时钟上下边沿抓数据。具体下图中的各参数，本文为规避风险不放，因为TI现在完整的Datasheet是用户签NDA才有的，想要具体了解，可以私信笔者学术交流。</p>
<p><img src="https://blog-img-goryj.oss-rg-china-mainland.aliyuncs.com/blogpost/202406_LVDS_3.png" alt="LVDSTiming"></p>
<p>所以，在FPGA侧的LVDS接收器的目标概括为：</p>
<ul>
<li>ADC工作转换率：$f_c &#x3D; 80$MSPS</li>
<li>ADC转换位数：$N_{ser}&#x3D;12$</li>
<li>帧时钟频率：$f_{Fclk}&#x3D;0.5\times f_c &#x3D; 40$MHz</li>
<li>数据Lane的波特率：$f_D &#x3D; N_{ser} \times f_c &#x3D; 960$MHz</li>
<li>时钟Lane频率：$f_{Dclk}&#x3D;f_D&#x2F;2&#x3D;480$MHz</li>
<li>16路LVDS receiver + 1:12  deserializer</li>
<li>并帧识别划分后分双通道输出数据（如下图所示，每个ADC轮番转换两个通道，这也是FCLK帧信号的主要用途）</li>
</ul>
<p><img src="https://blog-img-goryj.oss-rg-china-mainland.aliyuncs.com/blogpost/202406_LVDS_4.png" alt="FCLK帧时钟用途"></p>
<h2 id="FPGA的LVDS接收器方案"><a href="#FPGA的LVDS接收器方案" class="headerlink" title="FPGA的LVDS接收器方案"></a>FPGA的LVDS接收器方案</h2><p><img src="https://blog-img-goryj.oss-rg-china-mainland.aliyuncs.com/blogpost/202406_LVDS_5.svg" alt="LVDS接收器框图"></p>
<h3 id="FPGA关键原语"><a href="#FPGA关键原语" class="headerlink" title="FPGA关键原语"></a>FPGA关键原语</h3><blockquote>
<p>这里笔者使用的是AMD的 Ultrascale+ 系列FPGA，如果用Intel或国产的也是差不多的，读者应当注意对应移植细节。<br>这里做概念介绍方便理解代码，具体例化的接口定义请参考《UG571 UltraScale Architecture SelectIO Resources》</p>
</blockquote>
<ul>
<li><p>IBUFDS：差分输入信号转单端数字信号<br><img src="https://blog-img-goryj.oss-rg-china-mainland.aliyuncs.com/blogpost/202406_LVDS_6.png" alt="IBUFDS"></p>
</li>
<li><p>IDELAYE3：任何输入信号都可以用IDELAYE3进行延迟，除了时钟信号（必须用PLL或MMCM）。里面的Tap Delay Line支持512级延迟调节，但是每一级的延迟时间是没校准的，需要使用 IDELAYCTR 组件来额外补偿控制。<br><img src="https://blog-img-goryj.oss-rg-china-mainland.aliyuncs.com/blogpost/202406_LVDS_7.png" alt="IDELAYE3"></p>
</li>
<li><p>ISERDESE3：把串行输入（D口）的数据按一组并行输出。在SDR模式下支持1:2和1:4串转并，在DDR模式下支持1:4和1:8。</p>
<p>  <img src="https://blog-img-goryj.oss-rg-china-mainland.aliyuncs.com/blogpost/202406_LVDS_8.png" alt="ISERDESE3"><br>  如下图，是ISERDES的DATA_WIDTH为8时，DDR模式的时序。可见使用ISERDES可以在电路初级就完成时钟的降频（降低4倍），这对应可以带来大量的功耗优化、资源节省和布线时序优化。<br>  <img src="https://blog-img-goryj.oss-rg-china-mainland.aliyuncs.com/blogpost/202406_LVDS_9.png" alt="ISERDES时序"></p>
</li>
</ul>
<h3 id="关键模块Verilog实现"><a href="#关键模块Verilog实现" class="headerlink" title="关键模块Verilog实现"></a>关键模块Verilog实现</h3><p>在给出具体代码前，我们先按照上面给出的框架，将接收器分为数个子模块：</p>
<ul>
<li>顶层封装 <code>LVDS_recv</code><ul>
<li>时钟生成 <code>clkgen</code></li>
<li>帧信号采样器 <code>sipo12</code></li>
<li>数据串并转换器 <code>sipo12</code><ul>
<li>位偏移器 <code>bitSlip</code> </li>
<li>ISERDES等FPGA资源模块</li>
</ul>
</li>
<li>位偏移对齐控制器 <code>bitslip_ctrl</code></li>
<li>帧识别及写入控制器 <code>frame_ctrl</code></li>
<li>多组输入单输出FIFO缓存器（MISO） <code>FIFO_MISO</code></li>
<li>切片组合器 <code>gearbox</code></li>
</ul>
</li>
</ul>
<p>接下来，开始按照依赖关系，给出各个子模块的代码。最后给出顶层模块，和行为仿真的结果。这里上板的测试不方便给出，因为具体完整测试涉及到AFE5832的细节涉及保密条款。</p>
<h4 id="时钟生成器"><a href="#时钟生成器" class="headerlink" title="时钟生成器"></a>时钟生成器</h4><p>时钟恢复绝对是一切的基础，如果收不到时钟，那就是查硬件问题（顺序：查给AFE的$f_{adc}$正确输出 → 查AFE的时钟接收电路是否有正确的100Ω阻抗端接 → 查是否正确给了AFE初始化指令来让内部PLL正常工作 → 查供电 → 查FPGA的LVDS接收端是否有正确的100Ω阻抗端接）。</p>
<p>这里代码中没有什么复杂的操作，就是像框图里面由MMCM&#x2F;PLL跟踪数据时钟。有一个细节点就是锁相环的反馈要来自过时钟驱动器(<code>bufg</code>)的信号，这样可以去除驱动器的延迟。</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">module</span> clkgen #(</span><br><span class="line">      <span class="keyword">parameter</span> <span class="keyword">real</span>    CLKIN_PERIOD = <span class="number">2</span>        <span class="comment">// Clock period (ns) of input clock on clkin_p)</span></span><br><span class="line">    )</span><br><span class="line">    (</span><br><span class="line">    <span class="keyword">input</span> lvds_bclkin_p,    <span class="comment">// LVDS 源同步数据时钟 差分+</span></span><br><span class="line">    <span class="keyword">input</span> lvds_bclkin_n,    <span class="comment">// 差分-</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">input</span> rstn,             <span class="comment">// 异步复位</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">output</span> bps_div2,        <span class="comment">// DDR数据采样时钟，0相移</span></span><br><span class="line">    <span class="keyword">output</span> bps_div8,        <span class="comment">// 字节（切片）时钟</span></span><br><span class="line">    <span class="keyword">output</span> PLL_locked       <span class="comment">// PLL 锁定成功</span></span><br><span class="line">    );</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">wire</span> bclkin_p, bclkin_n;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 输入缓冲器</span></span><br><span class="line">    IBUFGDS_DIFF_OUT # (</span><br><span class="line">        <span class="variable">.DIFF_TERM</span>        (<span class="string">&quot;TRUE&quot;</span>)</span><br><span class="line">    )</span><br><span class="line">    iob_clk_in (</span><br><span class="line">        <span class="variable">.I</span>                (lvds_bclkin_p),</span><br><span class="line">        <span class="variable">.IB</span>               (lvds_bclkin_n),</span><br><span class="line">        <span class="variable">.O</span>                (bclkin_p),</span><br><span class="line">        <span class="variable">.OB</span>               (bclkin_n)</span><br><span class="line">    );</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 用来防止VCO频率不够</span></span><br><span class="line">    <span class="comment">// F_VCO 范围是 800MHz~1600MHz</span></span><br><span class="line">    <span class="comment">// 本设计跟踪的 dclk 范围 120M~480M</span></span><br><span class="line">    <span class="comment">// <span class="doctag">NOTE:</span> 将VCO的比例因子缩放到 VCO频率接近1200MHz</span></span><br><span class="line">    <span class="comment">// localparam VCO_MULTIPLIER = (CLKIN_PERIOD &gt;11.666) ? 2 : 1 ;</span></span><br><span class="line">    <span class="keyword">localparam</span> <span class="keyword">integer</span> VCO_MULTIPLIER = (CLKIN_PERIOD /(<span class="number">1</span>/<span class="number">1</span><span class="variable">.200</span>));</span><br><span class="line">    <span class="comment">/****</span></span><br><span class="line"><span class="comment">    ** FB通道和输入时钟同频，也就是 f_fb = f_bps/2</span></span><br><span class="line"><span class="comment">    ****/</span></span><br><span class="line">    MMCME3_BASE # (</span><br><span class="line">        <span class="variable">.CLKIN1_PERIOD</span>      (CLKIN_PERIOD),</span><br><span class="line">        <span class="variable">.BANDWIDTH</span>          (<span class="string">&quot;OPTIMIZED&quot;</span>),</span><br><span class="line">        </span><br><span class="line">        <span class="variable">.CLKFBOUT_MULT_F</span>    (VCO_MULTIPLIER),</span><br><span class="line">        <span class="variable">.CLKFBOUT_PHASE</span>     (<span class="number">180</span><span class="variable">.0</span>),</span><br><span class="line">        </span><br><span class="line">        <span class="variable">.DIVCLK_DIVIDE</span>      (<span class="number">1</span>),</span><br><span class="line">        <span class="variable">.REF_JITTER1</span>        (<span class="number">0</span><span class="variable">.100</span>)</span><br><span class="line">    )</span><br><span class="line">    rx_mmcm_adv_inst (</span><br><span class="line">        <span class="variable">.CLKFBOUT</span>       (bps_d2_pll),</span><br><span class="line">        <span class="variable">.CLKFBOUTB</span>      (),</span><br><span class="line">        <span class="variable">.CLKOUT0</span>        (),</span><br><span class="line">        <span class="variable">.CLKOUT0B</span>       (),</span><br><span class="line">        <span class="variable">.CLKOUT1</span>        (),</span><br><span class="line">        <span class="variable">.CLKOUT1B</span>       (),</span><br><span class="line">        <span class="variable">.CLKOUT2</span>        (),</span><br><span class="line">        <span class="variable">.CLKOUT2B</span>       (),</span><br><span class="line">        <span class="variable">.CLKOUT3</span>        (),</span><br><span class="line">        <span class="variable">.CLKOUT3B</span>       (),</span><br><span class="line">        <span class="variable">.CLKOUT4</span>        (),</span><br><span class="line">        <span class="variable">.CLKOUT5</span>        (),</span><br><span class="line">        <span class="variable">.CLKOUT6</span>        (),</span><br><span class="line">        <span class="variable">.LOCKED</span>         (PLL_locked),</span><br><span class="line">        <span class="variable">.CLKFBIN</span>        (bps_div2),</span><br><span class="line">        <span class="variable">.CLKIN1</span>         (bclkin_p),</span><br><span class="line">        <span class="variable">.PWRDWN</span>         (<span class="number">1&#x27;b0</span>),</span><br><span class="line">        <span class="variable">.RST</span>            (~rstn)</span><br><span class="line">    );</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 时钟打出去</span></span><br><span class="line">    BUFG  bg_2     (<span class="variable">.I</span>(bps_d2_pll),      <span class="variable">.O</span>(bps_div2)) ;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// * 供给iserdes的bclk_div时钟要和bclk时钟同源</span></span><br><span class="line">    BUFGCE_DIV #(</span><br><span class="line">        <span class="variable">.BUFGCE_DIVIDE</span>(<span class="number">4</span>)</span><br><span class="line">    )   bg_8(</span><br><span class="line">        <span class="variable">.I</span>(bps_d2_pll),</span><br><span class="line">        <span class="variable">.O</span>(bps_div8)</span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure>

<h4 id="帧-数据采样器"><a href="#帧-数据采样器" class="headerlink" title="帧&#x2F;数据采样器"></a>帧&#x2F;数据采样器</h4><p>和框图里面的设计一致，就是用原语来实现最基础的串并转换。这样比纯逻辑门做有更好的时序收敛性和更好的功耗。</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">module</span> sipo12(</span><br><span class="line">    <span class="keyword">input</span> lvds_din_p,   <span class="comment">// LVDS 数据线 差分+</span></span><br><span class="line">    <span class="keyword">input</span> lvds_din_n,   <span class="comment">// 差分-</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">input</span> rstn,     <span class="comment">// 异步复位</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">input</span> bps_div2, <span class="comment">// DDR时钟</span></span><br><span class="line">    <span class="keyword">input</span> bps_div8, <span class="comment">// 字节时钟</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">input</span> [<span class="number">2</span>:<span class="number">0</span>] Nslip,  <span class="comment">// 位滑动量</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">output</span> [<span class="number">7</span>:<span class="number">0</span>] pdout  <span class="comment">// 字节输出</span></span><br><span class="line">    );</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="keyword">wire</span> [<span class="number">7</span>:<span class="number">0</span>] des_out_curr;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 差分转单端</span></span><br><span class="line">    IBUFDS # (</span><br><span class="line">        <span class="variable">.DIFF_TERM</span>     (<span class="string">&quot;TRUE&quot;</span>)</span><br><span class="line">    )</span><br><span class="line">    iob_clk_in (</span><br><span class="line">        <span class="variable">.I</span>                (lvds_din_p),</span><br><span class="line">        <span class="variable">.IB</span>               (lvds_din_n),</span><br><span class="line">        <span class="variable">.O</span>                (datain_i)</span><br><span class="line">    );</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// DDR 串并转换 采样器</span></span><br><span class="line">    <span class="comment">// 1:8</span></span><br><span class="line">    ISERDESE3 #(</span><br><span class="line">        <span class="variable">.DATA_WIDTH</span>      (<span class="number">8</span>),   <span class="comment">// DDR, 8位</span></span><br><span class="line">        <span class="variable">.SIM_DEVICE</span>   	(<span class="string">&quot;ULTRASCALE_PLUS&quot;</span>),    <span class="comment">// FPGA器件</span></span><br><span class="line">        <span class="variable">.FIFO_ENABLE</span>     (<span class="string">&quot;FALSE&quot;</span>),     <span class="comment">// 不用FIFO</span></span><br><span class="line">        <span class="variable">.FIFO_SYNC_MODE</span>  (<span class="string">&quot;FALSE&quot;</span>) )</span><br><span class="line">    iserdes_m (</span><br><span class="line">        <span class="variable">.D</span>               (datain_i),    <span class="comment">// 串行数据线输入</span></span><br><span class="line">        <span class="variable">.RST</span>             (~rstn),       <span class="comment">// 复位</span></span><br><span class="line"></span><br><span class="line">        <span class="variable">.CLK</span>             ( bps_div2),   <span class="comment">// DDR采样时钟</span></span><br><span class="line">        <span class="variable">.CLK_B</span>           (~bps_div2),   <span class="comment">// TODO : 这个或门要优化成BUF</span></span><br><span class="line"></span><br><span class="line">        <span class="variable">.CLKDIV</span>          ( bps_div8),   <span class="comment">// 字节时钟</span></span><br><span class="line">        <span class="variable">.Q</span>               (des_out_curr), <span class="comment">// 字节数据</span></span><br><span class="line"></span><br><span class="line">        <span class="variable">.FIFO_RD_CLK</span>     (<span class="number">1&#x27;b0</span>),</span><br><span class="line">        <span class="variable">.FIFO_RD_EN</span>      (<span class="number">1&#x27;b0</span>),</span><br><span class="line">        <span class="variable">.FIFO_EMPTY</span>      (),</span><br><span class="line">        <span class="variable">.INTERNAL_DIVCLK</span> ()</span><br><span class="line">    );</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 位滑动器</span></span><br><span class="line">    bitSlip slip_inst(</span><br><span class="line">        <span class="variable">.Din</span>(des_out_curr),</span><br><span class="line">        <span class="variable">.clk</span>(bps_div8),</span><br><span class="line">        <span class="variable">.Nslip</span>(Nslip),</span><br><span class="line">        <span class="variable">.rstn</span>(rstn),</span><br><span class="line">        <span class="variable">.Dout</span>(pdout)</span><br><span class="line">    );</span><br><span class="line">    </span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure>

<h4 id="位偏移器"><a href="#位偏移器" class="headerlink" title="位偏移器"></a>位偏移器</h4><p>上面<code>sipo12</code>模块中，例化了一个位偏移器。这个模块的用途是，因为<code>ISERDES</code>被复位后开始抓数据的时间点，有非常大概率不是一个字节的第一个位，所以要对抓到的数据进行滑动匹配对齐。这里笔者使用的方案是比较笨但是好理解的，读者也可以升级为使用帧信号触发<code>ISERDES</code>复位逐渐逼近对齐的方案。偏移器的具体代码很简单，就是拼接：</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">module</span> bitSlip(</span><br><span class="line">    <span class="keyword">input</span> [<span class="number">7</span>:<span class="number">0</span>] Din,</span><br><span class="line">    <span class="keyword">input</span> clk,</span><br><span class="line">    <span class="keyword">input</span> [<span class="number">2</span>:<span class="number">0</span>] Nslip,</span><br><span class="line">    <span class="keyword">input</span> rstn,</span><br><span class="line">    <span class="keyword">output</span> [<span class="number">7</span>:<span class="number">0</span>] Dout</span><br><span class="line">    );</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// *输入的Din默认在外部为REG驱动，如果不是这里要加一级</span></span><br><span class="line">    <span class="comment">// *二级缓存REG</span></span><br><span class="line">    <span class="keyword">reg</span> [<span class="number">7</span>:<span class="number">0</span>] pre_din;</span><br><span class="line">    <span class="comment">// *输出REG</span></span><br><span class="line">    <span class="keyword">reg</span> [<span class="number">7</span>:<span class="number">0</span>] concat_dout;</span><br><span class="line">    <span class="keyword">assign</span> Dout = concat_dout;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">always</span> @(<span class="keyword">posedge</span> clk <span class="keyword">or</span> <span class="keyword">negedge</span> rstn) <span class="keyword">begin</span></span><br><span class="line">        <span class="keyword">if</span>(!rstn) <span class="keyword">begin</span></span><br><span class="line">            pre_din &lt;= <span class="number">0</span>;</span><br><span class="line">            concat_dout &lt;= <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">begin</span></span><br><span class="line">            <span class="comment">//* 缓冲REG，就是直接拿</span></span><br><span class="line">            pre_din &lt;= Din;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">//* 根据位移量，拼接数据</span></span><br><span class="line">            <span class="comment">//  note: 下面的拼法，代表发射机先发低位再发高位</span></span><br><span class="line">            <span class="keyword">case</span>(Nslip)</span><br><span class="line">                <span class="number">1</span>: concat_dout &lt;= &#123;Din[<span class="number">0</span>],pre_din[<span class="number">7</span>:<span class="number">1</span>]&#125;;</span><br><span class="line">                <span class="number">2</span>: concat_dout &lt;= &#123;Din[<span class="number">1</span>:<span class="number">0</span>],pre_din[<span class="number">7</span>:<span class="number">2</span>]&#125;;</span><br><span class="line">                <span class="number">3</span>: concat_dout &lt;= &#123;Din[<span class="number">2</span>:<span class="number">0</span>],pre_din[<span class="number">7</span>:<span class="number">3</span>]&#125;;</span><br><span class="line">                <span class="number">4</span>: concat_dout &lt;= &#123;Din[<span class="number">3</span>:<span class="number">0</span>],pre_din[<span class="number">7</span>:<span class="number">4</span>]&#125;;</span><br><span class="line">                <span class="number">5</span>: concat_dout &lt;= &#123;Din[<span class="number">4</span>:<span class="number">0</span>],pre_din[<span class="number">7</span>:<span class="number">5</span>]&#125;;</span><br><span class="line">                <span class="number">6</span>: concat_dout &lt;= &#123;Din[<span class="number">5</span>:<span class="number">0</span>],pre_din[<span class="number">7</span>:<span class="number">6</span>]&#125;;</span><br><span class="line">                <span class="number">7</span>: concat_dout &lt;= &#123;Din[<span class="number">6</span>:<span class="number">0</span>],pre_din[<span class="number">7</span>]&#125;;</span><br><span class="line">                <span class="keyword">default</span> : concat_dout &lt;= pre_din;</span><br><span class="line">            <span class="keyword">endcase</span></span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    </span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure>

<h4 id="位偏移对齐控制器"><a href="#位偏移对齐控制器" class="headerlink" title="位偏移对齐控制器"></a>位偏移对齐控制器</h4><p>识别位偏移的方法也很简单，就是把帧信号当作数据用<code>sipo</code>去抓，当正确对齐的情况下，抓出来的数据只可能是：<code>1111_1111</code>，<code>1111_0000</code>，<code>0000_0000</code>三种。基于这个思想，模块的代码为:</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">module</span> bitslip_ctrl(</span><br><span class="line">    <span class="keyword">input</span> clk,          </span><br><span class="line">    <span class="keyword">input</span> rstn,</span><br><span class="line"></span><br><span class="line">    <span class="keyword">input</span> [<span class="number">7</span>:<span class="number">0</span>] f8b_in,         <span class="comment">// 帧信号采样结果</span></span><br><span class="line">    <span class="keyword">output</span> <span class="keyword">reg</span> [<span class="number">2</span>:<span class="number">0</span>] Nslip,     <span class="comment">// 位滑动量</span></span><br><span class="line">    <span class="keyword">output</span> <span class="keyword">reg</span> [<span class="number">1</span>:<span class="number">0</span>] status,    <span class="comment">// 状态，见 BSLIP_[INIT/SLIPING/LOCK/FAIL]</span></span><br><span class="line">    <span class="keyword">output</span> <span class="keyword">reg</span> ERROR            <span class="comment">// 错误标志</span></span><br><span class="line">    );</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 状态机 4种工作状态</span></span><br><span class="line">    <span class="keyword">localparam</span> BSLIP_INIT = <span class="number">2&#x27;b00</span>;</span><br><span class="line">    <span class="keyword">localparam</span> BSLIP_SLIPING = <span class="number">2&#x27;b01</span>;</span><br><span class="line">    <span class="keyword">localparam</span> BSLIP_LOCK = <span class="number">2&#x27;b10</span>;</span><br><span class="line">    <span class="keyword">localparam</span> BSLIP_FAIL = <span class="number">2&#x27;b11</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">wire</span> patternFit;</span><br><span class="line">    <span class="keyword">wire</span> pattern_A,pattern_B,pattern_C;</span><br><span class="line">    <span class="keyword">assign</span> pattern_A = f8b_in == <span class="number">8&#x27;b1111_1111</span>;</span><br><span class="line">    <span class="keyword">assign</span> pattern_B = f8b_in == <span class="number">8&#x27;b0000_1111</span>;</span><br><span class="line">    <span class="keyword">assign</span> pattern_C = f8b_in == <span class="number">8&#x27;b0000_0000</span>;</span><br><span class="line">    <span class="keyword">assign</span> patternFit = pattern_A | pattern_B | pattern_C;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">reg</span> [<span class="number">1</span>:<span class="number">0</span>] pre_pattern; <span class="keyword">localparam</span> PT_A = <span class="number">0</span>, PT_B=<span class="number">1</span>, PT_C=<span class="number">2</span>, PT_NO=<span class="number">3</span>;</span><br><span class="line">    <span class="keyword">reg</span> [<span class="number">1</span>:<span class="number">0</span>] fit_cnt;</span><br><span class="line">    <span class="keyword">reg</span> [<span class="number">3</span>:<span class="number">0</span>] try_time;     <span class="comment">// 记录失败次数</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// pre_pattern 观测器实现</span></span><br><span class="line">    <span class="keyword">always</span>@(<span class="keyword">posedge</span> clk <span class="keyword">or</span> <span class="keyword">negedge</span> rstn) <span class="keyword">begin</span></span><br><span class="line">        <span class="keyword">if</span>(!rstn) <span class="keyword">begin</span></span><br><span class="line">            pre_pattern &lt;= PT_NO;</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">begin</span></span><br><span class="line">            <span class="keyword">if</span>(pattern_A)</span><br><span class="line">                pre_pattern &lt;= PT_A;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(pattern_B)</span><br><span class="line">                pre_pattern &lt;= PT_B;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(pattern_C)</span><br><span class="line">                pre_pattern &lt;= PT_C;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                pre_pattern &lt;= PT_NO;</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 滑动状态机</span></span><br><span class="line">    <span class="keyword">always</span>@(<span class="keyword">posedge</span> clk <span class="keyword">or</span> <span class="keyword">negedge</span> rstn) <span class="keyword">begin</span></span><br><span class="line">        <span class="keyword">if</span>(!rstn) <span class="keyword">begin</span></span><br><span class="line">            try_time &lt;= <span class="number">0</span>;</span><br><span class="line">            Nslip &lt;=<span class="number">0</span>;</span><br><span class="line">            status &lt;= BSLIP_INIT;</span><br><span class="line">            fit_cnt &lt;= <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">begin</span></span><br><span class="line">            <span class="keyword">case</span>(status)</span><br><span class="line">                </span><br><span class="line">                BSLIP_INIT : status &lt;= BSLIP_SLIPING;</span><br><span class="line">                </span><br><span class="line">                BSLIP_SLIPING : <span class="keyword">begin</span></span><br><span class="line">                    <span class="comment">// 只有匹配两次pattern且满足pattern的连续关系，才LOCK</span></span><br><span class="line">                    <span class="keyword">if</span>(patternFit) <span class="keyword">begin</span></span><br><span class="line">                        <span class="keyword">if</span>(fit_cnt == <span class="number">2</span>)</span><br><span class="line">                            status &lt;= BSLIP_LOCK;</span><br><span class="line">                        <span class="keyword">else</span> <span class="keyword">begin</span>  <span class="comment">// fit_cnt = 0 or 1</span></span><br><span class="line">                            <span class="keyword">case</span>(pre_pattern)</span><br><span class="line">                                PT_A: <span class="keyword">begin</span></span><br><span class="line">                                    <span class="keyword">if</span>(pattern_B)</span><br><span class="line">                                        fit_cnt &lt;= fit_cnt+<span class="number">1</span>;</span><br><span class="line">                                    <span class="keyword">else</span> <span class="keyword">begin</span></span><br><span class="line">                                        fit_cnt &lt;=<span class="number">0</span>;</span><br><span class="line">                                    <span class="keyword">end</span></span><br><span class="line">                                <span class="keyword">end</span></span><br><span class="line">                                </span><br><span class="line">                                PT_B: <span class="keyword">begin</span></span><br><span class="line">                                    <span class="keyword">if</span>(pattern_C)</span><br><span class="line">                                        fit_cnt &lt;= fit_cnt+<span class="number">1</span>;</span><br><span class="line">                                    <span class="keyword">else</span> <span class="keyword">begin</span></span><br><span class="line">                                        fit_cnt &lt;=<span class="number">0</span>;</span><br><span class="line">                                    <span class="keyword">end</span></span><br><span class="line">                                <span class="keyword">end</span></span><br><span class="line">                                </span><br><span class="line">                                PT_C: <span class="keyword">begin</span></span><br><span class="line">                                    <span class="keyword">if</span>(pattern_A)</span><br><span class="line">                                        fit_cnt &lt;= fit_cnt+<span class="number">1</span>;</span><br><span class="line">                                    <span class="keyword">else</span> <span class="keyword">begin</span></span><br><span class="line">                                        fit_cnt &lt;=<span class="number">0</span>;</span><br><span class="line">                                    <span class="keyword">end</span></span><br><span class="line">                                <span class="keyword">end</span></span><br><span class="line">                                </span><br><span class="line">                                <span class="keyword">default</span>: <span class="keyword">begin</span></span><br><span class="line">                                    fit_cnt &lt;= <span class="number">0</span>;</span><br><span class="line">                                <span class="keyword">end</span></span><br><span class="line">                            <span class="keyword">endcase</span></span><br><span class="line">                        <span class="keyword">end</span></span><br><span class="line">                    <span class="keyword">end</span></span><br><span class="line">                    <span class="keyword">else</span> <span class="keyword">if</span>(Nslip == <span class="number">7</span>)</span><br><span class="line">                        status &lt;= BSLIP_FAIL;</span><br><span class="line">                        <span class="keyword">else</span></span><br><span class="line">                        Nslip &lt;= Nslip+<span class="number">1</span>;</span><br><span class="line"><span class="comment">//                        status &lt;= BSLIP_INIT;</span></span><br><span class="line">                <span class="keyword">end</span></span><br><span class="line">                </span><br><span class="line">                BSLIP_LOCK : <span class="keyword">begin</span></span><br><span class="line">                    <span class="keyword">if</span>(patternFit)</span><br><span class="line">                        status &lt;= status;</span><br><span class="line">                    <span class="keyword">else</span></span><br><span class="line">                        status &lt;= BSLIP_FAIL;                 </span><br><span class="line">                <span class="keyword">end</span></span><br><span class="line">                </span><br><span class="line">                <span class="comment">// FAIL状态下，清空重新开始</span></span><br><span class="line">                <span class="keyword">default</span>: <span class="keyword">begin</span></span><br><span class="line">                    Nslip &lt;=<span class="number">0</span>;</span><br><span class="line">                    status &lt;= BSLIP_INIT;</span><br><span class="line">                    fit_cnt &lt;= <span class="number">0</span>;</span><br><span class="line">                    </span><br><span class="line">                    try_time &lt;= try_time +<span class="number">1</span>;</span><br><span class="line">                <span class="keyword">end</span></span><br><span class="line">                </span><br><span class="line">            <span class="keyword">endcase</span></span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 错误位判断</span></span><br><span class="line">    <span class="comment">// NOTE：清标志位只能通过子模块复位完成</span></span><br><span class="line">    <span class="keyword">always</span>@(<span class="keyword">posedge</span> clk <span class="keyword">or</span> <span class="keyword">negedge</span> rstn) <span class="keyword">begin</span></span><br><span class="line">        <span class="keyword">if</span>(!rstn) <span class="keyword">begin</span></span><br><span class="line">            ERROR &lt;=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">begin</span></span><br><span class="line">            <span class="keyword">if</span>(try_time == <span class="number">4&#x27;b1110</span>)</span><br><span class="line">                ERROR &lt;= <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> ERROR &lt;= ERROR;</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure>

<h4 id="切片组合器"><a href="#切片组合器" class="headerlink" title="切片组合器"></a>切片组合器</h4><p>我们使用的AFE采样精度是12位，也就是LVDS输出的一字有12位，但是我们用<code>sipo</code>抓的数据是8位，那么也就是我们需要对这些字节进行分切拼接。很明显，在帧信号的一个周期里面有2个采样数据（高电平一个、低电平一个），也就是24位，我们会抓到3个字节，其中，第一个字节和第二个字节的前半段拼起来是一个采样数据，第二个字节的后半段与第三个字节拼起来是第二个采样数据。因此，切片组合器实现为：</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">module</span> gearbox(</span><br><span class="line">    <span class="keyword">input</span> clk,</span><br><span class="line">    <span class="keyword">input</span> rstn,</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">input</span> [<span class="number">1</span>:<span class="number">0</span>] Nslice,     <span class="comment">// 切片编号</span></span><br><span class="line">    <span class="keyword">input</span> [<span class="number">7</span>:<span class="number">0</span>] pdin,       <span class="comment">// 字节数据</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">output</span> <span class="keyword">reg</span> [<span class="number">11</span>:<span class="number">0</span>] pdout <span class="comment">// 拼接结果</span></span><br><span class="line">    );</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">reg</span> [<span class="number">7</span>:<span class="number">0</span>] store_last_des;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 存储每一次的REG</span></span><br><span class="line">    <span class="keyword">always</span> @(<span class="keyword">posedge</span> clk <span class="keyword">or</span> <span class="keyword">negedge</span> rstn)</span><br><span class="line">    <span class="keyword">begin</span></span><br><span class="line">        <span class="keyword">if</span>(!rstn) <span class="keyword">begin</span></span><br><span class="line">            store_last_des &lt;= <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">        <span class="keyword">else</span>  <span class="keyword">begin</span></span><br><span class="line">            store_last_des &lt;= pdin;</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 根据状态机拼接输出</span></span><br><span class="line">    <span class="keyword">always</span> @(<span class="keyword">posedge</span> clk <span class="keyword">or</span> <span class="keyword">negedge</span> rstn)</span><br><span class="line">    <span class="keyword">begin</span></span><br><span class="line">        <span class="keyword">if</span>(! rstn)</span><br><span class="line">        <span class="keyword">begin</span></span><br><span class="line">            pdout &lt;= <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">begin</span></span><br><span class="line">            <span class="keyword">case</span>(Nslice)</span><br><span class="line">                <span class="number">2&#x27;h1</span>   : pdout &lt;= pdout;</span><br><span class="line">                <span class="number">2&#x27;h2</span>   : pdout &lt;= &#123;pdin[<span class="number">3</span>:<span class="number">0</span>],store_last_des[<span class="number">7</span>:<span class="number">0</span>]&#125;;</span><br><span class="line">                <span class="number">2&#x27;h3</span>   : pdout &lt;= &#123;pdin[<span class="number">7</span>:<span class="number">0</span>],store_last_des[<span class="number">7</span>:<span class="number">4</span>]&#125;;</span><br><span class="line">                <span class="keyword">default</span> : pdout &lt;= <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">endcase</span></span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    </span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure>

<h4 id="帧识别器及写入控制器"><a href="#帧识别器及写入控制器" class="headerlink" title="帧识别器及写入控制器"></a>帧识别器及写入控制器</h4><p>切片组合器的原理很简单，但前提是识别出切片的状态。前面说了帧信号是说明了采样数据的字划分的，并且我们也在位对齐环节对帧信号进行了采样，那么类似的采样的结果本质上就是切片编码。具体的，<code>1111_1111</code>就是第一个字节，<code>1111_0000</code>是第二个，<code>0000_0000</code>是第三个。但是要注意，3个字节切片，只有两个ADC采样结果，所以只有2&#x2F;3的时钟点需要存数据（写FIFO），因此本控制同时根据切片位置给出FIFO使能信号。</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">module</span> frame_ctrl(</span><br><span class="line">    <span class="keyword">input</span> [<span class="number">7</span>:<span class="number">0</span>] f8b_in,</span><br><span class="line">    <span class="keyword">input</span> init_seq_finish,</span><br><span class="line"></span><br><span class="line">    <span class="keyword">input</span> recvEn,           <span class="comment">// 全局接收使能，用于控制FIFO写入</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">output</span> <span class="keyword">reg</span> [<span class="number">1</span>:<span class="number">0</span>] Nslice,    <span class="comment">// 切片号</span></span><br><span class="line">    <span class="keyword">output</span> [<span class="number">1</span>:<span class="number">0</span>] FIFOen         <span class="comment">// FIFO写使能</span></span><br><span class="line">    );</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="keyword">reg</span> [<span class="number">1</span>:<span class="number">0</span>] fifo_en_by_slice;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">assign</span> FIFOen = recvEn ? fifo_en_by_slice : <span class="number">2&#x27;b00</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">always</span> @(*) <span class="keyword">begin</span></span><br><span class="line">        <span class="keyword">case</span>(f8b_in)</span><br><span class="line">            <span class="number">8&#x27;hff</span> : <span class="keyword">begin</span></span><br><span class="line">                Nslice &lt;= <span class="number">1</span>;</span><br><span class="line">                fifo_en_by_slice &lt;= <span class="number">2&#x27;b00</span>;</span><br><span class="line">            <span class="keyword">end</span></span><br><span class="line">            <span class="number">8&#x27;h0f</span> : <span class="keyword">begin</span></span><br><span class="line">                Nslice &lt;= <span class="number">2</span>;</span><br><span class="line">                fifo_en_by_slice &lt;= <span class="number">2&#x27;b10</span> &amp; &#123;<span class="number">2</span>&#123;init_seq_finish&#125;&#125;;</span><br><span class="line">            <span class="keyword">end</span></span><br><span class="line">            <span class="number">8&#x27;h00</span> : <span class="keyword">begin</span></span><br><span class="line">                Nslice &lt;= <span class="number">3</span>;</span><br><span class="line">                fifo_en_by_slice &lt;= <span class="number">2&#x27;b01</span> &amp; &#123;<span class="number">2</span>&#123;init_seq_finish&#125;&#125;;</span><br><span class="line">            <span class="keyword">end</span></span><br><span class="line">            <span class="keyword">default</span> : <span class="keyword">begin</span></span><br><span class="line">                Nslice &lt;= <span class="number">0</span>;</span><br><span class="line">                fifo_en_by_slice &lt;= <span class="number">2&#x27;b00</span>;</span><br><span class="line">            <span class="keyword">end</span></span><br><span class="line">        <span class="keyword">endcase</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    </span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure>

<h4 id="MISO缓冲器"><a href="#MISO缓冲器" class="headerlink" title="MISO缓冲器"></a>MISO缓冲器</h4><p>这个是为了方便读取数据到处理器的DDR设计的，因为使用的FPGA的PS与PL数据流交互是用的AXI，同时考虑到数据缓冲和多通道的需求，笔者设计了MISO这个缓冲器。具体思想是，首先例化了多个（通道数一致）跨时钟域的异步FIFO来缓冲数据，读写都是native端口，写入fifo的使能控制就是上面<code>frame_ctrl</code>来的；读fifo，则是设计了一个多通道轮询器来控制读使能，当用户连续读这个模块的端口时，实际在内部是轮流读各个通道数据FIFO。具体代码如下：</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">module</span> FIFO_MISO#(</span><br><span class="line">    <span class="keyword">parameter</span> N_CHANNEL = <span class="number">16</span>,   <span class="comment">// 需要缓冲数据的通道数</span></span><br><span class="line">    <span class="keyword">parameter</span> WID_WORD  = <span class="number">12</span>    <span class="comment">// 数据宽度</span></span><br><span class="line">    )(</span><br><span class="line">    <span class="keyword">input</span> rst,</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// FIFO 写入接口</span></span><br><span class="line">    <span class="keyword">input</span> wr_clk,</span><br><span class="line">    <span class="keyword">input</span> [ (N_CHANNEL*WID_WORD -<span class="number">1</span> ) :<span class="number">0</span> ] wr_dataBus,</span><br><span class="line">    <span class="keyword">input</span> [<span class="number">1</span>:<span class="number">0</span>] wr_enAB,</span><br><span class="line">    <span class="keyword">output</span> wrst_busy,</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 读接口，与fifo native标准一致</span></span><br><span class="line">    <span class="keyword">input</span> rd_clk,</span><br><span class="line">    <span class="keyword">output</span> [ (WID_WORD-<span class="number">1</span>) :<span class="number">0</span>] rd_data,</span><br><span class="line">    <span class="keyword">input</span> rd_en,</span><br><span class="line">    <span class="keyword">output</span> [<span class="number">5</span>:<span class="number">0</span>] rd_cnt,</span><br><span class="line">    <span class="keyword">output</span> rrst_busy,</span><br><span class="line">    <span class="keyword">output</span> rd_empty</span><br><span class="line">    );</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">wire</span> [( <span class="number">2</span>*N_CHANNEL -<span class="number">1</span> ):<span class="number">0</span>] fifo_rd_en_bus;</span><br><span class="line">    <span class="keyword">wire</span> [( <span class="number">2</span>*N_CHANNEL -<span class="number">1</span> ):<span class="number">0</span>] fifo_full_bus;</span><br><span class="line">    <span class="keyword">wire</span> [( <span class="number">2</span>*N_CHANNEL -<span class="number">1</span> ):<span class="number">0</span>] fifo_empty_bus;</span><br><span class="line">    <span class="keyword">wire</span> [<span class="number">5</span>:<span class="number">0</span>] fifo_cnt_bus [( <span class="number">2</span>*N_CHANNEL -<span class="number">1</span> ):<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">wire</span> [( <span class="number">2</span>*N_CHANNEL -<span class="number">1</span> ):<span class="number">0</span>] fifo_wrst_busy;</span><br><span class="line">    <span class="keyword">wire</span> [( <span class="number">2</span>*N_CHANNEL -<span class="number">1</span> ):<span class="number">0</span>] fifo_rrst_busy;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">wire</span> [ WID_WORD-<span class="number">1</span> :<span class="number">0</span> ] fifo_rdout_bus [ (<span class="number">2</span>*N_CHANNEL-<span class="number">1</span>) :<span class="number">0</span> ];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//* 例化FIFO，这里分AB是因为帧信号一周期有两个数据</span></span><br><span class="line">    <span class="keyword">generate</span></span><br><span class="line">    <span class="keyword">genvar</span> gi;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(gi = <span class="number">0</span>; gi &lt; N_CHANNEL; gi = gi+<span class="number">1</span>) <span class="keyword">begin</span>:fifo_gen</span><br><span class="line">    </span><br><span class="line">        fifo_generator_0 FIFO_channelA (</span><br><span class="line">            <span class="variable">.rst</span>(rst),                      <span class="comment">// input wire rst</span></span><br><span class="line">            <span class="variable">.wr_clk</span>(wr_clk),                <span class="comment">// input wire wr_clk</span></span><br><span class="line">            <span class="variable">.rd_clk</span>(rd_clk),                <span class="comment">// input wire rd_clk</span></span><br><span class="line">            <span class="variable">.din</span>(wr_dataBus[gi*<span class="number">12</span> +: <span class="number">12</span>]),                      <span class="comment">// input wire [11 : 0] din</span></span><br><span class="line">            <span class="variable">.wr_en</span>(wr_enAB[<span class="number">0</span>]),                  <span class="comment">// input wire wr_en</span></span><br><span class="line">            <span class="variable">.rd_en</span>(fifo_rd_en_bus[gi*<span class="number">2</span>]),                  <span class="comment">// input wire rd_en</span></span><br><span class="line">            <span class="variable">.dout</span>(fifo_rdout_bus[gi*<span class="number">2</span>]),                    <span class="comment">// output wire [11 : 0] dout</span></span><br><span class="line">            <span class="variable">.full</span>(fifo_full_bus[gi*<span class="number">2</span>]),                    <span class="comment">// output wire full</span></span><br><span class="line">            <span class="variable">.empty</span>(fifo_empty_bus[gi*<span class="number">2</span>]),                  <span class="comment">// output wire empty</span></span><br><span class="line">            <span class="variable">.rd_data_count</span>(fifo_cnt_bus[gi*<span class="number">2</span>]),  <span class="comment">// output wire [5 : 0] rd_data_count</span></span><br><span class="line">            <span class="variable">.wr_rst_busy</span>(fifo_wrst_busy[gi*<span class="number">2</span>]),      <span class="comment">// output wire wr_rst_busy</span></span><br><span class="line">            <span class="variable">.rd_rst_busy</span>(fifo_rrst_busy[gi*<span class="number">2</span>])      <span class="comment">// output wire rd_rst_busy</span></span><br><span class="line">        );</span><br><span class="line">        </span><br><span class="line">        fifo_generator_0 FIFO_channelB (</span><br><span class="line">            <span class="variable">.rst</span>(rst),                      <span class="comment">// input wire rst</span></span><br><span class="line">            <span class="variable">.wr_clk</span>(wr_clk),                <span class="comment">// input wire wr_clk</span></span><br><span class="line">            <span class="variable">.rd_clk</span>(rd_clk),                <span class="comment">// input wire rd_clk</span></span><br><span class="line">            <span class="variable">.din</span>(wr_dataBus[gi*<span class="number">12</span> +: <span class="number">12</span>]),  <span class="comment">// input wire [11 : 0] din</span></span><br><span class="line">            <span class="variable">.wr_en</span>(wr_enAB[<span class="number">1</span>]),         <span class="comment">// input wire wr_en</span></span><br><span class="line">            <span class="variable">.rd_en</span>(fifo_rd_en_bus[gi*<span class="number">2</span>+<span class="number">1</span>]),    <span class="comment">// input wire rd_en</span></span><br><span class="line">            <span class="variable">.dout</span>(fifo_rdout_bus[gi*<span class="number">2</span>+<span class="number">1</span>]),                    <span class="comment">// output wire [11 : 0] dout</span></span><br><span class="line">            <span class="variable">.full</span>(fifo_full_bus[gi*<span class="number">2</span>+<span class="number">1</span>]),             <span class="comment">// output wire full</span></span><br><span class="line">            <span class="variable">.empty</span>(fifo_empty_bus[gi*<span class="number">2</span>+<span class="number">1</span>]),         <span class="comment">// output wire empty</span></span><br><span class="line">            <span class="variable">.rd_data_count</span>(fifo_cnt_bus[gi*<span class="number">2</span>+<span class="number">1</span>]),  <span class="comment">// output wire [5 : 0] rd_data_count</span></span><br><span class="line">            <span class="variable">.wr_rst_busy</span>(fifo_wrst_busy[gi*<span class="number">2</span>+<span class="number">1</span>]),      <span class="comment">// output wire wr_rst_busy</span></span><br><span class="line">            <span class="variable">.rd_rst_busy</span>(fifo_rrst_busy[gi*<span class="number">2</span>+<span class="number">1</span>])      <span class="comment">// output wire rd_rst_busy</span></span><br><span class="line">        );</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">endgenerate</span></span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="keyword">assign</span> rd_cnt = fifo_cnt_bus[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">assign</span> wrst_busy = (fifo_wrst_busy != &#123;( <span class="number">2</span>*N_CHANNEL )&#123;<span class="number">1&#x27;b0</span>&#125;&#125; );</span><br><span class="line">    <span class="keyword">assign</span> rrst_busy = (fifo_rrst_busy != &#123;( <span class="number">2</span>*N_CHANNEL )&#123;<span class="number">1&#x27;b0</span>&#125;&#125; );</span><br><span class="line">    <span class="keyword">assign</span> rd_empty = fifo_empty_bus[( <span class="number">2</span>*N_CHANNEL -<span class="number">1</span> )];</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">reg</span> [ <span class="built_in">$clog2</span>(N_CHANNEL*<span class="number">2</span>)-<span class="number">1</span> : <span class="number">0</span> ] reading_idx;</span><br><span class="line">    <span class="keyword">reg</span> [( <span class="number">2</span>*N_CHANNEL -<span class="number">1</span> ):<span class="number">0</span>] fifo_rd_en_ctrl;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">generate</span> </span><br><span class="line">    <span class="keyword">for</span>(gi = <span class="number">0</span>; gi &lt; (<span class="number">2</span>*N_CHANNEL); gi = gi+<span class="number">1</span>) <span class="keyword">begin</span>: and_ren</span><br><span class="line">        <span class="keyword">assign</span> fifo_rd_en_bus[gi] = rd_en &amp; fifo_rd_en_ctrl[gi];</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">endgenerate</span></span><br><span class="line"><span class="comment">//    assign fifo_rd_en_bus = &#123;(2*N_CHANNEL)&#123;rd_en&#125;&#125; &amp; fifo_rd_en_ctrl;</span></span><br><span class="line">    <span class="keyword">always</span> @ (<span class="keyword">posedge</span> rd_clk <span class="keyword">or</span> <span class="keyword">posedge</span> rst) <span class="keyword">begin</span></span><br><span class="line">        <span class="keyword">if</span>(rst) <span class="keyword">begin</span></span><br><span class="line">            reading_idx &lt;= <span class="number">0</span>;</span><br><span class="line">            fifo_rd_en_ctrl &lt;= <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">begin</span></span><br><span class="line">            <span class="keyword">if</span>(rd_en)</span><br><span class="line">                fifo_rd_en_ctrl &lt;= &#123;fifo_rd_en_ctrl[N_CHANNEL*<span class="number">2</span>-<span class="number">2</span>:<span class="number">0</span>],fifo_rd_en_ctrl[N_CHANNEL*<span class="number">2</span>-<span class="number">1</span>]&#125;;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                fifo_rd_en_ctrl &lt;= fifo_rd_en_ctrl;</span><br><span class="line">                </span><br><span class="line">            <span class="keyword">if</span>(rd_en)</span><br><span class="line">                <span class="keyword">if</span>(reading_idx == (<span class="number">2</span>*N_CHANNEL-<span class="number">1</span>))</span><br><span class="line">                    reading_idx &lt;= <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    reading_idx &lt;= reading_idx +<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                reading_idx &lt;= reading_idx;</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">    <span class="keyword">assign</span> rd_data = fifo_rdout_bus[reading_idx];</span><br><span class="line">    </span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure>

<h4 id="顶层封装及例化构建采样器"><a href="#顶层封装及例化构建采样器" class="headerlink" title="顶层封装及例化构建采样器"></a>顶层封装及例化构建采样器</h4><p>这里对各个子模块进行拼装，还有对外部输入的控制信号，做跨时钟域的处理。</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">module</span> LVDS_recv #(</span><br><span class="line">    <span class="keyword">parameter</span> <span class="keyword">real</span> LVDS_DDR_CLK_MHZ = <span class="number">120</span></span><br><span class="line">) (</span><br><span class="line">    <span class="keyword">input</span> lvds_fclk_p,</span><br><span class="line">    <span class="keyword">input</span> lvds_fclk_n,</span><br><span class="line">    <span class="keyword">input</span> lvds_dclk_p,</span><br><span class="line">    <span class="keyword">input</span> lvds_dclk_n,</span><br><span class="line">    <span class="keyword">input</span> [<span class="number">15</span>:<span class="number">0</span>] lvds_data_p,</span><br><span class="line">    <span class="keyword">input</span> [<span class="number">15</span>:<span class="number">0</span>] lvds_data_n,</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">input</span> recvEn,   <span class="comment">// 接收使能</span></span><br><span class="line">    <span class="keyword">input</span> flush,    <span class="comment">// 清除FIFO中剩余数据</span></span><br><span class="line">    <span class="keyword">input</span> rstn,</span><br><span class="line"></span><br><span class="line">    <span class="keyword">output</span> <span class="keyword">reg</span> ready,</span><br><span class="line">    </span><br><span class="line">    (* X_INTERFACE_INFO = <span class="string">&quot;xilinx.com:interface:fifo_read:1.0 GroupRD RD_EN&quot;</span> *)</span><br><span class="line">    <span class="keyword">input</span> rd_en,</span><br><span class="line">    (* X_INTERFACE_INFO = <span class="string">&quot;xilinx.com:interface:fifo_read:1.0 GroupRD EMPTY&quot;</span> *)</span><br><span class="line">    <span class="keyword">output</span> empty,</span><br><span class="line">    (* X_INTERFACE_INFO = <span class="string">&quot;xilinx.com:interface:fifo_read:1.0 GroupRD ALMOST_EMPTY&quot;</span> *)</span><br><span class="line">    <span class="keyword">output</span> almost_empty,</span><br><span class="line">    (* X_INTERFACE_INFO = <span class="string">&quot;xilinx.com:interface:fifo_read:1.0 GroupRD RD_DATA&quot;</span> *)</span><br><span class="line">    <span class="keyword">output</span> [<span class="number">11</span>:<span class="number">0</span>]dout,</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">output</span> [<span class="number">5</span>:<span class="number">0</span>] valid_cnt,</span><br><span class="line">    <span class="keyword">input</span> rd_clk</span><br><span class="line">    );</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">wire</span> bps_div2, bps_div8;</span><br><span class="line">    <span class="keyword">wire</span> PLL_locked;</span><br><span class="line">    <span class="keyword">wire</span> init_seq_finish;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//* 最重要的，不依赖任何子模块的：时钟恢复</span></span><br><span class="line">    clkgen #(</span><br><span class="line">        <span class="variable">.CLKIN_PERIOD</span>((<span class="number">1</span>/LVDS_DDR_CLK_MHZ)*<span class="number">1000</span>)        <span class="comment">// Clock period (ns) of input clock on clkin_p)</span></span><br><span class="line">    ) clkgen_inst(</span><br><span class="line">        <span class="variable">.lvds_bclkin_p</span>(lvds_dclk_p),</span><br><span class="line">        <span class="variable">.lvds_bclkin_n</span>(lvds_dclk_n),</span><br><span class="line">        <span class="variable">.rstn</span>(rstn),</span><br><span class="line">        </span><br><span class="line">        <span class="variable">.bps_div2</span>(bps_div2),</span><br><span class="line">        <span class="variable">.bps_div8</span>(bps_div8),</span><br><span class="line">        <span class="variable">.PLL_locked</span>(PLL_locked)</span><br><span class="line">    );</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">wire</span> [<span class="number">2</span>:<span class="number">0</span>] Nslip;</span><br><span class="line">    <span class="keyword">wire</span> [<span class="number">1</span>:<span class="number">0</span>] frame_slice_control_gearbox;</span><br><span class="line">    <span class="keyword">wire</span> [<span class="number">1</span>:<span class="number">0</span>] fifo_write_en;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//* 帧采样模块</span></span><br><span class="line">    <span class="keyword">wire</span> [<span class="number">7</span>:<span class="number">0</span>] frame_samp_signal;</span><br><span class="line">    sipo12 frame_samp_inst(</span><br><span class="line">        <span class="variable">.lvds_din_p</span>(lvds_fclk_p),</span><br><span class="line">        <span class="variable">.lvds_din_n</span>(lvds_fclk_n),</span><br><span class="line">        </span><br><span class="line">        <span class="variable">.rstn</span>(rstn),</span><br><span class="line">        </span><br><span class="line">        <span class="variable">.bps_div2</span>(bps_div2),</span><br><span class="line">        <span class="variable">.bps_div8</span>(bps_div8),</span><br><span class="line">        </span><br><span class="line">        <span class="variable">.Nslip</span>(Nslip),</span><br><span class="line">        </span><br><span class="line">        <span class="variable">.pdout</span>(frame_samp_signal)</span><br><span class="line">    );</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//* 切片拼接测试-------------------------------------</span></span><br><span class="line">    <span class="comment">// WARN!!!: 仅用于调试，使用时关闭！</span></span><br><span class="line">    <span class="keyword">wire</span> [<span class="number">11</span>:<span class="number">0</span>] test_gearbox_out;</span><br><span class="line">    gearbox gb_test_inst(</span><br><span class="line">            <span class="variable">.clk</span>(bps_div8),</span><br><span class="line">            <span class="variable">.rstn</span>(rstn),</span><br><span class="line">            </span><br><span class="line">            <span class="variable">.Nslice</span>(frame_slice_control_gearbox),</span><br><span class="line">            <span class="variable">.pdin</span>(frame_samp_signal),</span><br><span class="line">            </span><br><span class="line">            <span class="variable">.pdout</span>(test_gearbox_out)</span><br><span class="line">        );</span><br><span class="line">    <span class="comment">//* -------------------------------------------------</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 跨时钟域处理，从ui_clk 到 bps_div8</span></span><br><span class="line">    <span class="keyword">reg</span> recv_en_buf, recv_en_buf_async; <span class="comment">// 跨时钟域处理</span></span><br><span class="line">    <span class="keyword">always</span> @(<span class="keyword">posedge</span> bps_div8) <span class="keyword">begin</span></span><br><span class="line">        recv_en_buf_async &lt;= recvEn;</span><br><span class="line">        recv_en_buf &lt;= recv_en_buf_async;</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// * 例化切片组合控制器 和 FIFO写切片控制器</span></span><br><span class="line">    frame_ctrl slice_concat_write_ctrl_inst(</span><br><span class="line">        <span class="variable">.f8b_in</span>(frame_samp_signal),</span><br><span class="line">        <span class="variable">.Nslice</span>(frame_slice_control_gearbox),</span><br><span class="line">        </span><br><span class="line">        <span class="variable">.recvEn</span>(recv_en_buf),</span><br><span class="line">        </span><br><span class="line">        <span class="variable">.init_seq_finish</span>(init_seq_finish),</span><br><span class="line">        <span class="variable">.FIFOen</span>(fifo_write_en)</span><br><span class="line">    );</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//* 帧对齐（划位控制）模块</span></span><br><span class="line">    <span class="comment">// tip: INIT(0), sliping(1), locked(2), error(3)</span></span><br><span class="line">    <span class="keyword">wire</span> [<span class="number">1</span>:<span class="number">0</span>] slip_ctrl_status;</span><br><span class="line">    bitslip_ctrl slip_inst(</span><br><span class="line">        <span class="variable">.clk</span>(bps_div8),</span><br><span class="line">        <span class="variable">.rstn</span>(rstn),</span><br><span class="line">        <span class="variable">.f8b_in</span>(frame_samp_signal),</span><br><span class="line">        <span class="variable">.Nslip</span>(Nslip),</span><br><span class="line">        <span class="variable">.status</span>(slip_ctrl_status)</span><br><span class="line">    );</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//* 例化data Lane采集通道</span></span><br><span class="line">    <span class="keyword">wire</span> [<span class="number">7</span>:<span class="number">0</span>] dlane_des_curr[<span class="number">15</span>:<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">wire</span> [(<span class="number">12</span>*<span class="number">16</span>-<span class="number">1</span>):<span class="number">0</span>] word_get_from_lane_bus;</span><br><span class="line">    <span class="keyword">wire</span> [<span class="number">11</span>:<span class="number">0</span>] word_get_from_lane[<span class="number">15</span>:<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">generate</span></span><br><span class="line">    <span class="keyword">genvar</span> gi;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(gi = <span class="number">0</span>; gi &lt; <span class="number">16</span>; gi = gi+<span class="number">1</span>) <span class="keyword">begin</span>: data_sipo_inst</span><br><span class="line">        <span class="keyword">assign</span> word_get_from_lane_bus[gi*<span class="number">12</span> +: <span class="number">12</span>] = word_get_from_lane[gi];</span><br><span class="line">        </span><br><span class="line">        sipo12 dsipo_inst(</span><br><span class="line">            <span class="variable">.lvds_din_p</span>(lvds_data_p[gi]),</span><br><span class="line">            <span class="variable">.lvds_din_n</span>(lvds_data_n[gi]),</span><br><span class="line">            </span><br><span class="line">            <span class="variable">.rstn</span>(rstn),</span><br><span class="line">            </span><br><span class="line">            <span class="variable">.bps_div2</span>(bps_div2),</span><br><span class="line">            <span class="variable">.bps_div8</span>(bps_div8),</span><br><span class="line">            </span><br><span class="line">            <span class="variable">.Nslip</span>(Nslip),</span><br><span class="line">            </span><br><span class="line">            <span class="variable">.pdout</span>(dlane_des_curr[gi])</span><br><span class="line">        );</span><br><span class="line">        </span><br><span class="line">        gearbox gb_inst(</span><br><span class="line">            <span class="variable">.clk</span>(bps_div8),</span><br><span class="line">            <span class="variable">.rstn</span>(rstn),</span><br><span class="line">            </span><br><span class="line">            <span class="variable">.Nslice</span>(frame_slice_control_gearbox),</span><br><span class="line">            <span class="variable">.pdin</span>(dlane_des_curr[gi]),</span><br><span class="line">            </span><br><span class="line">            <span class="variable">.pdout</span>(word_get_from_lane[gi])</span><br><span class="line">        );</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">endgenerate</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//* 多通道输入单通道输出FIFO模块例化</span></span><br><span class="line">    <span class="keyword">wire</span> fifo_wrst_busy,fifo_rrst_busy,fifo_empty;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">assign</span> empty = fifo_empty;</span><br><span class="line"><span class="comment">//    output almost_empty,</span></span><br><span class="line">    <span class="keyword">wire</span> rst_fifo;</span><br><span class="line">    </span><br><span class="line">    FIFO_MISO misoFIFO_inst(</span><br><span class="line">        <span class="variable">.rst</span>(rst_fifo),</span><br><span class="line">        </span><br><span class="line">        <span class="variable">.wr_clk</span>(bps_div8),</span><br><span class="line">        <span class="variable">.wr_dataBus</span>(word_get_from_lane_bus),</span><br><span class="line">        <span class="variable">.wr_enAB</span>(fifo_write_en),</span><br><span class="line">        <span class="variable">.wrst_busy</span>(fifo_wrst_busy),</span><br><span class="line">        </span><br><span class="line">        <span class="variable">.rd_clk</span>(rd_clk),</span><br><span class="line">        <span class="variable">.rd_data</span>(dout),</span><br><span class="line">        <span class="variable">.rd_en</span>(rd_en),</span><br><span class="line">        <span class="variable">.rd_cnt</span>(valid_cnt),</span><br><span class="line">        <span class="variable">.rrst_busy</span>(fifo_rrst_busy),</span><br><span class="line">        <span class="variable">.rd_empty</span>(fifo_empty)</span><br><span class="line">    );</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//* 复位管理安全模块</span></span><br><span class="line">    </span><br><span class="line">    lvds_rstCtrl safe_rst_inst(</span><br><span class="line">        <span class="variable">.PLL_locked</span>(PLL_locked),</span><br><span class="line">        <span class="variable">.rst_in</span>(~rstn),</span><br><span class="line">        <span class="variable">.ui_clk</span>(rd_clk),</span><br><span class="line">        </span><br><span class="line">        <span class="variable">.flush</span>(flush),</span><br><span class="line">        </span><br><span class="line">        <span class="variable">.fifo_wrst_busy</span>(fifo_wrst_busy),</span><br><span class="line">        <span class="variable">.fifo_rrst_busy</span>(fifo_rrst_busy),</span><br><span class="line">        <span class="variable">.rst_o_FIFO</span>(rst_fifo),</span><br><span class="line"><span class="comment">//    .rst_o_SIPO,</span></span><br><span class="line"><span class="comment">//    .rst_o_gearBox</span></span><br><span class="line">        <span class="variable">.OK</span>(init_seq_finish)</span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    <span class="keyword">always</span> @(<span class="keyword">posedge</span> rd_clk) <span class="keyword">begin</span></span><br><span class="line">        <span class="keyword">if</span> (~rstn) <span class="keyword">begin</span></span><br><span class="line">            ready &lt;= <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            ready &lt;= init_seq_finish;</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    </span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure>

<h4 id="仿真验证"><a href="#仿真验证" class="headerlink" title="仿真验证"></a>仿真验证</h4><p>先直接上仿真结果，再对着图给出仿真的思路和代码。</p>
<p><img src="https://blog-img-goryj.oss-rg-china-mainland.aliyuncs.com/blogpost/202406_LVDS_10.png" alt="行为仿真结果"></p>
<p>首先，我们仿真这个LVDS接收器，肯定是要先生成LVDS信号，以及随机的复位完成时间，来考察接收器锁定数据和帧切片的能力。下代码为数据生成器，笔者可以根据自己的应用大胆地更换数据生成器中的各个参数进行测试：</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">module</span> paternData_gen(</span><br><span class="line">    <span class="keyword">output</span> fclk_p,</span><br><span class="line">    <span class="keyword">output</span> fclk_n,</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">output</span> dclk_p,</span><br><span class="line">    <span class="keyword">output</span> dclk_n,</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">output</span> [<span class="number">15</span>:<span class="number">0</span>] dLane_p,</span><br><span class="line">    <span class="keyword">output</span> [<span class="number">15</span>:<span class="number">0</span>] dLane_n,</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">output</span> [<span class="number">15</span>:<span class="number">0</span>] dLane,</span><br><span class="line">    <span class="keyword">output</span> <span class="keyword">reg</span> RST</span><br><span class="line">    );</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="keyword">reg</span> BPS_CLK_960M;</span><br><span class="line">    <span class="keyword">reg</span> BPS_CLK_DDR_480M;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="comment">/*  时钟生成  */</span></span><br><span class="line">    <span class="keyword">parameter</span> <span class="keyword">real</span> PERIOD = <span class="number">1</span>/<span class="number">0</span><span class="variable">.96</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">always</span> <span class="keyword">begin</span></span><br><span class="line">        BPS_CLK_960M = <span class="number">1&#x27;b0</span>;</span><br><span class="line">        <span class="variable">#(PERIOD/2)</span> BPS_CLK_960M = <span class="number">1&#x27;b1</span>;</span><br><span class="line">        <span class="variable">#(PERIOD/2)</span>;</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">always</span> @ (<span class="keyword">posedge</span> BPS_CLK_960M)</span><br><span class="line">    <span class="keyword">begin</span></span><br><span class="line">        <span class="keyword">if</span>(RST)</span><br><span class="line">            BPS_CLK_DDR_480M &lt;= <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            BPS_CLK_DDR_480M &lt;= ~BPS_CLK_DDR_480M;</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">				</span><br><span class="line">	OBUFDS #(</span><br><span class="line">        <span class="variable">.IOSTANDARD</span>(<span class="string">&quot;LVDS&quot;</span>), <span class="comment">// 指定I/O标准为LVDS</span></span><br><span class="line">        <span class="variable">.DIFF_TERM</span>(<span class="string">&quot;TRUE&quot;</span>)  <span class="comment">// 启用差分终端</span></span><br><span class="line">    ) obufds_inst (</span><br><span class="line">        <span class="variable">.I</span>(BPS_CLK_DDR_480M),       <span class="comment">// 单端输入</span></span><br><span class="line">        <span class="variable">.O</span>(dclk_p),       <span class="comment">// 差分正端输出</span></span><br><span class="line">        <span class="variable">.OB</span>(dclk_n)       <span class="comment">// 差分负端输出</span></span><br><span class="line">    );		</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="comment">/*  生成测试数据  */</span></span><br><span class="line">    <span class="keyword">reg</span> [<span class="number">3</span>:<span class="number">0</span>] ser_num;</span><br><span class="line">    <span class="keyword">reg</span> [<span class="number">11</span>:<span class="number">0</span>] testData;</span><br><span class="line">    <span class="keyword">always</span>@(<span class="keyword">negedge</span> BPS_CLK_960M)</span><br><span class="line">    <span class="keyword">begin</span></span><br><span class="line">        <span class="keyword">if</span>(RST)</span><br><span class="line">            testData &lt;= <span class="number">12&#x27;b0000_0000_0000</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">begin</span></span><br><span class="line">            <span class="keyword">if</span>(ser_num == <span class="number">11</span>)</span><br><span class="line">                testData &lt;= testData + <span class="number">12&#x27;b000_0001_0000</span>;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                testData &lt;= testData;</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">/*  输出数据  */</span></span><br><span class="line">    <span class="keyword">reg</span> [<span class="number">2</span>:<span class="number">0</span>] frame_status;</span><br><span class="line">    <span class="keyword">localparam</span> [<span class="number">2</span>:<span class="number">0</span>] FRAME_READY = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">localparam</span> [<span class="number">2</span>:<span class="number">0</span>] FRAME_CA = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">localparam</span> [<span class="number">2</span>:<span class="number">0</span>] FRAME_CB = <span class="number">2</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 帧状态机</span></span><br><span class="line">    <span class="keyword">always</span> @ (<span class="keyword">negedge</span> BPS_CLK_960M)</span><br><span class="line">    <span class="keyword">begin</span></span><br><span class="line">        <span class="keyword">if</span>(RST)</span><br><span class="line">        <span class="keyword">begin</span></span><br><span class="line">            frame_status &lt;= FRAME_READY;</span><br><span class="line">            ser_num &lt;= <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">begin</span></span><br><span class="line">            <span class="keyword">if</span>(ser_num == <span class="number">11</span>)</span><br><span class="line">                ser_num &lt;= <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="keyword">if</span>( (frame_status == FRAME_CA) || (frame_status == FRAME_CB))</span><br><span class="line">                    ser_num &lt;= ser_num +<span class="number">1</span>;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    ser_num &lt;= ser_num;</span><br><span class="line">                </span><br><span class="line">        </span><br><span class="line">            <span class="keyword">case</span>(frame_status)</span><br><span class="line">                FRAME_READY :  frame_status &lt;= FRAME_CA;</span><br><span class="line">                FRAME_CA    :  <span class="keyword">begin</span></span><br><span class="line">                    <span class="keyword">if</span>(ser_num == <span class="number">11</span>)</span><br><span class="line">                        frame_status &lt;= FRAME_CB;</span><br><span class="line">                <span class="keyword">end</span></span><br><span class="line">                FRAME_CB    :  <span class="keyword">begin</span></span><br><span class="line">                    <span class="keyword">if</span>(ser_num == <span class="number">11</span>)</span><br><span class="line">                        frame_status &lt;= FRAME_CA;</span><br><span class="line">                <span class="keyword">end</span></span><br><span class="line">                <span class="keyword">default</span>     :  frame_status &lt;= FRAME_CA;</span><br><span class="line">            <span class="keyword">endcase</span></span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">wire</span> [<span class="number">11</span>:<span class="number">0</span>] testDataBus[<span class="number">15</span>:<span class="number">0</span>];</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">generate</span></span><br><span class="line">        <span class="keyword">genvar</span> ci;  </span><br><span class="line">        <span class="keyword">for</span>(ci = <span class="number">0</span>; ci &lt;<span class="number">16</span>; ci = ci+<span class="number">1</span>) <span class="keyword">begin</span>: gen_output_channel</span><br><span class="line">            <span class="keyword">assign</span> testDataBus[ci] = testData + ci;</span><br><span class="line">            <span class="keyword">assign</span> dLane[ci] = testDataBus[ci][ser_num];</span><br><span class="line">            		</span><br><span class="line">            OBUFDS #(</span><br><span class="line">                <span class="variable">.IOSTANDARD</span>(<span class="string">&quot;LVDS&quot;</span>), <span class="comment">// 指定I/O标准为LVDS</span></span><br><span class="line">                <span class="variable">.DIFF_TERM</span>(<span class="string">&quot;TRUE&quot;</span>)  <span class="comment">// 启用差分终端</span></span><br><span class="line">            ) dobufds_inst (</span><br><span class="line">                <span class="variable">.I</span>(dLane[ci]),       <span class="comment">// 单端输入</span></span><br><span class="line">                <span class="variable">.O</span>(dLane_p[ci]),       <span class="comment">// 差分正端输出</span></span><br><span class="line">                <span class="variable">.OB</span>(dLane_n[ci])       <span class="comment">// 差分负端输出</span></span><br><span class="line">            );	</span><br><span class="line">            </span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">endgenerate</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">wire</span> frame_clk_s;</span><br><span class="line">    <span class="keyword">assign</span> frame_clk_s = (frame_status == FRAME_CA);</span><br><span class="line">    </span><br><span class="line">    OBUFDS #(</span><br><span class="line">        <span class="variable">.IOSTANDARD</span>(<span class="string">&quot;LVDS&quot;</span>), <span class="comment">// 指定I/O标准为LVDS</span></span><br><span class="line">        <span class="variable">.DIFF_TERM</span>(<span class="string">&quot;TRUE&quot;</span>)  <span class="comment">// 启用差分终端</span></span><br><span class="line">    ) fobufds_inst (</span><br><span class="line">        <span class="variable">.I</span>(frame_clk_s),       <span class="comment">// 单端输入</span></span><br><span class="line">        <span class="variable">.O</span>(fclk_p),       <span class="comment">// 差分正端输出</span></span><br><span class="line">        <span class="variable">.OB</span>(fclk_n)       <span class="comment">// 差分负端输出</span></span><br><span class="line">    );	</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/*  初始化  */</span></span><br><span class="line">    <span class="keyword">initial</span> <span class="keyword">begin</span></span><br><span class="line">        RST = <span class="number">1</span>;</span><br><span class="line">        # (PERIOD*<span class="number">5</span>) RST = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    </span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure>

<p>生成器生成数据，被LVDS接收器收到后，我们还要对接收器进行读取操作，来验证数据是否正确。因此构建一个读取器，代码为：</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">module</span> fifo_reader(</span><br><span class="line">    <span class="keyword">output</span> <span class="keyword">reg</span> recvEn,</span><br><span class="line">    <span class="keyword">output</span> <span class="keyword">reg</span> flush,</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">input</span> empty,</span><br><span class="line">    <span class="keyword">input</span> almost_empty,</span><br><span class="line">    <span class="keyword">input</span> [<span class="number">5</span>:<span class="number">0</span>] cnt,</span><br><span class="line">    <span class="keyword">input</span> [<span class="number">11</span>:<span class="number">0</span>] rd_data,</span><br><span class="line">    <span class="keyword">output</span> <span class="keyword">reg</span> rd_en,</span><br><span class="line">    <span class="keyword">output</span> <span class="keyword">reg</span> rd_clk</span><br><span class="line">    );</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/*  时钟生成 600MHz */</span></span><br><span class="line">    <span class="keyword">parameter</span> <span class="keyword">real</span> PERIOD = <span class="number">1</span>/<span class="number">0</span><span class="variable">.600</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">initial</span> <span class="keyword">begin</span></span><br><span class="line">        recvEn = <span class="number">0</span>;</span><br><span class="line">        flush = <span class="number">0</span>;</span><br><span class="line">        <span class="variable">#(PERIOD * 300)</span> recvEn = <span class="number">1</span>;</span><br><span class="line">        <span class="variable">#(PERIOD * 120)</span> recvEn = <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="variable">#(PERIOD * 10)</span> flush = <span class="number">1</span>;</span><br><span class="line">        <span class="variable">#(PERIOD *1)</span> flush = <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="variable">#(PERIOD *10)</span> recvEn = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">always</span> <span class="keyword">begin</span></span><br><span class="line">        rd_clk = <span class="number">1&#x27;b0</span>;</span><br><span class="line">        <span class="variable">#(PERIOD/2)</span> rd_clk = <span class="number">1&#x27;b1</span>;</span><br><span class="line">        <span class="variable">#(PERIOD/2)</span>;</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">always</span>@(<span class="keyword">posedge</span> rd_clk) <span class="keyword">begin</span></span><br><span class="line">        <span class="keyword">if</span>(!empty &amp;&amp; cnt&gt;<span class="number">2</span>)</span><br><span class="line">            rd_en &lt;= <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            rd_en &lt;= <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    </span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure>

<p>最后，我们做一个testbench把上面几个测试的前后端拼接起来：</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="meta">`<span class="keyword">timescale</span> 1ns / 1ps</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">module</span> testBench_fifo_read(</span><br><span class="line">    </span><br><span class="line">    );</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">wire</span> fclk_p,fclk_n,dclk_p,dclk_n;</span><br><span class="line">    <span class="keyword">wire</span> [<span class="number">15</span>:<span class="number">0</span>] dLane_p;</span><br><span class="line">    <span class="keyword">wire</span> [<span class="number">15</span>:<span class="number">0</span>] dLane_n;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">wire</span> rst;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">wire</span> empty, almost_empty,fifo_ren,fifo_rclk;</span><br><span class="line">    <span class="keyword">wire</span> [<span class="number">11</span>:<span class="number">0</span>] fifo_rd_data;</span><br><span class="line">    <span class="keyword">wire</span> [<span class="number">5</span>:<span class="number">0</span>] fifo_valid_cnt;</span><br><span class="line">    </span><br><span class="line">    paternData_gen data_generator(</span><br><span class="line">        <span class="variable">.fclk_p</span>(fclk_p),</span><br><span class="line">        <span class="variable">.fclk_n</span>(fclk_n),</span><br><span class="line">        </span><br><span class="line">        <span class="variable">.dclk_p</span>(dclk_p),</span><br><span class="line">        <span class="variable">.dclk_n</span>(dclk_n),</span><br><span class="line">        </span><br><span class="line">        <span class="variable">.dLane_p</span>(dLane_p),</span><br><span class="line">        <span class="variable">.dLane_n</span>(dLane_n),</span><br><span class="line">        </span><br><span class="line">        <span class="variable">.RST</span>(rst)</span><br><span class="line">    );</span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    LVDS_recv #(</span><br><span class="line">        <span class="variable">.LVDS_DDR_CLK_MHZ</span>(<span class="number">480</span>)</span><br><span class="line">    ) recv_inst(</span><br><span class="line">        <span class="variable">.lvds_fclk_p</span>(fclk_p),</span><br><span class="line">        <span class="variable">.lvds_fclk_n</span>(fclk_n),</span><br><span class="line">        <span class="variable">.lvds_dclk_p</span>(dclk_p),</span><br><span class="line">        <span class="variable">.lvds_dclk_n</span>(dclk_n),</span><br><span class="line">        <span class="variable">.lvds_data_p</span>(dLane_p),</span><br><span class="line">        <span class="variable">.lvds_data_n</span>(dLane_n),</span><br><span class="line">        </span><br><span class="line">        <span class="variable">.rstn</span>(~rst),</span><br><span class="line">        <span class="variable">.recvEn</span>(recvEn),</span><br><span class="line">        <span class="variable">.flush</span>(flush),</span><br><span class="line">    </span><br><span class="line">        <span class="variable">.rd_en</span>(fifo_ren),</span><br><span class="line">        <span class="variable">.empty</span>(empty),</span><br><span class="line">        <span class="variable">.almost_empty</span>(almost_empty),</span><br><span class="line">        <span class="variable">.valid_cnt</span>(fifo_valid_cnt),</span><br><span class="line">        <span class="variable">.dout</span>(fifo_rd_data),</span><br><span class="line">        <span class="variable">.rd_clk</span>(fifo_rclk)</span><br><span class="line">    );</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    fifo_reader  reader_inst(</span><br><span class="line">        <span class="variable">.recvEn</span>(recvEn),</span><br><span class="line">        <span class="variable">.flush</span>(flush),</span><br><span class="line">        </span><br><span class="line">        <span class="variable">.empty</span>(empty),</span><br><span class="line">        <span class="variable">.almost_empty</span>(almost_empty),</span><br><span class="line">        <span class="variable">.cnt</span>(fifo_valid_cnt),</span><br><span class="line">        <span class="variable">.rd_data</span>(fifo_rd_data),</span><br><span class="line">        <span class="variable">.rd_en</span>(fifo_ren),</span><br><span class="line">        <span class="variable">.rd_clk</span>(fifo_rclk)</span><br><span class="line">    );</span><br><span class="line">    </span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure>

<h2 id="AMD官方推荐的LVDS接收器完整架构"><a href="#AMD官方推荐的LVDS接收器完整架构" class="headerlink" title="AMD官方推荐的LVDS接收器完整架构"></a>AMD官方推荐的LVDS接收器完整架构</h2><blockquote>
<p>见AMD的官方文档：《XAPP1315 LVDS Source Synchronous 7:1 Serialization and Deserialization Using Clock Multiplication》.</p>
</blockquote>
<p>上面我们实现的接收器，直接基于DCLK恢复时钟采样，没有考虑skew的问题，是因为在板级设计时笔者严格缩短了AFE5832至FPGA之间的Layout距离，并且Lane对内做了差分等长，对间同样做了等长。在工程应用中，很可能是控不到这么好的条件，比如子模块板间跨过多个连接座和线缆或者Layout工程师无法压榨。这就要在每一对Lane进入FPGA后使用IDELAY调节skew，以及CLK进去后由PLL和校准算法匹配数据采样点。</p>
<p>下图是AMD给的DEMO推荐架构，加了<code>IDELAYCTRL</code>和<code>IDELAY</code>。实际使用时，让LVDS前级出固定测试数据<code>1010_1010...</code>，然后FPGA工程师往延迟值小和延迟值大两个方向依次对每个通道测试延迟边缘值（也就是会看到采出来的数据开始一直跳），然后将中值配置为永久延迟设置值。</p>
<p><img src="https://blog-img-goryj.oss-rg-china-mainland.aliyuncs.com/blogpost/202406_LVDS_11.png" alt="LVDS完整接收器架构"></p>
<h2 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h2><ul>
<li>XAPP1208 Bitslip in Logic</li>
<li>XAPP1315 LVDS Source Synchronous 7:1 Serialization and Deserialization Using Clock Multiplication</li>
<li>XAPP524 Serial LVDS High-Speed ADC Interface</li>
<li>XAPP1017 LVDS Source Synchronous DDR Deserialization (up to 1,600 Mb&#x2F;s)</li>
<li>UG572 UltraScale Architecture Clocking Resources</li>
<li>UG571 UltraScale Architecture SelectIO Resources</li>
</ul>
]]></content>
      <categories>
        <category>FPGA&amp;计算加速&amp;芯片设计</category>
      </categories>
      <tags>
        <tag>FPGA</tag>
        <tag>LVDS</tag>
      </tags>
  </entry>
  <entry>
    <title>Python开发图片压缩小工具</title>
    <url>/2021/02/14/photoCompressionPython/</url>
    <content><![CDATA[<blockquote>
<p>这个小工具非常简单，就是把图像以最小的损失量压缩。网络上的工具要么是要钱，要么一张张图片导入导出实在是太麻烦啦🙃笔者博客的图片全部都托管在gitee上，有1MB的大小限制，所以就搞个小工具来批量压缩图片啦大家有需要自取</p>
</blockquote>
<h2 id="图像存储原理"><a href="#图像存储原理" class="headerlink" title="图像存储原理"></a>图像存储原理</h2><p>首先区别两个知识点：图片格式&amp;颜色模式</p>
<ul>
<li>图片格式：文件存储的时候文件编码的数据结构，比如常见的.jpg和.png是两种图片存储格式</li>
<li>颜色模式：指的是颜色表示的方式，常见的有RGB和YUV</li>
</ul>
<p>一般来说，咱们常见的.jpg图片，使用手机拍的、电脑截图的如果没有经过特殊转码处理，一般采用RGB颜色模式。</p>
<p>一张数字图片，可以理解为一个二维数组，每一个元素就是常说的像素点，每个像素点就是一个颜色方块，当这些方块非常非常小时，就组成了一张图片（微分思想）。我们知道使用三基色可以合成所有颜色，这也就是RGB颜色模式的由来。由红R+绿G+蓝B三个颜色分量合成一个像素点，目前一般采样RGB24也就是一个分量一个字节（1Byte&#x3D;8bits），那么一个像素点就是3Bytes（24bits）。计算一张采用RGB24颜色模式的分辨率A×B的图片大小：</p>
<p>$$<br>\text{Size} &#x3D; A\cdot B \cdot 3Bytes<br>$$</p>
<blockquote>
<p>当然还有更节省存储的RGB8和RGB16，也有色板精度更高的RGB32</p>
</blockquote>
<h2 id="图像压缩实例代码"><a href="#图像压缩实例代码" class="headerlink" title="图像压缩实例代码"></a>图像压缩实例代码</h2><span id="more"></span>

<p>所以根据图像存储原理及得到的图像存储大小计算方法就可以编写我们的最优抽样压缩代码了。在开始操作前，要先意识到有两个坑：</p>
<ul>
<li>由分辨率计算得到的图像大小会和实际图片大小偏差很大，这个常常是因为图片带有其他辅助信息。比如笔者用手机拍照得到的图片，放在电脑上用属性查看器是可以看到拍摄时间、拍摄地点经纬度以及相机光圈等属性</li>
<li>存储时，电脑磁盘不是以字节为最小单位！操作过格式化磁盘的小伙伴应该都知道有一个可调选项是单元分配大小，笔者电脑为了提高速度选择了较大的单元大小（4096B），那么存储2000B大小文件时还是会使用4096B的空间噢！就像一个很大的柜子里放了一颗小戒指！</li>
</ul>
<blockquote>
<p>所以这个图像压缩算法也可以用来剥离平时照片里的敏感信息噢！</p>
</blockquote>
<p>那么接下来让我们开始设计代码吧😜</p>
<ol>
<li>找出目标图片：笔者这边做了后缀筛选</li>
<li>文件大小超标检查</li>
<li>若超标，首先剥离图像的拍摄辅助信息</li>
<li>若还超标，则做抽样压缩</li>
</ol>
<p>根据图像存储大小公式，我们可计算压缩比为：</p>
<p>$$<br>C &#x3D; \sqrt{\frac{Size}{MaxSize}}<br>$$</p>
<p>然后计算抽样后的像素数组长宽数量：</p>
<p>$$<br>W’ &#x3D; \frac{W}{C},H’&#x3D;\frac{H}{C}<br>$$</p>
<p>最后，进行图像抽样并保存就可以啦！图像抽样时，可以选择不同的滤波方式，滤波的用途比如在长度为5的数组抽样4个则理论上最佳抽样点位置不在数据点上，那么就可以滤波得到逻辑抽样点。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">Created on Wed Feb 10 18:46:53 2021</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">@author: 江榕煜</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">@brief: 图片压缩工具</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;辅助模块导入&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">from</span> PIL <span class="keyword">import</span> Image</span><br><span class="line"><span class="keyword">import</span> glob</span><br><span class="line"><span class="keyword">import</span> math</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">在你使用之前</span></span><br><span class="line"><span class="string">请务必适配该部分</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line">DIR = <span class="string">r&#x27;./&#x27;</span>; <span class="comment"># 要进行压缩处理的图像路径，现在默认文件运行路径</span></span><br><span class="line">saveDIR = <span class="string">r&#x27;./&#x27;</span> <span class="comment"># 压缩处理后图像存储路径</span></span><br><span class="line">MaxSizeOfImg = <span class="number">1e6</span>; <span class="comment">#限制压缩后最大图像大小，单位：Byte</span></span><br><span class="line"></span><br><span class="line">condense_JPG = <span class="literal">True</span>;    <span class="comment"># 若压缩 .jpg 后缀文件请使能该项。若不用，请设置为False</span></span><br><span class="line">condense_PNG = <span class="literal">True</span>;    <span class="comment"># 若压缩 .png 后缀文件请使能该项</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;图片文件匹配&#x27;&#x27;&#x27;</span></span><br><span class="line">fileList_JPG = glob.glob(<span class="string">&#x27;%s%s%s&#x27;</span> % (DIR, <span class="string">&#x27;*&#x27;</span>, <span class="string">&#x27;.jpg&#x27;</span>));</span><br><span class="line">fileList_PNG = glob.glob(<span class="string">&#x27;%s%s%s&#x27;</span> % (DIR, <span class="string">&#x27;*&#x27;</span>, <span class="string">&#x27;.png&#x27;</span>));</span><br><span class="line"></span><br><span class="line">fileList = [];</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> condense_JPG:</span><br><span class="line">    fileList += fileList_JPG;</span><br><span class="line"><span class="keyword">if</span> condense_PNG:</span><br><span class="line">    fileList += fileList_PNG;</span><br><span class="line"></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;存储路径存在性检查&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="keyword">if</span> <span class="keyword">not</span> os.path.exists(saveDIR):</span><br><span class="line">    os.mkdir(saveDIR);</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;创建文件夹:&quot;</span>+saveDIR)</span><br><span class="line"></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;开始压缩处理&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="keyword">for</span> imgFile <span class="keyword">in</span> fileList:</span><br><span class="line">    <span class="string">&#x27;&#x27;&#x27;文件大小检查&#x27;&#x27;&#x27;</span></span><br><span class="line">    thisFileSize = os.path.getsize(imgFile)</span><br><span class="line">    <span class="keyword">if</span> thisFileSize &lt; MaxSizeOfImg:   <span class="comment"># 符合要求跳过不处理</span></span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        </span><br><span class="line">        <span class="string">&#x27;&#x27;&#x27;用户提示&#x27;&#x27;&#x27;</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;----------&quot;</span>)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;压缩图像&quot;</span>+<span class="built_in">str</span>(imgFile)+<span class="string">&quot;（大小：&quot;</span>+<span class="built_in">str</span>(thisFileSize)+<span class="string">&quot;Bytes）&quot;</span>)</span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">        <span class="string">&#x27;&#x27;&#x27;计算存储路径&#x27;&#x27;&#x27;</span></span><br><span class="line">        nameRout = imgFile.split(<span class="string">&#x27;/&#x27;</span>)</span><br><span class="line">        nameRout = nameRout[-<span class="number">1</span>].split(<span class="string">&#x27;\\&#x27;</span>)</span><br><span class="line">        nameRout = nameRout[-<span class="number">1</span>]</span><br><span class="line">        saveDir = <span class="string">&#x27;%s%s&#x27;</span> % (saveDIR,nameRout)</span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">        <span class="string">&#x27;&#x27;&#x27;先剥离图像原本的辅助数据&#x27;&#x27;&#x27;</span></span><br><span class="line">        thisImg = Image.<span class="built_in">open</span>(imgFile) <span class="comment"># 打开图像源文件</span></span><br><span class="line">        cleanImg = thisImg.resize(thisImg.size)</span><br><span class="line">        thisImg.close()</span><br><span class="line">        cleanImg.save(saveDir)</span><br><span class="line">        cleanImg.close()</span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">        <span class="string">&#x27;&#x27;&#x27;图像抽样压缩&#x27;&#x27;&#x27;</span></span><br><span class="line">        thisFileSize = os.path.getsize(saveDir)</span><br><span class="line">        <span class="keyword">if</span> thisFileSize &lt; MaxSizeOfImg:</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            condenseCoe = math.sqrt( <span class="built_in">float</span>(thisFileSize)/MaxSizeOfImg);  <span class="comment"># 计算压缩比</span></span><br><span class="line">            </span><br><span class="line">            thisImg = Image.<span class="built_in">open</span>(saveDir) <span class="comment"># 打开源图像文件</span></span><br><span class="line">            </span><br><span class="line">            thisImgHeight = thisImg.height; <span class="comment"># 获取图像像素个数</span></span><br><span class="line">            thisImgWidth = thisImg.width;</span><br><span class="line">            </span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;压缩比为：&quot;</span>+<span class="built_in">str</span>(condenseCoe))</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;源图像分辨率：%d，%d&quot;</span> % (thisImgWidth,thisImgHeight))</span><br><span class="line">            </span><br><span class="line">            thisImgHeight = <span class="built_in">int</span>(<span class="built_in">float</span>(thisImgHeight)/condenseCoe);  <span class="comment"># 计算压缩后像素个数</span></span><br><span class="line">            thisImgWidth = <span class="built_in">int</span>(<span class="built_in">float</span>(thisImgWidth)/condenseCoe);</span><br><span class="line">            </span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;压缩图像分辨率：%d，%d&quot;</span> % (thisImgWidth,thisImgHeight))</span><br><span class="line">            </span><br><span class="line">            <span class="string">&#x27;&#x27;&#x27;像素抽样&#x27;&#x27;&#x27;</span></span><br><span class="line">            condenseImg = thisImg.resize((thisImgWidth,thisImgHeight)</span><br><span class="line">                                          <span class="comment">#,Image.ANTIALIAS   # 滤波方法</span></span><br><span class="line">                                          )</span><br><span class="line">            </span><br><span class="line">            <span class="string">&#x27;&#x27;&#x27;存储压缩后的图像&#x27;&#x27;&#x27;</span></span><br><span class="line">            thisImg.close()</span><br><span class="line">            condenseImg.save(saveDir)</span><br><span class="line">            condenseImg.close()</span><br><span class="line">            </span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>AI &amp; CV &amp; OS</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>数字图像处理</tag>
      </tags>
  </entry>
  <entry>
    <title>速通材料力学</title>
    <url>/2023/09/01/mechanicofmaterial/</url>
    <content><![CDATA[<h2 id="基本概念和术语"><a href="#基本概念和术语" class="headerlink" title="基本概念和术语"></a>基本概念和术语</h2><ul>
<li><p>构件&#x2F;零件：组成机械与结构的各组成部分</p>
</li>
<li><p>保证构件正常或安全工作的条件：</p>
<ul>
<li>强度（在外力作用下抵抗塑性变形和断裂的能力），对应应力，单位Pa<br>对应的实验测试方法<ul>
<li>拉伸实验——拉伸强度、屈服强度、抗拉强度（tensile strength）</li>
<li>三点弯曲实验——抗弯强度（Shear strength）</li>
<li>压缩实验——抗压强度（compression strength）</li>
</ul>
</li>
<li>刚度（Stiffness）（受力时抵抗弹性变形的能力），对应应变</li>
<li>硬度（金属材料抵抗更硬的物体压入其内的能力），属于表面特征。硬度定义方式包括：<ul>
<li>刻划硬度（Scratch hardness）</li>
<li>压入硬度（Indentation hardness）</li>
<li>回弹硬度（Rebound hardness，动态硬度dynamic hardness，或绝对硬度）</li>
</ul>
</li>
</ul>
</li>
<li><p>连续性假设：材料无空隙地充满整个构件</p>
</li>
<li><p>均匀性假设：构件内每一处的力学性能都相同</p>
</li>
<li><p>各向同性假设：构件某一处材料沿各个方向的力学性能相同。</p>
</li>
<li><p>各向异性假设：各个方向的力学性能不同。</p>
</li>
<li><p>内力：构件内部各<strong>部分之间</strong>因受力后变形而引起的相互作用力</p>
<ul>
<li>应力的积分，可以算内力</li>
<li>内力的分类：轴力，剪力，扭矩，弯矩</li>
<li>单位：N</li>
</ul>
</li>
<li><p>应力：单个点的力特征，单位是Pa</p>
</li>
<li><p>变形：构件尺寸与形状的变化称为变形。</p>
<ul>
<li>弹性变形：外力解除后能消失的变形</li>
<li>塑性变形&#x2F;残余变形：外力解除后不能消失的变形<blockquote>
<p>在材料力学里，所有材料都会变形</p>
</blockquote>
</li>
</ul>
</li>
<li><p><strong>应变</strong>：变形的程度，无量纲</p>
<ul>
<li>线应变<br>$$<br>\epsilon &#x3D; \Delta L &#x2F; L<br>$$</li>
<li>切应变</li>
</ul>
</li>
<li><p>材料的应力-应变曲线<br><img src="https://blog-img-goryj.oss-rg-china-mainland.aliyuncs.com/blogpost/20230902_MecOfMat_1.jpg" alt="低碳钢应变应力"></p>
<p>如上图是低碳钢拉伸时的应力应变曲线。可以分为四个阶段：</p>
<span id="more"></span>
<ul>
<li>弹性阶段。这里当应力小于<strong>比例极限</strong> $\sigma _p$ 时，应力应变服从胡可定律：$\sigma &#x3D; E \epsilon$，常系数$E$为材料的杨氏弹性模量。</li>
<li>屈服阶段</li>
<li>强化阶段</li>
<li>局部变形阶段</li>
</ul>
</li>
<li><p>塑性材料与脆性材料</p>
<ul>
<li>评价指标：断后生长率$\delta&#x3D;\Delta l &#x2F; l_0 \times 100%$</li>
<li>脆性材料：$\delta &lt; 5%$</li>
<li>塑性材料：$\delta &gt; 5%$</li>
<li>判断材料失效的方法：塑性材料发生塑性变形，脆性材料断了</li>
</ul>
</li>
<li><p>卸载定律：如果拉伸达到强化阶段，样品开始卸载，那么弹性部分将服从胡可定律恢复，而塑性变形的应变将保留。</p>
</li>
<li><p>冷作硬化：冷作的意思就是金属材料在<strong>结晶温度以下</strong>的低温环境，受加工产生大量塑性变形，使表层的晶粒拉长、晶格畸变，实现材料表面的硬度增加。</p>
</li>
<li><p>名义屈服极限$\sigma_{0.2}$：对于没明显屈服阶段的材料，工程上常以卸载后残余应变为0.2%的应力作为屈服强度</p>
</li>
<li><p>压缩与拉伸的关系：</p>
<ul>
<li>塑性材料的拉伸和压缩性能相同；</li>
<li>脆性材料压缩时的强度极限远高于拉伸的强度极限，抗压性远远抗拉性</li>
</ul>
</li>
<li><p>许用应力：构件工作时允许的最大应力值$[\sigma] &#x3D; \sigma_u&#x2F;n$</p>
<ul>
<li>n是安全因数</li>
<li>$\sigma_u$是极限应力：塑性材料取屈服极限$\sigma_s$或$\sigma_{0.2}$，脆性材料取强度极限$\sigma_b$或$\sigma_{bc}$</li>
</ul>
</li>
<li><p>泊松比$\mu&#x3D;-\epsilon’&#x2F;\epsilon$，表示材料横向的应变$\epsilon’$与轴向受拉压产生应变的比。这是材料的常数，对于各向同性材料，$0&lt;\mu&lt;0.5$</p>
</li>
<li><p>变形满足（线性时不变）叠加原理：几组载荷同时作用的总效果，等于各组载荷单独作用产生的效果的和。</p>
<blockquote>
<p>条件：材料是线弹性的，或者小变形</p>
</blockquote>
</li>
<li><p>应力集中：因杆件外形突然变化而引起的局部应力急剧增大的现象</p>
<ul>
<li>理论应力集中因数：$K&#x3D; \frac {理论应力集中因数\sigma_{max}}{ 截面平均应力\sigma }$</li>
</ul>
</li>
<li><p>圆轴扭转时横截面上的内力和应力，用扭矩$T$表示(方向以右手螺旋法则，沿截面外法线方向为正)</p>
</li>
<li><p>切应力互等定理：在两个相互垂直的面上，切应力必然成对出现，且数值相等，两者都垂直于两平面的交线，其方向为共同指向或共同背离该交线。<br><img src="https://blog-img-goryj.oss-rg-china-mainland.aliyuncs.com/blogpost/20230902_MecOfMat_2.jpg" alt="切应力互等定理"></p>
</li>
<li><p>剪切胡克定律：$\tau &#x3D; G\cdot y$</p>
<ul>
<li>G为剪切弹性模量，且和其他常数有：$G&#x3D;\frac E {2(1+\mu)}$</li>
</ul>
</li>
<li><p>圆轴扭转时横截面上的应力：$\tau_\rho &#x3D; \frac {T\rho}{I_p}$</p>
<ul>
<li>$\rho$是距轴线的径向距离</li>
<li>$I_p&#x3D;\int_A\rho^2dA$</li>
<li>横截面上任一点切应力大小与该点到圆心的距离成正比</li>
<li>且最大应力点在圆截面边缘上：$\tau_{max}&#x3D;T&#x2F;W_t$，其中$W_t&#x3D;I_p&#x2F;R$为抗扭截面系数</li>
</ul>
</li>
<li><p>圆轴扭转变形与刚度条件</p>
<ul>
<li>扭转角$\phi &#x3D; \frac {Tl}{抗扭刚度GI_p}$</li>
<li>单位长度扭转角$\phi’&#x3D;\phi&#x2F;l&#x3D;T&#x2F;{GI_p}$</li>
<li>许用单位长度扭转角$[\phi’]&gt; \phi’$</li>
</ul>
</li>
<li><p>弯曲内力：杆件弯曲时有两个内力，剪力FS，弯矩M</p>
<ul>
<li>在集中力作用的地方，剪力图有突变，外力F向下，剪力图向下变，变化值&#x3D;F值；弯矩图有折角</li>
<li>在集中力偶作用的地方，剪力图无突变；弯矩图有突变，Me顺时针转，弯矩图向上变（朝增加方向），变化值&#x3D;Me值</li>
<li>在均布力作用的梁段上，剪力图为斜直线；弯矩图为二次抛物线，均布力向下作用，抛物线开口向下。抛物线的极值在剪力为零的截面上</li>
</ul>
</li>
<li><p>弯曲应力</p>
<ul>
<li>中性层和中性轴的概念：梁内既不伸长也不缩短的一层纤维，此层纤维称<strong>中性层</strong>。中性层与横截面的交线称为中性轴。中性轴通过截面形心<br><img src="https://blog-img-goryj.oss-rg-china-mainland.aliyuncs.com/blogpost/20230902_MecOfMat_3.png" alt="中性层和中性轴"></li>
<li>横截面上弯曲正应力：横截面上弯曲正应力沿截面高度直线变化，与该点到中性轴的距离成正比，中性轴上为零<ul>
<li>正应力公式：$\sigma&#x3D;My&#x2F;I_z$</li>
<li>最大正应力发生在离中性轴最远的边缘</li>
</ul>
</li>
<li>矩形截面梁弯曲切应力$\tau&#x3D;\frac{F_sS_z}{I_zb}$。强度沿截面高度按抛物线分布，最大切应力在中性轴上</li>
</ul>
</li>
<li><p>弯曲变形</p>
<ul>
<li>梁的横截面形心沿竖直方向的位移w称为挠度</li>
<li>变形后的轴线称为挠曲线。梁横截面对其原来位置转过的角度θ称为转角。在工程问题中，梁的转角一般很小，挠曲线是一条非常平坦的曲线，所以$\theta\approx dw&#x2F;dx$<blockquote>
<p>对弯曲变形的计算略，毕竟笔者不专业搞材料，只是用来计算机仿真</p>
</blockquote>
</li>
</ul>
</li>
<li><p>强度理论：关于“构件发生强度失效起因”的假说，利用简单应力状态实验结果，建立复杂应力状态强度条件</p>
<ul>
<li>两类破坏形式：脆性断裂和塑性屈服，因此有两类强度理论，断裂强度理论和屈服强度理论</li>
<li>四种常用强度理论：<ul>
<li>最大拉应力理论（第一强度理论）</li>
<li>最大伸长线应变理论（第二强度理论）</li>
<li>最大切应力理论（第三强度理论）</li>
<li>畸变能密度理论（第四强度理论）</li>
</ul>
</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>硬件&amp;物理</category>
      </categories>
      <tags>
        <tag>材料</tag>
      </tags>
  </entry>
  <entry>
    <title>电子罗盘的理论分析与实际应用（AK09915）</title>
    <url>/2022/08/28/ElectricCompass-FromZeroToInf/</url>
    <content><![CDATA[<blockquote>
<p>前言：继上篇6轴IMU之后，本文将介绍电子罗盘的原理（数学模型）和以<code>AK09915</code>为目标的应用实例。</p>
</blockquote>
<h2 id="磁基础知识"><a href="#磁基础知识" class="headerlink" title="磁基础知识"></a>磁基础知识</h2><h3 id="磁的分类"><a href="#磁的分类" class="headerlink" title="磁的分类"></a>磁的分类</h3><ul>
<li>硬磁：也就是永磁性材料。因为这种材料的矫顽力高&#x2F;磁滞回线面基大，所以在被<em>磁化后将很难退磁</em>。</li>
<li>软磁：普通的纯铁就是很好的例子，可以被磁铁吸住（纯铁被磁化），但是把磁铁拿掉后，很快将不表现出磁性（退磁）。这种材料的矫顽力小&#x2F;磁滞回线面基小，所以被<em>磁化后将快速退磁</em>；这种材料一般使用的目的就是<strong>增加磁导率</strong>，比如做成电感的磁芯可以加大电感量（$L&#x3D;\mu\cdot S_{磁芯} \cdot N^2&#x2F;l_{磁路}$）而又不带来大损耗。<br><img src="https://blog-img-goryj.oss-rg-china-mainland.aliyuncs.com/blogpost/20220828-electCompass-1.png" alt="硬磁与软磁"></li>
<li>地磁：地球产生的磁场，可以理解地球为永磁体，这里我们并不关注地球的磁性从何而来，只关心地磁场的模型（如下图）。NOTE：在地表测量地磁的磁感应强度范围约是0.4~0.6高斯，地磁场的大磁极轴与地球自转轴有一个约11.5°夹角。<br><img src="https://blog-img-goryj.oss-rg-china-mainland.aliyuncs.com/blogpost/20220828-electCompass-2.gif" alt="地磁场"></li>
</ul>
<h3 id="磁物理量"><a href="#磁物理量" class="headerlink" title="磁物理量"></a>磁物理量</h3><p>首先是常见的磁感应强度$B$，磁场强度$H$，表征磁介质磁性能力的磁导率$\mu&#x3D;B&#x2F;H$。磁感应强度$B$的单位有国际标准单位“特斯拉”(<strong>T</strong>)，也有常听到的“高斯”(<strong>G</strong>)，这两个量的关系为：$1T&#x3D;10^4G$。</p>
<span id="more"></span>

<p>可以认为磁场强度是与激励源直接挂钩的量，比如电流$I$与磁强$H$的关系为：</p>
<p>$$<br>H &#x3D; \frac {NI}{l_{磁路}}<br>$$</p>
<p>采用霍尔效应测量磁场（转换为霍尔电压$U$）时，属于直接测量磁感应强度$B$物理量：</p>
<p>$$<br>U&#x3D;\frac {I}{neh} B &#x3D; KB<br>$$</p>
<p>显然，霍尔器件理论上是具有良好线性测量特性，测量灵敏度为$K$。</p>
<h2 id="地磁解算偏航角"><a href="#地磁解算偏航角" class="headerlink" title="地磁解算偏航角"></a>地磁解算偏航角</h2><p>在开始前，我们先声名一下，坐标系设计为如下图所示的“北-东-地”坐标系，这是因为我们要测量的磁感应强度$\vec B$显然是一个从南往北的向量。</p>
<p><img src="https://blog-img-goryj.oss-rg-china-mainland.aliyuncs.com/blogpost/20220828-electCompass-3.png" alt="北-东-地 坐标系"></p>
<p>在校准好磁力计后，可以合理的假设我们测量得到的$\vec B$是较干净的地磁向量，则如下图所示分解为水平分向量$\vec B_{north}$和$\vec B_{down}$，此时我们的机头朝向显然为这里的X轴方向即$\vec x$，所以要得到偏航角可以用向量点乘的方法求解：</p>
<p>$$<br>\alpha &#x3D; \arcsin(\frac{\vec B_{north} \cdot \vec x}{\vert \vec B_{north} \vert \cdot \vert \vec x \vert})<br>$$</p>
<p><img src="https://blog-img-goryj.oss-rg-china-mainland.aliyuncs.com/blogpost/20220828-electCompass-4.jpg" alt="偏航解算"></p>
<p>所以接下来才是本文的重点——校准磁力计。</p>
<h2 id="电子罗盘校准"><a href="#电子罗盘校准" class="headerlink" title="电子罗盘校准"></a>电子罗盘校准</h2><p>首先，建立带干扰的误差模型，上面提到过磁介材料有永磁材料、软磁材料，其中永磁材料相当于给测量结果加上一个偏置$H_1$，软磁材料相当于改变了测量结果与实际量的灵敏度（$S_m$）；除此之外，还有机械安装时的误差矩阵$S_c$（相当于旋转矩阵），制造时的刻度系数（灵敏度）误差矩阵$S_i$，轴间非正交误差矩阵$N$，零点偏移矩阵（$H_0$）。因此将测量结果$\hat B$与实际磁场$H$关系描述为：</p>
<p>$$<br>\hat B &#x3D; S_m S_c N S_i H+H_0+H_1<br>$$</p>
<p>方便进行数学处理，我们可以合理地假定上式中的各个影响量是静态的，因此可以将上式各项合并简化为：</p>
<p>$$<br>\hat B &#x3D; K^{-1}H+P<br>$$</p>
<p>所以我们的目标就是获得上式中的矩阵$K\in \mathbb R^{3\times3}$和偏置向量$P\in \mathbb R^3$，就可以校准测量向量$\hat B$为真实地磁向量$H$：</p>
<p>$$<br>H &#x3D; K(\hat B-P)<br>$$</p>
<p>接下来我们讨论的是<strong>椭圆校准法</strong>，之所以叫这个是因为测量的数据点云呈现空间椭圆分布并且最后我们拟合的目标函数也是空间椭圆函数。因此，首先要说说为什么要用到椭圆这个形式，观察上式，$\hat B&#x3D;[b_1,b_2,b_3]^T$的数据展示时相当于$[x,y,z]^T$坐标（实际看起来确实像椭圆），向量$P$就像是这堆数据点的中心（椭圆心），K就类似于这堆数据的空间范围（椭圆半径）。</p>
<p><img src="https://blog-img-goryj.oss-rg-china-mainland.aliyuncs.com/blogpost/20220828-electCompass-5.png" alt="椭球拟合"></p>
<p>考虑到地磁场在某一个地点的磁向量是固定的，不管磁力计再怎么旋转，测量得到的结果$\hat B$应该是表征出同样的地磁向量$H$。因为旋转不改变向量的模长，所以有：</p>
<p>$$<br>\vert H \vert^2 \equiv | H_{\alpha,\beta,\theta}\vert^2 &#x3D;<br>\big( K(\hat B - P) \big)^{T}\cdot K(\hat B-P)<br>\\<br>&#x3D;(\hat B^T-P^T)K^TK(\hat B-P)<br>\\<br>&#x3D; \hat B^T K^TK \hat B - \hat B^T K^TK P - P^T K^TK \hat B+ P^T K^TKP<br>$$</p>
<p>因为上式中，最后的形式里每一项都有$K^TK$，所以我们把这项用一个新的矩阵$A&#x3D;K^TK\in R^{3\times 3}$替代，向量长因为是恒定的，我们用常量$s&#x3D;\vert H \vert ^2$替代：</p>
<p>$$<br>s&#x3D;\hat B^T A \hat B - 2\hat B^T A P+ P^T AP,<br>\\<br>A &#x3D; \begin{bmatrix}<br>a_{11},a_{12},a_{13} \\<br>a_{12},a_{22},a_{23} \\<br>a_{13},a_{23},a_{33}<br>\end{bmatrix}<br>$$</p>
<blockquote>
<p>注意：上式中的$- 2\hat B^T A P$本来是$-\hat B^T A P-P^TA\hat B$，但因为$A$是<em>二次型矩阵</em>所以两个结果是一样的就合并了。</p>
</blockquote>
<p>把测量值用空间坐标表示$\hat B &#x3D; [x,y,z]^T$，带入上式拆开后（有兴趣你可以试一试）：</p>
<p>$$<br>ax^2+by^2+cz^2+dxy+exz+fyz+gx+hy+iz+l&#x3D;s<br>\\<br>a&#x3D;a_{11},b&#x3D;a_{22},c&#x3D;a_{33},<br>d&#x3D;a_{12}+a_{21},\cdots,<br>l&#x3D;P^TAP<br>$$</p>
<p>得到拟合形式后，我们就可以用最小二乘法等数学工具将采样数据点拿去推参数了。但是上式中的实数项要合并一下还有参数项要拆出一个系数2方便后面的关系转换：</p>
<p>$$<br>ax^2+by^2+cz^2+d2xy+e2xz+f2yz+g2x+h2y+i2z&#x3D;1<br>$$</p>
<p>将上式中要拟合的系数和样本数据分别用向量$V\in \mathbb R^{9\times 1}$和非方矩阵$D\in\mathbb R^{N\times 9}$来表示：</p>
<p>$$<br>DV&#x3D;1<br>\\<br>D&#x3D;\begin{bmatrix}<br>x_1^2 &amp; y_1^2 &amp; z_1^2 &amp; 2x_1y_1 &amp; 2x_1z_1 &amp; 2y_1z_1 &amp; 2x_1 &amp; 2y_1 &amp; 2z_1<br>\\<br>&amp;&amp;&amp;&amp; \vdots<br>\\<br>x_N^2 &amp; y_N^2 &amp; z_N^2 &amp; 2x_Ny_N &amp; 2x_Nz_N &amp; 2y_Nz_N &amp; 2x_N &amp; 2y_N &amp; 2z_N<br>\end{bmatrix}<br>\\<br>V&#x3D;\begin{bmatrix}<br>a &amp; b &amp; c &amp; d &amp; e &amp; f &amp; g &amp; h &amp; i<br>\end{bmatrix}^T<br>$$</p>
<p>接下来使用非方矩阵的伪逆来求解$V$的最小二乘拟合（见文末）：</p>
<p>$$<br>D^TDV&#x3D;D^T\cdot 1<br>\\<br>V&#x3D;(D^TD)^{-1}D^T \cdot 1<br>$$</p>
<blockquote>
<p>上面的“椭球拟合”图片，就是笔者使用AK09915的实际采样数据，用“非方矩阵伪逆法”拟合的参数效果。Matlab画图相关接口：scatter3、fimplicit3</p>
</blockquote>
<p>那么拟合得到的系数，如何对应到校准方程中的矩阵系数呢？首先是偏移量向量：</p>
<p>$$<br>O&#x3D;A_{3\times3}^{-1} V_{ghi}<br>\\<br>A_{3\times3}&#x3D;\begin{bmatrix}<br>a &amp; d &amp; e \\<br>d &amp; b &amp; f \\<br>e &amp; f &amp; c<br>\end{bmatrix} ,<br>V_{ghi}&#x3D;\begin{bmatrix}<br>g \\ h \\ i<br>\end{bmatrix}<br>$$</p>
<p>接着求椭圆旋转矩阵，先求一个中间辅助矩阵：</p>
<p>$$<br>B_{4\times4}&#x3D;T A_{4\times 4}T^T<br>\\<br>T &#x3D; \begin{bmatrix}<br>1 &amp;0 &amp;0 &amp;0 \\<br>0 &amp;1 &amp;0 &amp;0 \\<br>0 &amp;0 &amp;1 &amp;0 \\<br>Ox &amp; Oy &amp; Oz &amp; 1<br>\end{bmatrix},<br>A_{4\times 4}&#x3D;\begin{bmatrix}<br>a &amp; d &amp; e &amp; g \\<br>d &amp; b &amp; f &amp; h \\<br>e &amp; f &amp; c &amp; i \\<br>g &amp; h &amp; i &amp; -1<br>\end{bmatrix}<br>$$</p>
<p>然后把这个辅助矩阵$B_{4\times4}$进行分块来求解另一个辅助矩阵：</p>
<p>$$<br>B_{4\times4} &#x3D; \begin{bmatrix}<br>B_{3\times3-core} &amp; N_{3\times 1}<br>\\<br>M_{1\times3} &amp; b_{44}<br>\end{bmatrix}<br>\\<br>B_{3\times3}&#x3D;\frac{1}{-b_{44}} B_{3\times3-core}<br>$$</p>
<p>对$B_{3\times3}$求解出3个特征值$\lambda_i$和3个特征向量$v_i$。则可以用特征值构造轴增益（椭圆半径）：</p>
<p>$$<br>G&#x3D;[\frac{1}{\sqrt{\lambda_1}},\frac{1}{\sqrt{\lambda_2}},\frac{1}{\sqrt{\lambda_3}}]^T<br>$$</p>
<p>用特征向量构造旋转矩阵：</p>
<p>$$<br>R_{3\times3}&#x3D;\begin{bmatrix}<br>v_1 &amp; v_2 &amp; v_3<br>\end{bmatrix}<br>$$</p>
<p>最终，我们就可以对读取到的传感器采样数据$\hat B$进行校准了：</p>
<p>$$<br>\hat B_{withoutBias} &#x3D; \hat B + O<br>\\<br>\hat B_{invRot} &#x3D; R^{-1} \hat B_{withoutBias}<br>\\<br>\hat B_{pred} &#x3D; \hat B_{invRot} &#x2F; G<br>$$</p>
<p>上面三步依次为：去偏移量、反旋转、去增益。</p>
<h2 id="电子罗盘使用实战"><a href="#电子罗盘使用实战" class="headerlink" title="电子罗盘使用实战"></a>电子罗盘使用实战</h2><p>这一节主要有两个部分，分别是：</p>
<ol>
<li>AK09915底层驱动程序：分享了从驱动一颗电子罗盘芯片到获得采样数据的全流程代码；</li>
<li>椭球矫正算法：接着在该部分中，分享了对采样数据进行分析得出干扰补偿数据的算法实现，并给出了矫正效果对比图；</li>
<li>矫正电子罗盘并求解航向角：最后这个部分，将矫正算法用C实现部署到了实际嵌入式硬件上，并求解最终目标——航向角。</li>
</ol>
<h3 id="AK09915底层驱动程序"><a href="#AK09915底层驱动程序" class="headerlink" title="AK09915底层驱动程序"></a>AK09915底层驱动程序</h3><p><img src="https://blog-img-goryj.oss-rg-china-mainland.aliyuncs.com/blogpost/20220828-electCompass-6.png" alt="AK09915寄存器表"></p>
<p>上图是这个电子罗盘的寄存器表，可以看出这个器件可以<br>配置的寄存器起始就三个：CNTL1、CNTL2、CNTL3。配置完成后，读取HXL~HZH的采样数据寄存器就可以了。初始化代码如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * @brief  设置工作模式</span></span><br><span class="line"><span class="comment">  * @note   无</span></span><br><span class="line"><span class="comment">  * @param  targetMode: 要进入的工作模式</span></span><br><span class="line"><span class="comment">  * @retval None</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">AK09915_setOpMode</span><span class="params">(AK09915_operationMode_t targetMode)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">/*保护其他位（FIFO，SDR）不被修改*/</span></span><br><span class="line">	<span class="type">uint8_t</span> preStatus;</span><br><span class="line">	AK09915_IIC_ReadRegs(MAGREG_CONTROL2, &amp;preStatus, <span class="number">1</span>);</span><br><span class="line">	</span><br><span class="line">	preStatus &amp;= <span class="number">0xE0</span>;  <span class="comment">// 1110 0000，清除MODE&#123;4,0&#125;位，变成PowerDown模式</span></span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 进入Power Down 模式</span></span><br><span class="line">	AK09915_IIC_WriteRegs(MAGREG_CONTROL2, preStatus);</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 等待1ms</span></span><br><span class="line">	HAL_Delay(<span class="number">1</span>);</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 进入目标模式</span></span><br><span class="line">	<span class="keyword">if</span>(targetMode != AK09915_operationMode_PowerDown)</span><br><span class="line">	&#123;</span><br><span class="line">		preStatus |= targetMode;</span><br><span class="line">		AK09915_IIC_WriteRegs(MAGREG_CONTROL2, preStatus);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * @brief  设备初始化</span></span><br><span class="line"><span class="comment">  * @note   使用前需初始化好IIC接口</span></span><br><span class="line"><span class="comment">  * @param  None</span></span><br><span class="line"><span class="comment">  * @retval None</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">AK09915_initDev</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">/***</span></span><br><span class="line"><span class="comment">	 * 配置 CNTL1 和 CNTL2 寄存器</span></span><br><span class="line"><span class="comment">	 * 使能噪声抑制滤波器，关闭FIFO，低噪声模式，200Hz采样率</span></span><br><span class="line"><span class="comment">	****/</span></span><br><span class="line">	<span class="type">uint8_t</span> ctrlRegs[<span class="number">2</span>] = &#123; AK09915_NSF_EN, </span><br><span class="line">		                      AK09915_FIFO_DIS | AK09915_SDR_LowNoise | AK09915_operationMode_ContinueMode1_10Hz</span><br><span class="line">	                      &#125;;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 设备复位</span></span><br><span class="line">	AK09915_resetDev_HardMethod();</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 进入空闲模式</span></span><br><span class="line">	AK09915_setOpMode(AK09915_operationMode_PowerDown);</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 配置参数</span></span><br><span class="line">	AK09915_IIC_WriteRegs(MAGREG_CONTROL1,ctrlRegs[<span class="number">0</span>]);</span><br><span class="line">	AK09915_IIC_WriteRegs(MAGREG_CONTROL2,ctrlRegs[<span class="number">1</span>]);</span><br><span class="line">												</span><br><span class="line">	<span class="comment">// 读出参数，校验一下</span></span><br><span class="line"><span class="comment">//	HAL_Delay(1);</span></span><br><span class="line"><span class="comment">//	AK09915_IIC_ReadRegs(MAGREG_CONTROL1, ctrlRegs,2);</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面的代码，把AK09915配置成了<code>DRDY</code>引脚输出有效数据，因此MCU可以使用外部GPIO中断来读数据：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * @brief  中断解析回调函数</span></span><br><span class="line"><span class="comment">  * @note   在MCU中断引脚对应的EXTI函数中调用</span></span><br><span class="line"><span class="comment">  *         开启测量后自动生成中断</span></span><br><span class="line"><span class="comment">  * @param  None</span></span><br><span class="line"><span class="comment">  * @retval None</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">AK09915_callback_interrupt</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">uint8_t</span> statusCache;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// - 读状态寄存器1</span></span><br><span class="line">	AK09915_IIC_ReadRegs(MAGREG_STATUS1, &amp;statusCache, <span class="number">1</span>);</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// - 检验是否有数据，NOTE：这里优化去掉，因为是中断模式</span></span><br><span class="line"><span class="comment">//	if (statusCache &amp; MAGREGMASK_CTRL1_DRDY)</span></span><br><span class="line"><span class="comment">//	&#123;</span></span><br><span class="line"><span class="comment">//		/*有数据，读数据*/</span></span><br><span class="line"><span class="comment">//	&#125;</span></span><br><span class="line">	</span><br><span class="line">	<span class="comment">// - 检验是否有数据遗漏</span></span><br><span class="line">	<span class="keyword">if</span>(statusCache &amp; MAGREGMASK_CTRL1_DOR)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">/*处理数据遗漏问题*/</span></span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// - 读取数据</span></span><br><span class="line">	AK09915_IIC_ContinueReadRegs((<span class="type">uint8_t</span> *)&amp;ak09915_rawRegDataCache, <span class="keyword">sizeof</span>(ak09915_rawRegDataCache));</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// - 读状态寄存器2</span></span><br><span class="line">	AK09915_IIC_ContinueReadRegs(&amp;statusCache, <span class="number">1</span>);	<span class="comment">// 一个Dummy</span></span><br><span class="line">	AK09915_IIC_ContinueReadRegs(&amp;statusCache, <span class="number">1</span>);</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// - 判断数据是否溢出（如果总磁强大于4912uT，芯片判为溢出）</span></span><br><span class="line">	<span class="keyword">if</span>(statusCache &amp; MAGREGMASK_CTRL2_HOFL)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">/*处理磁强爆表问题*/</span></span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// - 判断数据有效与否（仅用于FIFO模式，标志FIFO缓冲区过读）</span></span><br><span class="line">	<span class="meta">#<span class="keyword">ifdef</span> _USER_USE_AK09915_FIFO_</span></span><br><span class="line">	<span class="keyword">if</span>(statusCache &amp; MAGREGMASK_CTRL2_INV)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">/*处理FIFO读到无效数据*/</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>最后给出上面用到的底层通信接口，读者可以根据需要优化成DMA和操作系统信号量的形式：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/******************************************************************</span></span><br><span class="line"><span class="comment">**  通信封装</span></span><br><span class="line"><span class="comment">*******************************************************************/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * @brief  向指定寄存器写入数据</span></span><br><span class="line"><span class="comment">  * @note   一次只写一个数据！</span></span><br><span class="line"><span class="comment">  * @param  regAddr: 目标寄存器起始地址</span></span><br><span class="line"><span class="comment">  * @param  Data:   写入的数据</span></span><br><span class="line"><span class="comment">  * @retval None</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">AK09915_IIC_WriteRegs</span><span class="params">(<span class="type">uint8_t</span> regAddr, <span class="type">uint8_t</span> Data)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">uint8_t</span> ak09915_transCache[<span class="number">2</span>];</span><br><span class="line">	</span><br><span class="line">	ak09915_transCache[<span class="number">0</span>] = regAddr;	<span class="comment">// 寄存器地址</span></span><br><span class="line">	ak09915_transCache[<span class="number">1</span>] = Data;</span><br><span class="line">	HAL_I2C_Master_Transmit(&amp;AK09915DRV_IIC_HANDLER,	<span class="comment">/*HAL IIC Handler*/</span></span><br><span class="line">		                         AK09915DRV_IIC_ADDR,   <span class="comment">/*AK09915的IIC地址*/</span></span><br><span class="line">	                           ak09915_transCache, <span class="number">2</span>, <span class="comment">/*传输的数据和长度*/</span></span><br><span class="line">	                           <span class="number">0xff</span>);   <span class="comment">/*超时阈值*/</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * @brief  从指定寄存器读取数据</span></span><br><span class="line"><span class="comment">  * @note   支持连续读一串数据，地址自增</span></span><br><span class="line"><span class="comment">  * @param  regAddr: 目标寄存器起始地址</span></span><br><span class="line"><span class="comment">  * @param  pData:   读取数据存放位置</span></span><br><span class="line"><span class="comment">  * @param  len  :   读数据个数</span></span><br><span class="line"><span class="comment">  * @retval None</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">AK09915_IIC_ReadRegs</span><span class="params">(<span class="type">uint8_t</span> regAddr, <span class="type">uint8_t</span> * pData, <span class="type">uint8_t</span> len)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">uint8_t</span> ak09915_transCache;</span><br><span class="line">	</span><br><span class="line">	ak09915_transCache = regAddr;	<span class="comment">// 寄存器地址</span></span><br><span class="line">	HAL_I2C_Master_Transmit(&amp;AK09915DRV_IIC_HANDLER,	<span class="comment">/*HAL IIC Handler*/</span></span><br><span class="line">		                         AK09915DRV_IIC_ADDR,   <span class="comment">/*AK09915的IIC地址*/</span></span><br><span class="line">	                           &amp;ak09915_transCache, <span class="number">1</span>, <span class="comment">/*传输的数据和长度*/</span></span><br><span class="line">	                           <span class="number">0xff</span>);   <span class="comment">/*超时阈值*/</span></span><br><span class="line">	</span><br><span class="line">	<span class="comment">/*- 收数据 -*/</span></span><br><span class="line">	HAL_I2C_Master_Receive(&amp;AK09915DRV_IIC_HANDLER,	<span class="comment">/*HAL IIC Handler*/</span></span><br><span class="line">		                         AK09915DRV_IIC_ADDR,   <span class="comment">/*AK09915的IIC地址*/</span></span><br><span class="line">	                           pData, len, <span class="comment">/*传输的数据和长度*/</span></span><br><span class="line">	                           <span class="number">0xff</span>);   <span class="comment">/*超时阈值*/</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * @brief  从上一次读取后继续读取</span></span><br><span class="line"><span class="comment">  * @note   小心越界循环读取！</span></span><br><span class="line"><span class="comment">  * @param  pData:   读取数据存放位置</span></span><br><span class="line"><span class="comment">  * @param  len  :   读数据个数</span></span><br><span class="line"><span class="comment">  * @retval None</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">AK09915_IIC_ContinueReadRegs</span><span class="params">(<span class="type">uint8_t</span> * pData, <span class="type">uint8_t</span> len)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">/*- 收数据 -*/</span></span><br><span class="line">	HAL_I2C_Master_Receive(&amp;AK09915DRV_IIC_HANDLER,	<span class="comment">/*HAL IIC Handler*/</span></span><br><span class="line">		                         AK09915DRV_IIC_ADDR,   <span class="comment">/*AK09915的IIC地址*/</span></span><br><span class="line">	                           pData, len, <span class="comment">/*传输的数据和长度*/</span></span><br><span class="line">	                           <span class="number">0xff</span>);   <span class="comment">/*超时阈值*/</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/******************************************************************</span></span><br><span class="line"><span class="comment">**  基础功能</span></span><br><span class="line"><span class="comment">*******************************************************************/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * @brief  硬件复位AK09915设备</span></span><br><span class="line"><span class="comment">  * @note   提前配置RSTN引脚</span></span><br><span class="line"><span class="comment">  * @param  None</span></span><br><span class="line"><span class="comment">  * @retval None</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">AK09915_resetDev_HardMethod</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">// 拉低RSTN引脚</span></span><br><span class="line">	HAL_GPIO_WritePin(MAG_RSTN_GPIO_Port, MAG_RSTN_Pin,</span><br><span class="line">	                  GPIO_PIN_RESET);</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 等待1ms</span></span><br><span class="line">	HAL_Delay(<span class="number">1</span>);</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 拉高RSTN引脚</span></span><br><span class="line">	HAL_GPIO_WritePin(MAG_RSTN_GPIO_Port, MAG_RSTN_Pin,</span><br><span class="line">	                  GPIO_PIN_SET);</span><br><span class="line">	</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * @brief  读取设备号通信测试</span></span><br><span class="line"><span class="comment">  * @note   检验 WHOIAM 寄存器数据</span></span><br><span class="line"><span class="comment">  * @param  None</span></span><br><span class="line"><span class="comment">  * @retval 0正确；1通信错误；2数值错误</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"><span class="type">uint32_t</span> <span class="title function_">AK09915_communicateTest</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">uint8_t</span> ak09915_testCache[<span class="number">2</span>];</span><br><span class="line">	</span><br><span class="line">	AK09915_resetDev_HardMethod();	<span class="comment">// 复位并使能设备</span></span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 发地址</span></span><br><span class="line">	ak09915_testCache[<span class="number">0</span>] = MAGREG_WHOIAM1_COMPANYID;</span><br><span class="line">	<span class="keyword">if</span>(HAL_I2C_Master_Transmit(&amp;AK09915DRV_IIC_HANDLER,</span><br><span class="line">		                         AK09915DRV_IIC_ADDR,</span><br><span class="line">	                           ak09915_testCache, <span class="number">1</span>,</span><br><span class="line">	                           <span class="number">0xff</span>) \</span><br><span class="line">	     != HAL_OK)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">1</span>;	<span class="comment">// 通信错误</span></span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 读取WHOAMI1和WHOAMI2数据</span></span><br><span class="line">	<span class="keyword">if</span> (HAL_I2C_Master_Receive(&amp;AK09915DRV_IIC_HANDLER,</span><br><span class="line">		                         AK09915DRV_IIC_ADDR,</span><br><span class="line">	                           ak09915_testCache, <span class="number">2</span>,</span><br><span class="line">	                           <span class="number">0xff</span>) \</span><br><span class="line">	     != HAL_OK)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">1</span>;	<span class="comment">// 通信错误</span></span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 检验正确性</span></span><br><span class="line">	<span class="keyword">if</span>(ak09915_testCache[<span class="number">0</span>] == MAGREGVAL_WHOIAM1_COMPANYID \</span><br><span class="line">		 &amp;&amp; \</span><br><span class="line">	   ak09915_testCache[<span class="number">1</span>] == MAGREGVAL_WHOIAM2_DEVICEID)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;	<span class="comment">// 正确</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		<span class="keyword">return</span> <span class="number">2</span>;	<span class="comment">// 数值错误</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * @brief  获取地磁数据</span></span><br><span class="line"><span class="comment">  * @note   原始16位有符号数据</span></span><br><span class="line"><span class="comment">  * @param  pRes : 存放读取数据的位置</span></span><br><span class="line"><span class="comment">  * @retval None</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">AK09915_getRawData</span><span class="params">(AK09915_rawRegData_t * pRes)</span></span><br><span class="line">&#123;</span><br><span class="line">	AK09915_IIC_ReadRegs(MAGREG_X_L, (<span class="type">uint8_t</span> *)pRes, <span class="keyword">sizeof</span>(AK09915_rawRegData_t));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>必要类型与变量的声名：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> __AK09915_DEFS_H__</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __AK09915_DEFS_H__</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stdint.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/******************************************************************</span></span><br><span class="line"><span class="comment">**  数据格式</span></span><br><span class="line"><span class="comment">*******************************************************************/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="class"><span class="keyword">union</span>&#123;</span></span><br><span class="line">		<span class="type">uint8_t</span> L_H_bytes[<span class="number">2</span>];</span><br><span class="line">		<span class="type">int16_t</span> getSigned;</span><br><span class="line">	&#125; HX;</span><br><span class="line">	</span><br><span class="line">	<span class="class"><span class="keyword">union</span>&#123;</span></span><br><span class="line">		<span class="type">uint8_t</span> L_H_bytes[<span class="number">2</span>];</span><br><span class="line">		<span class="type">int16_t</span> getSigned;</span><br><span class="line">	&#125; HY;</span><br><span class="line">	</span><br><span class="line">	<span class="class"><span class="keyword">union</span>&#123;</span></span><br><span class="line">		<span class="type">uint8_t</span> L_H_bytes[<span class="number">2</span>];</span><br><span class="line">		<span class="type">int16_t</span> getSigned;</span><br><span class="line">	&#125; HZ;</span><br><span class="line">	</span><br><span class="line">&#125; AK09915_rawRegData_t;</span><br><span class="line"></span><br><span class="line"><span class="comment">/******************************************************************</span></span><br><span class="line"><span class="comment">**  寄存器地址表</span></span><br><span class="line"><span class="comment">*******************************************************************/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAGREG_WHOIAM1_COMPANYID  0x00	<span class="comment">// AK公司ID</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAGREG_WHOIAM2_DEVICEID   0x01	<span class="comment">// 设备ID</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAGREG_STATUS1            0x10	<span class="comment">// 状态：数据准备、数据覆盖</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAGREG_X_L                0x11</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAGREG_X_H                0x12</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAGREG_Y_L                0x13</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAGREG_Y_H                0x14</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAGREG_Z_L                0x15</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAGREG_Z_H                0x16</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAGREG_STATUS2            0x18	<span class="comment">// 状态：磁量溢出、无效数据</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAGREG_CONTROL1           0x30	<span class="comment">// 配置：NSF使能、FIFO的阈值</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAGREG_CONTROL2           0x31	<span class="comment">// 配置：工作模式、功耗模式、FIFO使能</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAGREG_CONTROL3           0x32	<span class="comment">// 配置：软件复位</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/******************************************************************</span></span><br><span class="line"><span class="comment">**  寄存器内容</span></span><br><span class="line"><span class="comment">*******************************************************************/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAGREGVAL_WHOIAM1_COMPANYID  (0x48)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAGREGVAL_WHOIAM2_DEVICEID   (0x10)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * @reg MAGREG_STATUS1</span></span><br><span class="line"><span class="comment">***/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAGREGMASK_CTRL1_DRDY 0x01	<span class="comment">// 数据准备好了</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAGREGMASK_CTRL1_DOR  0x02	<span class="comment">// 数据覆盖</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAGREGMASK_CTRL1_HSM  0x80	<span class="comment">// 高速IIC 模式</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * @reg MAGREG_STATUS2</span></span><br><span class="line"><span class="comment">***/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAGREGMASK_CTRL2_INV  0x04	<span class="comment">// 无效数据</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAGREGMASK_CTRL2_HOFL 0x08	<span class="comment">// 数据溢出</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * @reg MAGREG_CONTROL1</span></span><br><span class="line"><span class="comment">***/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">enum</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	AK09915_NSF_EN  = (<span class="number">0x01</span>&lt;&lt;<span class="number">5</span>),</span><br><span class="line">	AK09915_NSF_DIS = (<span class="number">0x00</span>&lt;&lt;<span class="number">5</span>),</span><br><span class="line">&#125; AK09915_NSF_t;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * @reg MAGREG_CONTROL2</span></span><br><span class="line"><span class="comment">***/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">enum</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	AK09915_operationMode_PowerDown          = <span class="number">0x0</span>,</span><br><span class="line">	AK09915_operationMode_SingleMeasure      = <span class="number">0x1</span>,</span><br><span class="line">	AK09915_operationMode_ContinueMode1_10Hz = <span class="number">0x2</span>,</span><br><span class="line">	AK09915_operationMode_ContinueMode2_20Hz = <span class="number">0x4</span>,</span><br><span class="line">	AK09915_operationMode_ContinueMode3_50Hz = <span class="number">0x6</span>,</span><br><span class="line">	AK09915_operationMode_ContinueMode4_100Hz= <span class="number">0x8</span>,</span><br><span class="line">	AK09915_operationMode_ContinueMode5_200Hz= <span class="number">0xA</span>,</span><br><span class="line">	AK09915_operationMode_ContinueMode6_1Hz  = <span class="number">0xC</span>,</span><br><span class="line">	AK09915_operationMode_SelfTest          = <span class="number">0x10</span>,</span><br><span class="line">&#125; AK09915_operationMode_t;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">enum</span>&#123;</span></span><br><span class="line">	AK09915_SDR_LowPower = (<span class="number">0x0</span>&lt;&lt;<span class="number">6</span>),</span><br><span class="line">	AK09915_SDR_LowNoise = (<span class="number">0x1</span>&lt;&lt;<span class="number">6</span>),</span><br><span class="line">&#125; AK09915_SDR_t;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">enum</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	AK09915_FIFO_EN  = (<span class="number">0x01</span>&lt;&lt;<span class="number">7</span>),</span><br><span class="line">	AK09915_FIFO_DIS = (<span class="number">0x00</span>&lt;&lt;<span class="number">7</span>),</span><br><span class="line">&#125; AK09915_FIFO_t;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * @reg MAGREG_CONTROL3</span></span><br><span class="line"><span class="comment">***/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">enum</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	AK09915_SRST_EN  = <span class="number">1</span>,</span><br><span class="line">	AK09915_SRST_DIS = <span class="number">0</span>,</span><br><span class="line">&#125; AK09915_SRST_t;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="椭球矫正算法"><a href="#椭球矫正算法" class="headerlink" title="椭球矫正算法"></a>椭球矫正算法</h3><p><img src="https://blog-img-goryj.oss-rg-china-mainland.aliyuncs.com/blogpost/20220828-electCompass-7.png" alt="矫正效果"></p>
<p>为了方便算法的验证，这里使用Matlab作为主要编程工具，上图就是对原始采样数据矫正前后的效果对比（显然矫正前后椭球的中心补偿到了零点，椭球的轴长比接近1：1也就是圆球）。当然也可以使用Python或者纯C实现（最后部署时还得是C），但是Py和C在矫正效果展示方面（3D绘图）实在太困难了，没有Matlab方便。以下代码即可在Matlab上直接实现原始数据的分析、矫正、数据展示：</p>
<figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line"><span class="comment">%% 配置工作条件 ----------------------------------------------------------</span></span><br><span class="line"></span><br><span class="line"><span class="comment">% 存储电子罗盘采样数据的文件名</span></span><br><span class="line">compassDataFileName = <span class="string">&quot;ak09915.csv&quot;</span>;</span><br><span class="line"><span class="comment">% 显示图像的方式：1. 子图形式， 2. 分别显示</span></span><br><span class="line">SHOW_FIG_PATTERN_METHOD = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">%% 读取采样数据 -----------------------------------------------------------</span></span><br><span class="line"></span><br><span class="line"><span class="comment">% 自动解析CSV文件，自动识别并去掉表头，返回矩阵类型</span></span><br><span class="line">elecCompassDataTable = readmatrix(compassDataFileName);</span><br><span class="line"></span><br><span class="line"><span class="comment">% 提取3个轴向数据向量</span></span><br><span class="line">xVector = elecCompassDataTable(:,<span class="number">1</span>);</span><br><span class="line">yVector = elecCompassDataTable(:,<span class="number">2</span>);</span><br><span class="line">zVector = elecCompassDataTable(:,<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">%% 求解标准椭球方程的9个参数 -----------------------------------------------</span></span><br><span class="line"></span><br><span class="line">epis9Param = fitEpisode9Param(xVector,yVector,zVector);</span><br><span class="line"></span><br><span class="line"><span class="comment">%% 显示原始数据与拟合效果 --------------------------------------------------</span></span><br><span class="line"><span class="built_in">figure</span></span><br><span class="line"><span class="keyword">if</span> SHOW_FIG_PATTERN_METHOD == <span class="number">1</span></span><br><span class="line">    subplot(<span class="number">1</span>,<span class="number">2</span>,<span class="number">1</span>)</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">% 计算3D显示的数据范围</span></span><br><span class="line">intv = [<span class="built_in">min</span>(xVector) <span class="built_in">max</span>(xVector) <span class="built_in">min</span>(yVector) <span class="built_in">max</span>(yVector) <span class="built_in">min</span>(zVector) <span class="built_in">max</span>(zVector)];</span><br><span class="line">intv = <span class="number">1.2</span> * intv;  <span class="comment">% 比顶端数据范围大20%</span></span><br><span class="line"><span class="comment">% 标准9参数椭球方程</span></span><br><span class="line">f = @(x,y,z) epis9Param(<span class="number">1</span>)*x.^<span class="number">2</span>  + epis9Param(<span class="number">2</span>)* y.^<span class="number">2</span> + epis9Param(<span class="number">3</span>)* z.^<span class="number">2</span> + ...</span><br><span class="line">             epis9Param(<span class="number">4</span>)*<span class="number">2</span>*x*y + epis9Param(<span class="number">5</span>)*<span class="number">2</span>*x*z + epis9Param(<span class="number">6</span>)*<span class="number">2</span>*y*z + ...</span><br><span class="line">             epis9Param(<span class="number">7</span>)*<span class="number">2</span>*x   + epis9Param(<span class="number">8</span>)*<span class="number">2</span>*y   + epis9Param(<span class="number">9</span>)*<span class="number">2</span>*z  <span class="number">-1</span>;</span><br><span class="line"><span class="comment">% 绘制椭球面</span></span><br><span class="line">fimplicit3(f,intv)</span><br><span class="line"></span><br><span class="line"><span class="comment">% 添加原始采样数据散点</span></span><br><span class="line"><span class="built_in">hold</span> on</span><br><span class="line"><span class="built_in">scatter3</span>(xVector,yVector,zVector)</span><br><span class="line"><span class="comment">% 添加标题和轴标</span></span><br><span class="line">title(<span class="string">&quot;电子罗盘采样数据-非方矩阵的伪逆法拟合效果&quot;</span>)</span><br><span class="line">xlabel(<span class="string">&quot;x&quot;</span>)</span><br><span class="line">ylabel(<span class="string">&quot;y&quot;</span>)</span><br><span class="line">zlabel(<span class="string">&quot;z&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">%% 求解校准矩阵------------------------------------------------------------</span></span><br><span class="line"></span><br><span class="line"><span class="comment">% 中心偏移向量</span></span><br><span class="line">A3x3 = [ epis9Param(<span class="number">1</span>) epis9Param(<span class="number">4</span>) epis9Param(<span class="number">5</span>) ;</span><br><span class="line">         epis9Param(<span class="number">4</span>) epis9Param(<span class="number">2</span>) epis9Param(<span class="number">6</span>) ;</span><br><span class="line">         epis9Param(<span class="number">5</span>) epis9Param(<span class="number">6</span>) epis9Param(<span class="number">3</span>) ];</span><br><span class="line">Vghi = [ epis9Param(<span class="number">7</span>); epis9Param(<span class="number">8</span>); epis9Param(<span class="number">9</span>) ];</span><br><span class="line">CentorOffVec = inv(A3x3)*Vghi;</span><br><span class="line"></span><br><span class="line"><span class="comment">% 旋转矩阵</span></span><br><span class="line">T = [        <span class="number">1</span>             <span class="number">0</span>              <span class="number">0</span>           <span class="number">0</span></span><br><span class="line">             <span class="number">0</span>             <span class="number">1</span>              <span class="number">0</span>           <span class="number">0</span></span><br><span class="line">             <span class="number">0</span>             <span class="number">0</span>              <span class="number">1</span>           <span class="number">0</span></span><br><span class="line">      CentorOffVec(<span class="number">1</span>) CentorOffVec(<span class="number">2</span>) CentorOffVec(<span class="number">3</span>) <span class="number">1</span>];</span><br><span class="line">A4x4 = [A3x3  Vghi</span><br><span class="line">        Vghi&#x27;  <span class="number">-1</span> ];</span><br><span class="line">B4x4 = T * A4x4 * T&#x27; ;</span><br><span class="line">B3x3 = B4x4(<span class="number">1</span>:<span class="number">3</span>,<span class="number">1</span>:<span class="number">3</span>) / (-B4x4(<span class="number">4</span>,<span class="number">4</span>));</span><br><span class="line">[eigVector,eigLambda] = eig(B3x3);   <span class="comment">% 分解特征向量和特征值</span></span><br><span class="line"></span><br><span class="line">invRot = inv(eigVector);    <span class="comment">% 反旋转矩阵</span></span><br><span class="line">invGainVector = [eigLambda(<span class="number">1</span>,<span class="number">1</span>); eigLambda(<span class="number">2</span>,<span class="number">2</span>); eigLambda(<span class="number">3</span>,<span class="number">3</span>)];</span><br><span class="line">invGainVector = <span class="number">1</span> ./ <span class="built_in">sqrt</span>(invGainVector); <span class="comment">% 各轴增益补偿矩阵</span></span><br><span class="line"></span><br><span class="line"><span class="comment">%% 对原本采样的数据进行矫正-------------------------------------------------</span></span><br><span class="line"></span><br><span class="line">xyzRectData = [xVector, yVector, zVector]; <span class="comment">% 3轴数据组合起来更快</span></span><br><span class="line">xyzRectData = xyzRectData + CentorOffVec&#x27;; <span class="comment">% 球心偏置矫正</span></span><br><span class="line">xyzRectData = invRot * xyzRectData&#x27;;</span><br><span class="line">xyzRectData = xyzRectData&#x27;; <span class="comment">% 旋转矫正</span></span><br><span class="line">xyzRectData = xyzRectData ./ invGainVector&#x27;;</span><br><span class="line"></span><br><span class="line"><span class="comment">%% 显示矫正后的数据---------------------------------------------------------</span></span><br><span class="line"><span class="keyword">if</span> SHOW_FIG_PATTERN_METHOD == <span class="number">1</span></span><br><span class="line">    subplot(<span class="number">1</span>,<span class="number">2</span>,<span class="number">2</span>);</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    <span class="keyword">if</span> SHOW_FIG_PATTERN_METHOD == <span class="number">2</span></span><br><span class="line">        <span class="built_in">figure</span>;</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">xRectVector = xyzRectData(:,<span class="number">1</span>);</span><br><span class="line">yRectVector = xyzRectData(:,<span class="number">2</span>);</span><br><span class="line">zRectVector = xyzRectData(:,<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">% 再按照9参数椭球标准拟合一次</span></span><br><span class="line">episRect9Param = fitEpisode9Param(xRectVector,yRectVector,zRectVector);</span><br><span class="line"><span class="comment">% 计算3D显示的数据范围</span></span><br><span class="line">intv = [<span class="built_in">min</span>(xRectVector) <span class="built_in">max</span>(xRectVector) <span class="built_in">min</span>(yRectVector) <span class="built_in">max</span>(yRectVector) <span class="built_in">min</span>(zRectVector) <span class="built_in">max</span>(zRectVector)];</span><br><span class="line">intv = <span class="number">1.2</span> * intv;  <span class="comment">% 比顶端数据范围大20%</span></span><br><span class="line"><span class="comment">% 标准9参数椭球方程</span></span><br><span class="line">rectF = @(x,y,z) episRect9Param(<span class="number">1</span>)*x.^<span class="number">2</span>  + episRect9Param(<span class="number">2</span>)* y.^<span class="number">2</span> + episRect9Param(<span class="number">3</span>)* z.^<span class="number">2</span> + ...</span><br><span class="line">             episRect9Param(<span class="number">4</span>)*<span class="number">2</span>*x*y + episRect9Param(<span class="number">5</span>)*<span class="number">2</span>*x*z + episRect9Param(<span class="number">6</span>)*<span class="number">2</span>*y*z + ...</span><br><span class="line">             episRect9Param(<span class="number">7</span>)*<span class="number">2</span>*x   + episRect9Param(<span class="number">8</span>)*<span class="number">2</span>*y   + episRect9Param(<span class="number">9</span>)*<span class="number">2</span>*z  <span class="number">-1</span>;</span><br><span class="line"><span class="comment">% 绘制椭球面</span></span><br><span class="line">fimplicit3(rectF,intv)</span><br><span class="line"></span><br><span class="line"><span class="comment">% 添加原始采样数据散点</span></span><br><span class="line"><span class="built_in">hold</span> on</span><br><span class="line"><span class="built_in">scatter3</span>(xRectVector,yRectVector,zRectVector)</span><br><span class="line"><span class="comment">% 添加标题和轴标</span></span><br><span class="line">title(<span class="string">&quot;电子罗盘矫正数据&quot;</span>)</span><br><span class="line">xlabel(<span class="string">&quot;x&quot;</span>)</span><br><span class="line">ylabel(<span class="string">&quot;y&quot;</span>)</span><br><span class="line">zlabel(<span class="string">&quot;z&quot;</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>其中，对椭球表面的采样散点数据进行最小二乘拟合参数的函数<code>fitEpisode9Param</code>实现很简单，就是上面的非方矩阵的伪逆公式的代码形式：</p>
<figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="params">[fitParamVector]</span> = <span class="title">fitEpisode9Param</span><span class="params">(xVector,yVector,zVector)</span></span></span><br><span class="line">    D = [ xVector.*xVector, yVector.*yVector, zVector.*zVector, ...</span><br><span class="line">          <span class="number">2</span>*xVector.*yVector, <span class="number">2</span>*xVector.*zVector, <span class="number">2</span>*yVector.*zVector, ...</span><br><span class="line">          <span class="number">2</span>*xVector, <span class="number">2</span>*yVector, <span class="number">2</span>*zVector];</span><br><span class="line">    </span><br><span class="line">    fitParamVector = inv(D&#x27; * D) * D&#x27; * <span class="built_in">ones</span>(<span class="built_in">length</span>(xVector),<span class="number">1</span>);</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>

<h3 id="矫正电子罗盘并求解航向角（嵌入式）"><a href="#矫正电子罗盘并求解航向角（嵌入式）" class="headerlink" title="矫正电子罗盘并求解航向角（嵌入式）"></a>矫正电子罗盘并求解航向角（嵌入式）</h3><p>最后一步了，就是把矫正部署到实际硬件上，并且根据得到的地磁向量直接求解出航向角。由于上面已经多次讨论并且展示了矫正算法，所以我们可以很容易地用C语言实现如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;math.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * @brief  椭球矫正算法</span></span><br><span class="line"><span class="comment">  * @note   输入参数是标准9参数转换后的矩阵形式</span></span><br><span class="line"><span class="comment">  * @param  pSrc : 磁传感数据存放的位置</span></span><br><span class="line"><span class="comment">  * @retval None</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">episodeRectify</span><span class="params">(mag_rawData_t * pSrc)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">float</span> EpiCmptCache[<span class="number">3</span>];</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 中心偏移 B_&#123;noBias&#125; = B_&#123;samp&#125;-Offset  注意这里补偿的正负号</span></span><br><span class="line">	pSrc-&gt;compass[<span class="number">0</span>] = pSrc-&gt;magX + pSrc-&gt;centerOffset[<span class="number">0</span>];</span><br><span class="line">	pSrc-&gt;compass[<span class="number">1</span>] = pSrc-&gt;magY + pSrc-&gt;centerOffset[<span class="number">1</span>];</span><br><span class="line">	pSrc-&gt;compass[<span class="number">2</span>] = pSrc-&gt;magZ + pSrc-&gt;centerOffset[<span class="number">2</span>];</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 反旋转   B_&#123;noRot&#125; = invRot * B_&#123;noBias&#125;</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i =<span class="number">0</span>; i&lt;<span class="number">3</span>; i++)	<span class="comment">// 逐行求</span></span><br><span class="line">	&#123;</span><br><span class="line">		EpiCmptCache[i] = pSrc-&gt;invRot[i][<span class="number">0</span>] * pSrc-&gt;compass[<span class="number">0</span>] + \</span><br><span class="line">		                  pSrc-&gt;invRot[i][<span class="number">1</span>] * pSrc-&gt;compass[<span class="number">1</span>] + \</span><br><span class="line">		                  pSrc-&gt;invRot[i][<span class="number">2</span>] * pSrc-&gt;compass[<span class="number">2</span>];	<span class="comment">// 矩阵乘法</span></span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 轴长补偿  注意：这里使用乘法（因为比除法更快），所以加载补偿量时应该是 1/轴长</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i =<span class="number">0</span>; i&lt;<span class="number">3</span>; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		pSrc-&gt;compass[i] = EpiCmptCache[i] * pSrc-&gt;gain[i];</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * @brief  解算航向角</span></span><br><span class="line"><span class="comment">  * @note   若严重非水平，应当传入旋转补偿后的磁向量</span></span><br><span class="line"><span class="comment">  * @param  compass3Axis : x,y,z轴的磁向量数据</span></span><br><span class="line"><span class="comment">  * @retval yaw 偏航角</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"><span class="type">float</span> <span class="title function_">getYaw_FromCompass</span><span class="params">(<span class="type">float</span> compass3Axis[<span class="number">3</span>])</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">/**                                    Y      */</span></span><br><span class="line">	<span class="comment">/* 水平情况下偏航角求解公式 ： arctan( ------)  */</span></span><br><span class="line">	<span class="comment">/*                                     X      */</span></span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">atan2</span>( compass3Axis[<span class="number">1</span>] , compass3Axis[<span class="number">0</span>] );	<span class="comment">// 参见 math.h</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最后简单点一下上面实现中的一些小技巧。首先，矫正算法中的旋转补偿这里在加载参数的时候就以$R^{-1}$的形式，这样可以节省非常多的计算量；接着，在各轴向补偿上，原本是$&#x2F;G$，但是在硬件上浮点除法是比乘法要难算的，所以这里我们在加载参数的时候就以$1&#x2F;G$的形式加载，将除法换成了乘法；最后，求航向角使用的是ARM的数学库，推荐读者在使用不同处理器时进行相应的优化（如果有的话）。</p>
<h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ul>
<li><a href="https://www.st.com/resource/zh/design_tip/dm00286302-ellipsoid-or-sphere-fitting-for-sensor-calibration-stmicroelectronics.pdf">意法半导体公司对用于传感器校准的椭球或球体拟合的设计建议</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/87582571">矩阵最小二乘-知乎作者：你是想难为我胖虎</a></li>
</ul>
]]></content>
      <categories>
        <category>嵌入式&amp;控制算法</category>
      </categories>
      <tags>
        <tag>电子罗盘</tag>
        <tag>IIC</tag>
        <tag>椭球拟合</tag>
      </tags>
  </entry>
  <entry>
    <title>阻抗匹配和枝节匹配器</title>
    <url>/2021/06/23/%E9%98%BB%E6%8A%97%E5%8C%B9%E9%85%8D%E5%92%8C%E6%9E%9D%E8%8A%82%E5%8C%B9%E9%85%8D/</url>
    <content><![CDATA[<blockquote>
<p>前言：笔者这学期在课内学习了《微波技术》，本以为射频相关是永远不可能涉及的工作，直至前几日帮好兄弟解决了一个阻抗匹配的玄学通信案例，才意识到做硬件一定逃不开传输线的知识，以及阻抗匹配的重要性</p>
</blockquote>
<h2 id="匹配实战案例"><a href="#匹配实战案例" class="headerlink" title="匹配实战案例"></a>匹配实战案例</h2><p><img src="https://blog-img-goryj.oss-rg-china-mainland.aliyuncs.com/blogpost/20210625-IM-1.jpg" alt="开路同轴线匹配"></p>
<p>事情的起因是这样的，前几天我的一个好兄弟联系说有一个机械臂的STM32主控板有点问题，其他功能都正常，但是不能使用<code>SW</code>接口烧录调试只能用普通串口烧录代码。🤯“不会是假片子吧？”在片慌的2021年，这是笔者的第一感觉…</p>
<blockquote>
<p>“一切玄学本质上都是无知”——王贞炎（HUST-STI）</p>
</blockquote>
<p>拿到板子后，笔者用ST-LINK和CMSIS-DAP调试器分别试了一下，确实都识别不到芯片；看了一下Layout，板子上<code>SWCLK</code>和<code>SWD</code>没有做等长，所以怀疑是时钟对齐问题，把调试器的时钟降至最低的5kHz居然还是不行？！（建议读者记下这个常规调试方式）</p>
<p><img src="https://blog-img-goryj.oss-rg-china-mainland.aliyuncs.com/blogpost/20210625-IM-2.png" alt="layout"></p>
<p>这里不得不感谢一下华科电信院的微波考试的心理阴影，让笔者考完几天后还久久不能忘怀哈哈哈🐶我突然想到了阻抗匹配这个东西，怀疑有可能是阻抗匹配没做，实时证明也确实如此，如图中笔者使用了期末考的枝节匹配器</p>
<p><img src="https://blog-img-goryj.oss-rg-china-mainland.aliyuncs.com/blogpost/20210625-IM-3.png" alt="支线匹配"></p>
<p>DETAIL：在SWCLK引脚和地焊盘之间并联了一条终端开路的同轴传输线，单枝节匹配器理论上是只对一个频点（窄带）匹配，但是由于本例中总线时钟较低（5k~4M），所以获得了宽带匹配效果。</p>
<span id="more"></span>

<p>对于没有微波概念的读者来说，这非常难以理解，为什么并联一个开路的线能起作用呢？？？所以接下来笔者将分别讨论：</p>
<ol>
<li>高频分布参数电路及传输线方程</li>
<li>阻抗匹配</li>
<li>枝节匹配器</li>
</ol>
<p>并且在文末将会给出重要公式汇总，如果读者们不喜欢推导可以直接快进</p>
<h2 id="真正的传输线"><a href="#真正的传输线" class="headerlink" title="真正的传输线"></a>真正的传输线</h2><h3 id="传输线方程及解"><a href="#传输线方程及解" class="headerlink" title="传输线方程及解"></a>传输线方程及解</h3><p><img src="https://blog-img-goryj.oss-rg-china-mainland.aliyuncs.com/blogpost/20210625-IM-4.png" alt="普通传输线"></p>
<p>上图是你以为的传输线，Right？但实际上的传输线是由无数段如下结构所示的分布参数微元电路组成的，但是平时我们电路频率低长度短所以不考虑分布参数也可以正常使用。</p>
<p><img src="https://blog-img-goryj.oss-rg-china-mainland.aliyuncs.com/blogpost/20210625-IM-5.jpg" alt="分布参数电路"></p>
<blockquote>
<p>当信号的波长可以和电路尺寸相比拟时就要使用分布参数电路，所以这个知识在电网和高频中使用最多。举例：我们一般100k数量级频率信号，电磁波长在3000m数量级，比我们常规电路板（再大大不过10m）大很多，可以不考虑；但是1G频率的电路，电磁波长在0.3m数量级，这时候就必须要使用分布参数电路了</p>
</blockquote>
<p>上图中，各个参数意义如下：</p>
<ul>
<li>R：单位长度传输线分布电阻，物理单位是<code>Ω/m</code>，由导体材料决定</li>
<li>G：单位长度传输线分布并联电导，物理单位是<code>S/m</code>，由导体周围介质材料决定</li>
<li>L：单位长度传输线分布电感，物理单位是<code>L/m</code>，由导线截面尺寸、磁导率、线间距等决定</li>
<li>C：单位长度传输线间分布电容，物理单位是<code>F/m</code>，由导线截面尺寸、介电常数、线间距等决定</li>
</ul>
<p>首先我们分析上面的分布参数微元电路，有：</p>
<p>$$<br>u(z+\Delta z,t) &#x3D; u(z,t)+d u<br>\\<br>i(z+\Delta z,t) &#x3D; i(z,t)+d i<br>\\<br>-du(z,t)&#x3D;Rdz\cdot i(z,t)+Ldz\cdot \frac{\partial i(z,t)}{\partial t}<br>\\<br>-di(z,t)&#x3D;Gdz\cdot u(z,t)+Cdz\cdot \frac{\partial u(z,t)}{\partial t}<br>$$</p>
<p>由于所有信号都可以做Fourier分解，而且我们也常常传输的是三角信号，所以将电压电流设置为简谐量讨论，即：</p>
<p>$$<br>u(z,t)&#x3D;\text{Re}[U(z)e^{j\omega t}]<br>\\<br>i(z,t)&#x3D;\text{Re}[I(z)e^{j\omega t}]<br>\\ \therefore<br>\frac{\partial u(z,t)}{\partial t} &#x3D; \text{Re}[U(z)e^{j\omega t}j\omega]<br>\\<br>\frac{\partial i(z,t)}{\partial t} &#x3D; \text{Re}[I(z)e^{j\omega t}j\omega]<br>$$</p>
<p>所以，将上面的简谐形式带入微分电路关系式可得简谐振幅U和I关系：</p>
<p>$$<br>\frac{dU(z)}{dz}&#x3D;-(R+j\omega L)I(z)<br>\\<br>\frac{dI(z)}{dz}&#x3D;-(G+j\omega C)U(z)<br>$$</p>
<p>注意这里可以定义：</p>
<ul>
<li>传输线单位长度串联阻抗<br>  $$<br>  Z &#x3D; R +j\omega L<br>  $$</li>
<li>传输线单位长度并联导纳<br>  $$<br>  Y &#x3D; G +j\omega C<br>  $$</li>
</ul>
<p>我们现在可以用更加简单直观的方法重写上微分式：</p>
<p>$$<br>\frac{dU(z)}{dz}&#x3D;-Z\cdot I(z)<br>\\<br>\frac{dI(z)}{dz}&#x3D;-Y\cdot U(z)<br>\\ \therefore<br>\frac{d^2U(z)}{dz^2}&#x3D;-Z\cdot \frac{dI(z)}{dz}&#x3D;ZY\cdot U(z)<br>\\<br>\frac{dI(z)}{dz}&#x3D;-Y\cdot \frac{dU(z)}{dz}&#x3D;ZY\cdot I(z)<br>$$</p>
<p>注意这里我们又引入一个重要的定义——传播常数</p>
<p>$$<br>\gamma &#x3D; \sqrt{ZY} &#x3D; \alpha + j\beta<br>$$</p>
<blockquote>
<p>这里把传播常数分解为衰减常数和相位常数（后面会解释为什么叫这个）</p>
</blockquote>
<p>则我们可以得到一个漂亮的二阶齐次微分方程——传输线方程：</p>
<p>$$<br>\frac{d^2U(z)}{dz^2}-\gamma^2\cdot U(z)&#x3D;0<br>\\<br>\frac{dI(z)}{dz}-\gamma^2\cdot I(z)&#x3D;0<br>$$</p>
<p>以及传输线通解：</p>
<p>$$<br>U(z)&#x3D;Ae^{-\gamma z}+Be^{\gamma z}<br>\\<br>I(z) &#x3D; \frac{1}{Z_0}(Ae^{-\gamma z}-Be^{\gamma z})<br>$$</p>
<p>其中，特征阻抗：</p>
<p>$$<br>Z_0&#x3D;\sqrt{\frac{R +j\omega L}{G +j\omega C}}<br>$$</p>
<blockquote>
<p>从上面的通解形式，可以看到有两个简谐量，一个波面相当于往<code>-z</code>方向移动，一个波面相当于往<code>+z</code>方向移动，这就解释了上面传播常数的物理意义命令由来</p>
</blockquote>
<h3 id="传输线上的行波"><a href="#传输线上的行波" class="headerlink" title="传输线上的行波"></a>传输线上的行波</h3><p>先把传播常数拆开带入，解疑上面的衰减常数和相位常数定义：</p>
<p>$$<br>U(z)&#x3D;Ae^{-\gamma z}+Be^{\gamma z} &#x3D; Ae^{-(\alpha + j\beta) z}+Be^{(\alpha + j\beta) z}<br>\\<br>I(z) &#x3D; \frac{1}{Z_0}(Ae^{-\gamma z}-Be^{\gamma z})&#x3D; \frac{1}{Z_0}(Ae^{-(\alpha + j\beta) z}-Be^{(\alpha + j\beta) z})<br>\\ \Rightarrow<br>U(z) &#x3D; e^{-\alpha z} [Ae^{-j\beta z}+Be^{j\beta z}]<br>\\<br>I(z) &#x3D; e^{-\alpha z} \frac{1}{Z_0} [Ae^{-j\beta z}-Be^{j\beta z}]<br>$$</p>
<p>这时，参数的含义就很明显很自然了，显然第一个指数项是随着信号传播带来幅度衰减的效果，而第二个指数项为相角随距离周期变化。</p>
<p>一般来说，我们使用的传输线损耗都特别小（起码也是个铜材），在频率较高的场合显然有：</p>
<p>$$<br>R \ll j\omega L,G \ll j\omega C<br>$$</p>
<p>则我们提出无耗传输线，并基于“无耗”分析其他所有传输线特性：</p>
<p>$$<br>R &#x3D; 0,G &#x3D; 0<br>\\ \therefore<br>Z_0 &#x3D;\sqrt{ \frac{L}{C}}<br>\\<br>\gamma &#x3D; j\omega\sqrt{LC} &#x3D; j\beta<br>\\<br>\Rightarrow \alpha &#x3D;0,\beta &#x3D; \omega\sqrt{LC}<br>$$</p>
<p>无耗传输线通解：</p>
<p>$$<br>U(z) &#x3D; Ae^{-j\beta z}+Be^{j\beta z} &#x3D; U^+(z) + U^-(z)<br>\\<br>I(z) &#x3D;\frac{1}{Z_0} [Ae^{-j\beta z}-Be^{j\beta z}]<br>$$</p>
<p>注意这个时候的两个参数是由<strong>传输线边界条件决定</strong>的复参数，即：</p>
<p>$$<br>A &#x3D; |A| e^{j\phi_1}, B &#x3D; |B| e^{j\phi_2}<br>$$</p>
<p>则由上面电压、流信号的简谐定义可知：</p>
<p>$$<br>u(z,t) &#x3D; \text{Re}[U(z)e^{j\omega t}]&#x3D;|<br>A| \cos(\omega t -\beta z +\phi_1) + |<br>B| \cos(\omega t +\beta z +\phi_2)<br>\\<br>i(z,t) &#x3D; \text{Re}[I(z)e^{j\omega t}]&#x3D;\frac{|A|}{Z_0} \cos(\omega t -\beta z +\phi_1) - \frac{|B|}{Z_0} \cos(\omega t +\beta z +\phi_2)<br>$$</p>
<p>基于上式，我们可以获得参数：</p>
<ul>
<li>相速：等相位面移动速度<br>  $$<br>  v_p &#x3D; \frac{\omega}{\beta}&#x3D;\frac{1}{\sqrt{LC}}<br>  $$<blockquote>
<p>注意式中的频率相关参数，代表相速随频率变化，即：色散现象</p>
</blockquote>
</li>
<li>相波长：传输线上等相位点距离<br>  $$<br>  \lambda_p &#x3D; \frac{2\pi}{\beta} &#x3D; \frac{v_p}{f} &#x3D; v_p T &#x3D; \frac{\lambda_0}{\sqrt{\epsilon_r}}<br>  $$</li>
</ul>
<h3 id="传输线终端带载与输入阻抗"><a href="#传输线终端带载与输入阻抗" class="headerlink" title="传输线终端带载与输入阻抗"></a>传输线终端带载与输入阻抗</h3><p>现在，在传输线的终端带有一个负载：</p>
<p>$$<br>Z_L<br>$$</p>
<p>并知道负载上的电流和电压，则可以作为边界条件带入传输线通解得到系数解。在带入前，我们将上面推导得到的以<strong>源端为原点</strong>的通解改写为以<strong>负载端为原点</strong>的形式：</p>
<p>$$<br>U(z) &#x3D; A \cdot e^{j\beta t } + B \cdot e^{-j\beta t}<br>\\<br>I(z) &#x3D; \frac{1}{Z_0} [A\cdot e^{j\beta t } - B \cdot e^{-j\beta t}]<br>$$</p>
<p>带入负载端电压电流条件得：</p>
<p>$$<br>U_L&#x3D;U(0) &#x3D; A+B<br>\\<br>I_L&#x3D;I(0) &#x3D; \frac{1}{Z_0}(A-B)<br>$$</p>
<p>解方程组得：</p>
<p>$$<br>A &#x3D; \frac{U_L+I_LZ_0}{2}<br>\\<br>B &#x3D; \frac{U_L-I_LZ_0}{2}<br>$$</p>
<p>则有电流电压：</p>
<p>$$<br>U(z)&#x3D;U^+(z)+U^-(z)&#x3D;U^+(0)e^{j\beta z} + U^-(0)e^{-j\beta z} ,\\<br>U^+(0) &#x3D; \frac{U_L+I_LZ_0}{2},U^-(0)&#x3D;\frac{U_L-I_LZ_0}{2}, \\<br>I(z) &#x3D; I^+(z)+I^-(z) &#x3D; I^+(0)e^{j\beta z} + I^-(0)e^{-j\beta z} ,\\<br>I^+(0) &#x3D; \frac{U_L+I_LZ_0}{2Z_0},I^-(0)&#x3D;-\frac{U_L-I_LZ_0}{2Z_0}, \\<br>$$</p>
<p>根据上面的结果，我们提出如下概念参数：</p>
<ul>
<li>输入阻抗：带负载的传输线在任一点向负载侧看去的等效阻抗<br>  $$<br>  Z_{in}(z) &#x3D; \frac{U(z)}{I(z)} &#x3D; Z_0\frac{Z_L\cdot \cos(\beta z)+jZ_0\cdot \sin(\beta z)}{Z_0 \cdot \cos(\beta z) + jZ_L \cdot \sin(\beta z)}<br>  $$</li>
<li>输入导纳：显然就是输入阻抗的倒数</li>
<li>电压反射系数：入射波与反射波之比<br>  $$<br>  \Gamma_u &#x3D; \frac{U^-(z)}{U^+(z)} &#x3D; \frac{Z_L - Z_0}{Z_0 + Z_L} e^{-j2\beta z}<br>  $$</li>
<li>电流反射系数<br>  $$<br>  \Gamma_i &#x3D; \frac{I^-(z)}{I^+(z)} &#x3D; \frac{Z_0 - Z_L}{Z_0 + Z_L} e^{-j2\beta z}<br>  $$</li>
<li>驻波比：电压振幅最大值比最小值<br>  $$<br>  \rho &#x3D; \frac{|U(z)|_{\max}}{|U(z)|_{\min}} &#x3D; \frac{1+|\Gamma|}{1-|\Gamma|}<br>  $$</li>
</ul>
<h2 id="阻抗匹配"><a href="#阻抗匹配" class="headerlink" title="阻抗匹配"></a>阻抗匹配</h2><p>这里我们观察输入阻抗关系：</p>
<p>$$<br>Z_{in}(z) &#x3D; Z_0\frac{Z_L\cdot \cos(\beta z)+jZ_0\cdot \sin(\beta z)}{Z_0 \cdot \cos(\beta z) + jZ_L \cdot \sin(\beta z)}<br>$$</p>
<p>如果此时负载阻抗和传输线的特性阻抗一致时：</p>
<p>$$<br>Z_L &#x3D; Z_0<br>\\ \Rightarrow<br>Z_{in}(z) &#x3D; Z_0<br>$$</p>
<p>右边分式的分子和分母是一样的，直接去掉！也就是此时传输线上处处输入阻抗都是相同的。再观察此时的反射系数：</p>
<p>$$<br>\Gamma_u (z)&#x3D; \frac{Z_L - Z_0}{Z_L+Z_0} e^{-j2\beta z} &#x3D; 0<br>$$</p>
<p>反射系数为0！🏹也就是说此时没有反射波，即：</p>
<p>$$<br>U(z) &#x3D; U^+(z)[1+\Gamma_u(z)] &#x3D; U^+(z) &#x3D; U_L e^{j\beta z}<br>$$</p>
<p>此时系统工作于行波状态，那么为什么叫这个时候为“负载匹配”或“阻抗匹配”呢？因为此时系统向负载传输能量的传输功率最大！可由电磁场知识推导传输线上任意点传输功率：</p>
<p>$$<br>P(z) &#x3D; \frac{1}{2}\text{Re}[U(z)I^*(z)] &#x3D; \frac{|U^+(z)|^2}{2Z_0} [1-|\Gamma(z)|^2]<br>$$</p>
<p>则显然当反射系数为0时，传输线传输功率最大。</p>
<blockquote>
<p>阻抗匹配 &#x3D; 反射系统为0 &#x3D; 传输功率最大 &#x3D; 驻波比为1</p>
</blockquote>
<p>那么要做到阻抗匹配，有几种方案：</p>
<ul>
<li>调整负载阻抗与传输线阻抗一致<blockquote>
<p>一般来说，我们的负载是有固定参数对象（比如天线），不能改变。所以这个用的少</p>
</blockquote>
</li>
<li>调整传输线阻抗<blockquote>
<p>简单点说，换线；但如果是PCB上的微带线和带状线，就设计的时候按照目标参数去设计</p>
</blockquote>
</li>
<li>在负载与传输线之间加入阻抗变换器</li>
<li>在传输线上并联枝节匹配器</li>
</ul>
<h2 id="阻抗变换器"><a href="#阻抗变换器" class="headerlink" title="阻抗变换器"></a>阻抗变换器</h2><p>这个思想吧非常简单，就是加个能变换阻抗的东西，把负载阻抗变换成和传输线一样。方案也挺多，变压器啥的笔者也没试过，书上教的是一种比较简单的——四分之波长变换器。还是回忆上面的输入阻抗公式：</p>
<p>$$<br>Z_{in}(z) &#x3D; Z_0\frac{Z_L\cdot \cos(\beta z)+jZ_0\cdot \sin(\beta z)}{Z_0 \cdot \cos(\beta z) + jZ_L \cdot \sin(\beta z)}<br>$$</p>
<p>在终端接负载四分之波长位置处有：</p>
<p>$$<br>z &#x3D; \frac{\lambda}{4}<br>\\ \Rightarrow<br>\beta z &#x3D; \frac{\pi}{2}<br>\\ \Rightarrow<br>Z_{in}(\frac{\lambda}{4}) &#x3D; Z \frac{Z}{Z_L}<br>$$</p>
<p>所以，如果我们在负载和传输线之间加入一段匹配线长度四分之波长特征阻抗为：</p>
<p>$$<br>Z &#x3D; \sqrt{Z_0Z_L}<br>$$</p>
<p>则即可使得整个系统获得阻抗匹配。</p>
<h2 id="枝节匹配器"><a href="#枝节匹配器" class="headerlink" title="枝节匹配器"></a>枝节匹配器</h2><p><img src="https://blog-img-goryj.oss-rg-china-mainland.aliyuncs.com/blogpost/20210625-IM-6.png" alt="枝节匹配"></p>
<p>枝节匹配器的结构如上图所示，就是在传输线上的某个位置并联一段终端开路（短路也行）的传输线，来调节系统匹配。</p>
<blockquote>
<p>接下来的分析是笔者的个人推导结果，后续有空再写写教科书上的“史密斯”圆图法</p>
</blockquote>
<p>教科书上推荐使用终端短路线（笔者也不知道为什么），但是根据这次的实际案例，如果使用短路线，TTL电平电路有大量直流分量会导致调试器损坏。所以笔者接下来讨论的是本次使用的终端开路线，首先我们先导出终端开路线的输入导纳（阻抗倒数）：</p>
<p>$$<br>Y_{in}(z) &#x3D; Y_0 \frac{Y_L+jY_0 \tan(\beta z)}{Y_0+jY_L \tan(\beta z)} &#x3D; jY_0\tan(\beta z)<br>$$</p>
<p>为了防止下面推导的时候符号歧义，我们把上式用终端开路枝节匹配器的特征导纳符号重写：</p>
<p>$$<br>Y_{in-1}(z) &#x3D; jY_1\tan(\beta z)<br>$$</p>
<p>那么，根据上面的枝节匹配器电路结构图和阻抗匹配原理，我们知道在枝节插入位置有插入后等效导纳和左端传输线导纳相等的要求，即：</p>
<p>$$<br>Y_0 &#x3D; Y_{in-1}(l_3) + Y_{in-L}(l_2)<br>$$</p>
<p>考虑上面的终端开路枝节能提供的导纳，只有虚部没有实部，所以显然插入后的实部部分只能由不同插入位置决定，而虚部可以用插入枝节的长度进行调节。为了方便分析，我们对上式以传输线特征导纳作归一化处理：</p>
<p>$$<br>1 &#x3D; \frac{Y_0}{Y_0} &#x3D; \frac{ Y_{in-1}(l_3)}{Y_0} + \frac{ Y_{in-L}(l_2)}{Y_0} &#x3D; j\frac{Y_1}{Y_0}tan(\beta l_3) + \tilde{Y}_{in-L}(l_2)<br>$$</p>
<p>其中</p>
<p>$$<br>\tilde{Y}_{in-L}(l_2) &#x3D; \frac{Y_L+jY_0 \tan(\beta l_2)}{Y_0+jY_L \tan(\beta l_2)}  &#x3D; \tilde{G}+ j \tilde{B}<br>$$</p>
<p>即显然有：</p>
<p>$$<br>1&#x3D; j\frac{Y_1}{Y_0}tan(\beta l_3) + \tilde{G}+ j \tilde{B}<br>\\<br>\tilde{G} &#x3D; \frac{Y_LY_0+Y_LY_0\tan^2(\beta l_2)}{Y_0^2 + Y_L^2\tan^2(\beta l_2)} &#x3D; 1<br>\\<br>\tilde{B} &#x3D; \frac{Y_0^2 \tan(\beta l_2)-Y_L^2\tan(\beta l_2)}{Y_0^2+Y_L^2\tan^2(\beta l_2)} &#x3D; -\frac{Y_1}{Y_0}tan(\beta l_3)<br>$$</p>
<p>即可解得：</p>
<p>$$<br>l_2 &#x3D; \frac{1}{\beta}\arctan(\sqrt{\frac{Y_0}{Y_L}})<br>\\<br>l_3 &#x3D;  \frac{1}{\beta} \arctan(\frac{Y_L-Y_0}{Y_1}\sqrt{\frac{Y_0}{Y_L}})<br>$$</p>
<h2 id="工程实用公式"><a href="#工程实用公式" class="headerlink" title="工程实用公式"></a>工程实用公式</h2><ul>
<li>带载传输线的输入阻抗<br>  $$<br>  Z_{in}(z) &#x3D; \frac{U(z)}{I(z)} &#x3D; Z_0\frac{Z_L\cdot \cos(\beta z)+jZ_0\cdot \sin(\beta z)}{Z_0 \cdot \cos(\beta z) + jZ_L \cdot \sin(\beta z)}<br>  $$</li>
<li>反射系数<br>  $$<br>  \Gamma_u &#x3D; \frac{U^-(z)}{U^+(z)} &#x3D; \frac{Z_L - Z_0}{Z_0 + Z_L} e^{-j2\beta z}<br>  $$</li>
<li>四分之波长匹配器特征阻抗<br>  $$<br>  Z &#x3D; \sqrt{Z_0Z_L}<br>  $$</li>
<li>枝节匹配器<br>  $$<br>  插入点l_2 &#x3D; \frac{1}{\beta}\arctan(\sqrt{\frac{Y_0}{Y_L}})<br>  \\<br>  支线长度l_3 &#x3D;  \frac{1}{\beta} \arctan(\frac{Y_L-Y_0}{Y_1}\sqrt{\frac{Y_0}{Y_L}})<br>  $$</li>
</ul>
]]></content>
      <categories>
        <category>硬件&amp;物理</category>
      </categories>
      <tags>
        <tag>阻抗匹配</tag>
      </tags>
  </entry>
  <entry>
    <title>六轴传感器（ICM42688）驱动及姿态估计</title>
    <url>/2022/07/28/ICM42688P-DrvBySPI/</url>
    <content><![CDATA[<blockquote>
<p>前言：打算给小巡洋舰搞点花活，顺便做个飞控，记录一下其中最为关键的惯性导航（IMU）。本次项目中使用的是TDK出的最新MEMS传感器以提高项目的生命周期，因此本文将先简单介绍ICM42688这个片子，接着探讨SPI驱动方法，最后记录六轴MEMS传感器的工作原理。</p>
</blockquote>
<h2 id="ICM42688简介"><a href="#ICM42688简介" class="headerlink" title="ICM42688简介"></a>ICM42688简介</h2><p><img src="https://blog-img-goryj.oss-rg-china-mainland.aliyuncs.com/blogpost/20220728-ICM42688SPI-1.png" alt="ICM42688芯片"></p>
<p>这款6轴MEMS运动跟踪传感器内有一个三轴陀螺仪和一个三轴加速度计，通信方面支持I3C接口、常规的IIC、SPI通信和2kB的FIFO，并且按照TDK的老传统这个片子里也是带数字处理单元的。这个片子目前算是消费电子里的顶流了，参数如下：</p>
<ul>
<li>陀螺仪噪声密度：$0.0028°&#x2F;s&#x2F;\sqrt{Hz}$</li>
<li>加速度计噪声密度：$70\mu g&#x2F;\sqrt{Hz}$</li>
<li>8档陀螺仪量程：$\pm15.6 \sim 2000dps$</li>
<li>4档加速度计量程：2&#x2F;4&#x2F;8&#x2F;16g</li>
<li>前端ADC精度：16bits</li>
<li>SPI通信速率达24MHz</li>
<li>最后，温漂参数也是非常不错：<ul>
<li>陀螺仪SSF-Temp为$\pm 0.005 % &#x2F;° C$，ZRO-Temp为$\pm 0.005 °&#x2F;s&#x2F;° C$</li>
<li>加速度计SSF-Temp为$\pm 0.005 % &#x2F;°C$，ZGO-Temp为$\pm 0.15 mg&#x2F;° C$</li>
</ul>
</li>
</ul>
<p>至于内置的APEX数字运动处理器也是非常优秀了，可以说是针对消费电子设计的，支持检测拿起、记录步数、倾斜测试等。这些功能在机器人应用上虽然犹如鸡肋，但是应该可以做一些花活。</p>
<h2 id="SPI总线"><a href="#SPI总线" class="headerlink" title="SPI总线"></a>SPI总线</h2><span id="more"></span>

<p>SPI总线在高速板载外设的通信中，极为常见。标准的4线SPI的信号线有：</p>
<ul>
<li>片选信号线<em>NSS</em>（或CS、CSB）：SPI标准允许一套总线上挂载多个设备，但是通信时只能有一个设备与主机通信，也就是片选被使能（拉低）的外设；</li>
<li>同步时钟线<em>SCLK</em>（或SCK）：在下面将会看到，数据线上的信号将在时钟线的上下边沿被采集或放置，多个从机时该线共享；</li>
<li>主机收从机发数据线<em>MISO</em>（或SDO）：全称Master Input Slave Output，作用很显然了，串行发至主机的数据线，多个从机时该线共享；</li>
<li>主机发从机收数据线<em>MOSI</em>（或SDI）：全称Master Output Slave Input，类似的，串行发至从机的数据线，多个从机时该线共享；</li>
</ul>
<blockquote>
<p>⚠️SPI总线属于有时钟的同步总线，因此在布线时应该严格按<em>等长线设计</em>；但一般无需做阻抗匹配</p>
</blockquote>
<p><img src="https://blog-img-goryj.oss-rg-china-mainland.aliyuncs.com/blogpost/20220728-ICM42688SPI-2.png" alt="SPI总线"></p>
<p>在STM32等MCU上，SPI外设的配置十分灵活，如上所示可以配置出最少4种类型的SPI通信方式，并由参数<em>CPOL</em>和<em>CPHA</em>配置：</p>
<ul>
<li>CPOL(Clock Polarity)表示时钟线<em>SCLK</em>在空闲状态时的信号电平。</li>
<li>CPHA(Clock Phase)表示数据线<em>MOSI</em>和<em>MISO</em>在哪个时钟沿捕获数据。如上图所示，当该参数为<code>1Edge</code>时，设备在第一个时钟跳变沿采样数据；当该参数为<code>2Edge</code>时，设备在第二个时钟跳变沿采样数据。</li>
</ul>
<h3 id="ICM42688的SPI标准"><a href="#ICM42688的SPI标准" class="headerlink" title="ICM42688的SPI标准"></a>ICM42688的SPI标准</h3><p><img src="https://blog-img-goryj.oss-rg-china-mainland.aliyuncs.com/blogpost/20220728-ICM42688SPI-3.png" alt="外设SPI时序"></p>
<p>上图为截取自42688数据手册的SPI时序图，显然片选信号<em>CS</em>和时钟信号<em>SCLK</em>在空闲时都为高电平，数据线<em>SDI</em>和<em>SDO</em>在每个周期的第一个边沿放置数据及第二个边沿采样数据。因此CPOL&#x3D;High(<code>1</code>)，CPHA&#x3D;2Edge(<code>1</code>)。</p>
<h2 id="底层驱动代码"><a href="#底层驱动代码" class="headerlink" title="底层驱动代码"></a>底层驱动代码</h2><p><img src="https://blog-img-goryj.oss-rg-china-mainland.aliyuncs.com/blogpost/20220728-ICM42688SPI-4.png" alt="ICM42688原理图"></p>
<p>本文接下来开发的驱动程序都是基于上原理图实现的硬件进行配置，为<code>FOSH</code>计划中的<code>GUAV</code>通用无人空中飞行器项目。采样标准4线SPI通信的方式，并使用1个中断线和一个外部32.768kHz的标准时钟（来自MCU的内部时钟共享，以提高数据同步性），另外添加PWM控制的加热恒温功能以防止低温环境带来的误差。</p>
<p><img src="https://blog-img-goryj.oss-rg-china-mainland.aliyuncs.com/blogpost/20220728-ICM42688SPI-5.png" alt="驱动特性"></p>
<p>在ICM42688P的数据手册上，我们看到该片的SPI使用时为：</p>
<ul>
<li>先发高位（MSB first）</li>
<li>上升沿采样（与上面SPI小节中传输时序一致）</li>
<li>读写时都是主机先发（MOSI）的第一个字节为地址信息，且该字节的最高位表示读写指令（读是1，写是0）</li>
</ul>
<p>根据这些信息来配置MCU，笔者使用的为STM32H750VBT6，使用官方工具CubeMX配置SPI参数具体如下：</p>
<p><img src="https://blog-img-goryj.oss-rg-china-mainland.aliyuncs.com/blogpost/20220728-ICM42688SPI-6.png" alt="STM32配置"></p>
<p>在CubeMX生成的项目中，可以编写如下代码读写ICM42688P的寄存器，并测试连续读写功能：</p>
<blockquote>
<p>基于该测试代码和上面的原理图（等长布线），经实际上板测试，在225kHz~22.5MHz的时钟（波特率）范围内都可以稳定通信（SPI官方最高速率指标为24MHz）</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;bsp.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;string.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ICM42xxx_HSPI hspi2</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ICM42xxx_BUFFER_LEN 16</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ICM42xxx_SPI_NSS_HIGH()  HAL_GPIO_WritePin(SPI2_NSS4IMU_GPIO_Port, SPI2_NSS4IMU_Pin, GPIO_PIN_SET)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ICM42xxx_SPI_NSS_LOW()   HAL_GPIO_WritePin(SPI2_NSS4IMU_GPIO_Port, SPI2_NSS4IMU_Pin, GPIO_PIN_RESET)</span></span><br><span class="line"></span><br><span class="line"><span class="type">uint8_t</span> icm42xxx_spi_tx [ICM42xxx_BUFFER_LEN] =&#123;<span class="number">0xff</span>&#125;;</span><br><span class="line"><span class="type">uint8_t</span> icm42xxx_spi_rx [ICM42xxx_BUFFER_LEN] =&#123;<span class="number">0xff</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">uint8_t</span> testCache[<span class="number">4</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">/*****************************************************</span></span><br><span class="line"><span class="comment">以下为寄存器读写接口</span></span><br><span class="line"><span class="comment">*****************************************************/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * @brief  向指定寄存器写入数据</span></span><br><span class="line"><span class="comment">  * @note		这个芯片只能单次写，不支持突发写</span></span><br><span class="line"><span class="comment">  * @param  reg_addr:  写入寄存器地址</span></span><br><span class="line"><span class="comment">  *          value: 写入的数据</span></span><br><span class="line"><span class="comment">  * @retval 0正常；及其他错误代码</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"><span class="type">uint32_t</span> <span class="title function_">icm42xxx_spi_master_write_register</span><span class="params">(<span class="type">uint8_t</span> reg_addr, <span class="type">uint8_t</span> value)</span></span><br><span class="line">&#123;</span><br><span class="line">	ICM42xxx_SPI_NSS_LOW();	<span class="comment">// 软件使能</span></span><br><span class="line">	icm42xxx_spi_tx[<span class="number">0</span>] = reg_addr &amp; <span class="number">0x7F</span>;	<span class="comment">// 写入时，寄存器地址字节的第一位为 0；0x7f &lt;-&gt; 01111111</span></span><br><span class="line">	icm42xxx_spi_tx[<span class="number">1</span>] = value;	<span class="comment">// MOSI上第二个字节为写入的数据</span></span><br><span class="line">	</span><br><span class="line">	HAL_SPI_TransmitReceive(&amp;ICM42xxx_HSPI,</span><br><span class="line">	                       &amp;icm42xxx_spi_tx[<span class="number">0</span>],</span><br><span class="line">	                       &amp;icm42xxx_spi_rx[<span class="number">0</span>], <span class="number">2</span>,</span><br><span class="line">	                       <span class="number">0XFF</span>);</span><br><span class="line">	ICM42xxx_SPI_NSS_HIGH();</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * @brief  读取指定寄存器or一堆寄存器数据</span></span><br><span class="line"><span class="comment">  * @note   支持突发（连续）读</span></span><br><span class="line"><span class="comment">	* @param  reg_addr:  读取数据的起始地址</span></span><br><span class="line"><span class="comment">  *          pData:     返回的数据</span></span><br><span class="line"><span class="comment">  *          len:    读取的数字长度</span></span><br><span class="line"><span class="comment">  * @retval 0正常；及其他错误代码</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"><span class="type">uint32_t</span> <span class="title function_">icm42xxx_spi_master_read_register</span><span class="params">(<span class="type">uint8_t</span> reg_addr, <span class="type">uint8_t</span>* pData, <span class="type">uint8_t</span> len)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span>(len&gt;ICM42xxx_BUFFER_LEN<span class="number">-1</span>)</span><br><span class="line">		<span class="keyword">return</span> <span class="number">1</span>;	<span class="comment">// 超出缓存空间！</span></span><br><span class="line">	</span><br><span class="line">	ICM42xxx_SPI_NSS_LOW();</span><br><span class="line">	icm42xxx_spi_tx[<span class="number">0</span>] = reg_addr | <span class="number">0x80</span>;	<span class="comment">// 读取时，寄存器地址字节的第一位为 1</span></span><br><span class="line">	<span class="built_in">memset</span>(icm42xxx_spi_tx+<span class="number">1</span>,<span class="number">0x00</span>,len);	<span class="comment">// 接收数据时，注意MOSI上不能再发地址，否则会破坏突发读的地址连续性</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span>( HAL_SPI_TransmitReceive(&amp;ICM42xxx_HSPI,</span><br><span class="line">	                             &amp;icm42xxx_spi_tx[<span class="number">0</span>],</span><br><span class="line">	                             &amp;icm42xxx_spi_rx[<span class="number">0</span>], len+<span class="number">1</span>,</span><br><span class="line">	                             <span class="number">0XFF</span>)</span><br><span class="line">		 != HAL_OK) <span class="comment">//因为先发地址后读数据，因此这里长度是len+1</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">2</span>;	<span class="comment">// SPI读取操作出错</span></span><br><span class="line">	&#125;</span><br><span class="line">	ICM42xxx_SPI_NSS_HIGH();</span><br><span class="line">	<span class="built_in">memcpy</span>(pData,icm42xxx_spi_rx+<span class="number">1</span>,len);</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * @brief  通信测试</span></span><br><span class="line"><span class="comment">  * @note   测试单次读取芯片ID，和连续读</span></span><br><span class="line"><span class="comment">  * @param  </span></span><br><span class="line"><span class="comment">  * @retval 0测试通过；及其他错误代码</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"><span class="type">uint32_t</span> <span class="title function_">icm42xxx_spi_master_communicate_test</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="meta">#<span class="keyword">define</span> ICM42XXX_REGADDR_WHO_AM_I (0x75)	<span class="comment">// 不同芯片读出来的ID值不一样，42688P是0x47</span></span></span><br><span class="line">	<span class="meta">#<span class="keyword">define</span> ICM42XXX_REGVAL_WHO_AM_I (0x47)</span></span><br><span class="line">	<span class="meta">#<span class="keyword">define</span> ICM42XXX_REGADDR_ACCEL_WOM_Y_THR (0x4B)</span></span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">	icm42xxx_spi_master_read_register(ICM42XXX_REGADDR_WHO_AM_I, testCache, <span class="number">1</span>);	<span class="comment">// 读取身份信息寄存器</span></span><br><span class="line">	</span><br><span class="line">	<span class="keyword">if</span>(testCache[<span class="number">0</span>] != ICM42XXX_REGVAL_WHO_AM_I)	<span class="comment">// 身份核验</span></span><br><span class="line">		<span class="keyword">return</span> <span class="number">1</span>;	<span class="comment">// 表示读取身份错误</span></span><br><span class="line">	</span><br><span class="line">	icm42xxx_spi_master_write_register(<span class="number">0x11</span>,<span class="number">0x01</span>);	<span class="comment">// 软件复位</span></span><br><span class="line">	HAL_Delay(<span class="number">2</span>);	<span class="comment">// 要等待最少1ms</span></span><br><span class="line">	icm42xxx_spi_master_read_register(ICM42XXX_REGADDR_ACCEL_WOM_Y_THR, testCache, <span class="number">2</span>);		<span class="comment">// 连读WOM_Y_TH、WOM_Z_TH</span></span><br><span class="line">	<span class="comment">/********************************</span></span><br><span class="line"><span class="comment">	BUG REPORT:</span></span><br><span class="line"><span class="comment">	调试过程中，发现不能连续操作3个字节</span></span><br><span class="line"><span class="comment">	目前还没找到原因！</span></span><br><span class="line"><span class="comment">	可能原因：</span></span><br><span class="line"><span class="comment">	1. 这几个寄存器之间不支持连读写</span></span><br><span class="line"><span class="comment">	   需要连续原厂才有答案</span></span><br><span class="line"><span class="comment">	2. 硬件时序偏移，使用高精度DLA可知</span></span><br><span class="line"><span class="comment">	********************************/</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">2</span>;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		testCache[i] += <span class="number">0x15</span>;	<span class="comment">// 随机变个数据</span></span><br><span class="line">		HAL_Delay(<span class="number">1</span>);</span><br><span class="line">		icm42xxx_spi_master_write_register((ICM42XXX_REGADDR_ACCEL_WOM_Y_THR + i), testCache[i]);	<span class="comment">// 写入数据</span></span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	HAL_Delay(<span class="number">1</span>);</span><br><span class="line">	icm42xxx_spi_master_read_register(ICM42XXX_REGADDR_ACCEL_WOM_Y_THR, testCache+<span class="number">2</span>, <span class="number">2</span>);	<span class="comment">// 再读一次</span></span><br><span class="line">	</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">2</span>;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span>(testCache[i] != testCache[i+<span class="number">2</span>])	<span class="comment">// 检验连续读写的正确性</span></span><br><span class="line">			<span class="keyword">return</span> <span class="number">2</span>;	<span class="comment">// 表示连续读写错误</span></span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;	<span class="comment">// 表示测试通过</span></span><br><span class="line">	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="姿态解算算法"><a href="#姿态解算算法" class="headerlink" title="姿态解算算法"></a>姿态解算算法</h2><p>一般用直观的<strong>欧拉角</strong>来表示机体姿态，但是解算过程中，由于欧拉角的万向锁问题，人们使用<strong>四元数</strong>作为主要数学工具。</p>
<h3 id="四元数"><a href="#四元数" class="headerlink" title="四元数"></a>四元数</h3><p>这是类似于复数的工具，但虚部是$\mathbb R^3$空间向量$\mathbf q_v&#x3D;[q_1,q_2,q_3]^T$，一般写为：</p>
<p>$$<br>\mathbf q \triangleq \begin{bmatrix}<br> q_0 \\<br> \mathbf q_v<br>\end{bmatrix}<br>$$</p>
<p>具有性质：</p>
<ul>
<li>加减法（显然满足交换律）<br>  $$<br>  \mathbf{p} \pm \mathbf{q} &#x3D;<br>  \begin{bmatrix}<br>  p_0 \\ \mathbf p_v<br>  \end{bmatrix} \pm<br>  \begin{bmatrix}<br>  q_0 \\ \mathbf q_v<br>  \end{bmatrix} &#x3D;<br>  \begin{bmatrix}<br>  p_0\pm q_0 \\ \mathbf p_v\pm \mathbf q_v<br>  \end{bmatrix}<br>  $$</li>
<li>乘法（不能交换次序，但有分配律和结合律）<br>  $$<br>  \mathbf p\otimes \mathbf q &#x3D;<br>  \begin{bmatrix}<br>  p_0 \\ \mathbf p_v<br>  \end{bmatrix} \otimes<br>  \begin{bmatrix}<br>  q_0 \\ \mathbf q_v<br>  \end{bmatrix} &#x3D;<br>  \begin{bmatrix}<br>  p_0q_0-\mathbf q_v^T \mathbf p_v \\ \mathbf p_v\times \mathbf q_v + p_0 \mathbf q_v + q_0 \mathbf p_v<br>  \end{bmatrix}<br>  \\<br>  \mathbf q \otimes (\mathbf r+\mathbf m) &#x3D; \mathbf q\otimes \mathbf r + \mathbf q \otimes \mathbf m<br>  \\<br>  \mathbf q \otimes \mathbf r \otimes \mathbf m &#x3D; (\mathbf q \otimes \mathbf r) \otimes \mathbf m &#x3D;\mathbf q \otimes (\mathbf r \otimes \mathbf m )<br>  $$</li>
<li>数乘<br>  $$<br>  s\mathbf q &#x3D; \mathbf q s &#x3D; \begin{bmatrix} sq_0 \\ s\mathbf q_v \end{bmatrix}<br>  $$</li>
<li>共轭（和复数类似，都是虚部反）<br>  $$<br>  \mathbf q^* &#x3D; \begin{bmatrix} q_0 \\ -\mathbf q_v \end{bmatrix}<br>  \\<br>  (\mathbf q \otimes \mathbf p)^* &#x3D; \mathbf p^* \otimes \mathbf q^*<br>  $$</li>
<li>范数<br>  $$<br>  \Vert \mathbf q \Vert  &#x3D; \sqrt{q_0^2 + \mathbf q_v^T\mathbf q_v} &#x3D; \sqrt{\Vert \mathbf q \otimes \mathbf q^*\Vert}<br>  $$</li>
<li>逆<br>  $$<br>  \mathbf q \otimes \mathbf q^{-1} &#x3D; \begin{bmatrix}<br>  1 \\<br>  \mathbf 0_{3\times 1}<br>  \end{bmatrix} \\<br>  \mathbf q^{-1} &#x3D; \frac{\mathbf q^*}{\Vert \mathbf q \Vert}<br>  $$</li>
</ul>
<p>以上就是四元数的基本性质，接下来我们将这个工具往需要的姿态解算上带。首先，从四元数的范数计算，我们类似单位向量一般的，定义单位四元数$\Vert \mathbf q\Vert &#x3D; 1$，这是因为单位化之后的四元数们具有优秀的计算性质：</p>
<p>$$<br>\forall . \Vert \mathbf q \Vert &#x3D;\Vert \mathbf p \Vert &#x3D;1<br>\\<br>\Rightarrow \Vert \mathbf q \otimes \mathbf p \Vert &#x3D; 1<br>\\<br>\mathbf q^{-1} &#x3D; \mathbf q^{*}<br>$$</p>
<p>然后我们观察到四元数$\mathbf q$是由一个标量$q_0$和一个空间向量$\mathbf q_v$组成，如果把一个旋转过程记录为绕$\mathbf v$轴（右手螺旋系）旋转$\theta_0$角度，那么看起来恰好可以用四元数来表示🧐但是人们发现直接这样带进去的话，算起来还是不好用！然后就有人发现，可以把旋转过程和四元数对应为：</p>
<p>$$<br>\mathbf q &#x3D; \begin{bmatrix}<br>\cos\frac \theta 2 \\<br>\mathbf v \sin\frac \theta 2<br>\end{bmatrix},<br>\Vert \mathbf v \Vert &#x3D;1<br>$$</p>
<p>首先，这样映射的话就成了单位四元数啦，求逆很方便！然后将空间方向向量$\mathbf v_1$用一个四元数表示：<br>$$<br>\mathbf p &#x3D; \begin{bmatrix}<br>0 \\<br>\mathbf v_1<br>\end{bmatrix}<br>$$</p>
<p>则该空间向量经过一个$\mathbf q$的旋转过程（绕$\mathbf v$转$\theta$角），经证明，可采用下式计算旋转后的空间姿态$\mathbf v_1’$：</p>
<p>$$<br>\begin{bmatrix}<br>0 \\ \mathbf v_1’<br>\end{bmatrix} &#x3D; \mathbf q \otimes \mathbf p \otimes \mathbf q^{-1} &#x3D;<br>\begin{bmatrix}<br>\cos\frac \theta 2 \\<br>\mathbf v \sin\frac \theta 2<br>\end{bmatrix} \otimes<br>\begin{bmatrix}<br>0 \\<br>\mathbf v_1<br>\end{bmatrix} \otimes<br>\begin{bmatrix}<br>\cos\frac \theta 2 \\<br>-\mathbf v \sin\frac \theta 2<br>\end{bmatrix}<br>$$</p>
<blockquote>
<p>读者可以直接记下该<em><strong>重要公式</strong></em>，有余力可结合文末的推荐参考文献自行推导具体过程。</p>
</blockquote>
<h3 id="四元数旋转计算过程矩阵化"><a href="#四元数旋转计算过程矩阵化" class="headerlink" title="四元数旋转计算过程矩阵化"></a>四元数旋转计算过程矩阵化</h3><p>除了四元数外，这里也介绍一下它的好兄弟——旋转矩阵：</p>
<p>$$<br>\mathbf v_e &#x3D; \mathbf R ^e_b \cdot \mathbf v_b<br>\\<br>\mathbf R^e_b \in SO(3),SO(3) &#x3D; { \mathbf R | \mathbf R^T \mathbf R &#x3D; \mathbf I_3, det(\mathbf R) &#x3D; 1,\mathbf R \in \mathbb R_{3\times 3} }<br>$$</p>
<p>虽然用不上，但是这里为啥要介绍旋转矩阵呢，因为优秀的先人就是从这个旋转矩阵的变换中，观察到四元数空间旋转计算过程和旋转矩阵计算极为像！前提是我们要把四元数旋转计算过程进行矩阵化（毕竟不矩阵化，计算机也算不了这玩意），四元数乘法计算可以转为：</p>
<p>$$<br>\mathbf p\otimes \mathbf q &#x3D; \mathbf p^+ \cdot \mathbf q &#x3D;  \mathbf q^-  \cdot \mathbf p<br>$$</p>
<p>上式矩阵乘法中，将一个四元数直接作为$\mathbb R_{4}$向量，另一个四元数与四元数乘法符号一起转换为一个$\mathbb R_{4\times 4}$等效矩阵：</p>
<p>$$<br>\mathbf p^{+} &#x3D; p_0 \mathbf I_4 +<br>\begin{bmatrix}<br>0 &amp; -\mathbf p_v^T<br>\\<br>\mathbf p_v &amp; [\mathbf p_v]_\times<br>\end{bmatrix}<br>$$<br>$$<br>\mathbf q^{-} &#x3D; q_0 \mathbf I_4 +<br>\begin{bmatrix}<br>0 &amp; -\mathbf q_v^T<br>\\<br>\mathbf q_v &amp; - [\mathbf q_v]_\times<br>\end{bmatrix}<br>$$</p>
<p>其中，$[\mathbf p_v]_\times$是$\mathbf p_v$叉乘计算的矩阵点乘表示：</p>
<p>$$<br>\mathbf p_v \times \mathbf a &#x3D; [\mathbf p_v]_\times \mathbf a,因此<br>[\mathbf p_v]_\times &#x3D;<br>\begin{bmatrix}<br>0 &amp; -p_3 &amp; p_2<br>\\<br>p_3 &amp; 0 &amp; -p_1<br>\\<br>-p_2 &amp; p_1 &amp; 0<br>\end{bmatrix}<br>$$</p>
<p>因此四元数旋转计算过程可以矩阵化为：</p>
<p>$$<br>\begin{bmatrix}<br>0 \\ \mathbf v_{1}’<br>\end{bmatrix} &#x3D; \mathbf q \otimes<br>\begin{bmatrix}<br>0 \\<br>\mathbf v_{1}<br>\end{bmatrix} \otimes \mathbf q^* &#x3D;<br>\mathbf q^{+} \cdot \mathbf q^{* -} \cdot<br>\begin{bmatrix}<br>0 \\<br>\mathbf v_{1}<br>\end{bmatrix}<br>$$<br>$$<br>\Rightarrow<br>\begin{bmatrix}<br>0 \\ \mathbf v_1’<br>\end{bmatrix} &#x3D;<br>\begin{bmatrix}<br>q_0 &amp; -\mathbf q_v^T<br>\\<br>\mathbf q_v &amp; q_0\mathbf I_3 + [\mathbf q_v]_\times<br>\end{bmatrix}<br>\begin{bmatrix}<br>q_0 &amp; +\mathbf q_v^T<br>\\<br>-\mathbf q_v &amp; q_0\mathbf I_3 + [\mathbf q_v]_\times<br>\end{bmatrix}<br>\begin{bmatrix}<br>0 \\<br>\mathbf v_1<br>\end{bmatrix}<br>$$</p>
<p>在这个过程中，由于变换对象和结果对象四元数的实数部分都是0，所以如下我们可以把与0操作的部分直接去掉，则得到如下类似旋转矩阵的变换形式：</p>
<p>$$<br>\mathbf v_1’ &#x3D;<br>\begin{bmatrix}<br>q_0^2+q_1^2-q_2^2-q_3^2 &amp; 2(q_1q_2-q_0q_3) &amp; 2(q_1q_3+q_0q_2)<br>\\<br>2(q_1q_2+q_0q_3) &amp; q_0^2-q_1^2+q_2^2-q_3^2 &amp;2(q_2q_3-q_0q_1)<br>\\<br>2(q_1q_3-q_0q_2) &amp; 2(q_2q_3+q_0q_1) &amp; q_0^2-q_1^2-q_2^2+q_3^2<br>\end{bmatrix} \cdot<br>\mathbf v_1<br>$$</p>
<h3 id="六轴数据→四元数→姿态估计"><a href="#六轴数据→四元数→姿态估计" class="headerlink" title="六轴数据→四元数→姿态估计"></a>六轴数据→四元数→姿态估计</h3><p>姿态估计算法的<strong>最终目标</strong>通常就是<strong>欧拉角</strong>，因为欧拉角的物理概念很直观很好理解，方便设计多旋翼等类型的控制系统。而中间计算过程，上面通过对四元数的介绍，我们知道肯定是用这种优秀的工具。当机体停在平地上开机，接着开始运动，我们可以分别从3轴陀螺仪、3轴加速度计获得两套姿态：</p>
<ol>
<li><p>陀螺仪数据获得姿态</p>
<p> 这里我们将传感器返回的3轴陀螺仪数据记为：<br> $$<br> \omega &#x3D;<br> \begin{bmatrix}<br> \omega_x \\<br> \omega_y \\<br> \omega_z<br> \end{bmatrix}<br> $$</p>
<p> 显然，对角速度进行积分就可以直接得到姿态，但从长远来看，我们需要把积分过程用四元数来算才行。从四元数的性质推导得到四元数的微分方程：</p>
<p> $$<br> \dot{\mathbf q}  &#x3D; \frac 12 \mathbf q \otimes<br> \begin{bmatrix}<br> 0 \\<br> \omega<br> \end{bmatrix}<br> $$</p>
<p> 所以陀螺仪估计姿态，在MCU中的离散式计算方程为：</p>
<p> $$<br> \mathbf q_t &#x3D; \mathbf q_{t-1}  + \frac 12 \mathbf q_{t-1} \otimes<br> \begin{bmatrix}<br> 0 \\<br> \omega<br> \end{bmatrix} \Delta t<br> $$</p>
<p> 式中$\Delta t$为定采样&#x2F;计算迭代的周期时长。一个纯积分的系统，都必然是会发散的！这也是用陀螺仪测量的问题，如果一直迭代上式，就算是静止放着，角速度测量时的噪声、误差等都会不断累积，也就是大家常说的“漂移”。</p>
</li>
<li><p>加速度计数据获得姿态</p>
<p> 类似的，我们把传感器得到的3轴加速度计数据记为：</p>
<p> $$<br> \mathbf a &#x3D;<br> \begin{bmatrix}<br> a_x \\<br> a_y \\<br> a_z<br> \end{bmatrix}<br> $$</p>
<p> 当我们把传感器<em>静止</em>放在一个<em>水平面</em>上时，显然受到重力的作用，测量的结果应该是当地的重力加速度$\mathbf g &#x3D; [0,0,g]^T$；而在其他姿态<em>静止</em>情况下，我们通过勾股定理可以得到：</p>
<p> $$<br> a_x &#x3D; -g \sin \theta \\<br> a_y &#x3D; g \cos \theta \sin \phi \\<br> a_z &#x3D; g \cos \theta \cos \phi<br> $$</p>
<p> 多么美妙方便呀，可以直接得到两个姿态角$\theta &#x3D; \arcsin(\frac {a_x}{-g})$和$\phi &#x3D; \arctan(\frac{a_y}{a_z})$。是的，非常遗憾，得不到偏航角！并且还有其他问题，比如载体运动时测量结果带有运动加速度、加速度噪声等。</p>
</li>
</ol>
<p>通过上面直接用原始数据求解姿态，我们就得到了一句流传于世的经典名言：陀螺仪测量结果高频特性好，加速度计测量结果低频特性好。展开来说呢，就是陀螺仪因为积分漂移的问题，看总体的话测量结果会越来越差，但是局部测量的姿态（角速度）可靠性高；而加速度恰恰相反，没有漂移问题，但是局部测量结果估计的姿态存在较大干扰和噪声。所以，工程师们达成了一个共识，陀螺仪和加速计配合起来用就叫做一个完美！（当然，还有个缺陷就是偏航角测量问题，得加地磁计）那么就要设计一套多传感器数据融合估计姿态算法了，接下来开始介绍一套常用的6轴传感器估计姿态算法。</p>
<blockquote>
<p>这里接下来讨论的其实是<strong>Mahony算法</strong>！还有很多其他优秀的姿态估计算法，只是本文写不下而已！</p>
</blockquote>
<p><img src="https://blog-img-goryj.oss-rg-china-mainland.aliyuncs.com/blogpost/20220728-ICM42688SPI-7.png" alt="Mahony算法框图"></p>
<p>图中$_b \vec a$和$_b\vec \omega$分别表示传感器测量得到的加速度和角速度，由于传感器是安装在机体上的，所以这里使用前下角标“$_b$”进行注明，并考虑图片分辨率问题使用头戴箭头的方式替代本文中的粗体来表示矢量。</p>
<p>这个算法融合的原理简单来说，就是用PI控制器去调整四元数离散微分方程中的角速度，补偿的依据（误差）是加速度计测量得到的向量与估计姿态下的重力方向做叉乘，这个误差的定义也就是这个算法的精髓。可以看出算法框图中是一个闭环结构，所以最后算法收敛的目标就是陀螺仪估计得到的姿态应该接近&#x2F;等于加速度计估计的姿态。</p>
<h3 id="Mahony姿态估计实现代码"><a href="#Mahony姿态估计实现代码" class="headerlink" title="Mahony姿态估计实现代码"></a>Mahony姿态估计实现代码</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> sampleFreq	1000.0f			<span class="comment">// 采样率（ Hz ）</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> twoKpDef	(2.0f * 0.5f)	<span class="comment">// 2 * proportional gain</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> twoKiDef	(2.0f * 0.0f)	<span class="comment">// 2 * integral gain</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">volatile</span> <span class="type">float</span> twoKp = twoKpDef;											<span class="comment">// 2 * proportional gain (Kp)</span></span><br><span class="line"><span class="keyword">volatile</span> <span class="type">float</span> twoKi = twoKiDef;											<span class="comment">// 2 * integral gain (Ki)</span></span><br><span class="line"><span class="keyword">volatile</span> <span class="type">float</span> integralFBx = <span class="number">0.0f</span>,  integralFBy = <span class="number">0.0f</span>, integralFBz = <span class="number">0.0f</span>;	<span class="comment">// 积分误差</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/******************************************************************</span></span><br><span class="line"><span class="comment">**  算法实现</span></span><br><span class="line"><span class="comment">*******************************************************************/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * @brief  快速计算反平方根</span></span><br><span class="line"><span class="comment">  * @note   1/sqrt(x)</span></span><br><span class="line"><span class="comment">  * @param  x : 输入参数</span></span><br><span class="line"><span class="comment">  * @retval y : 反平方根结果</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"><span class="type">float</span> <span class="title function_">inv_sqrt</span><span class="params">(<span class="type">float</span> x)</span> </span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">float</span> halfx = <span class="number">0.5f</span> * x;</span><br><span class="line">	<span class="type">float</span> y     = x;</span><br><span class="line">	<span class="type">long</span>  i     = *(<span class="type">long</span>*)&amp;y;</span><br><span class="line">	</span><br><span class="line">	i = <span class="number">0x5f3759df</span> - (i &gt;&gt; <span class="number">1</span>);</span><br><span class="line">	y = *(<span class="type">float</span>*)&amp;i;</span><br><span class="line">	y = y * (<span class="number">1.5f</span> - (halfx * y * y));</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">return</span> y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * @brief  Mahony融合算法（6轴版）</span></span><br><span class="line"><span class="comment">  * @note   只负责迭代环路，初始化另外提前做</span></span><br><span class="line"><span class="comment">  * @param  q : 四元数（数组）</span></span><br><span class="line"><span class="comment">  * @param  gx,gy,gz : 陀螺仪数据（标准dps单位）</span></span><br><span class="line"><span class="comment">  * @param  ax,ay,az : 加速度数据（标准g单位）</span></span><br><span class="line"><span class="comment">  * @retval None</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">MahonyFilter_6Axis</span><span class="params">(<span class="type">float</span> q[<span class="number">4</span>], </span></span><br><span class="line"><span class="params">	                       <span class="type">float</span> gx, <span class="type">float</span> gy, <span class="type">float</span> gz,</span></span><br><span class="line"><span class="params">												 <span class="type">float</span> ax, <span class="type">float</span> ay, <span class="type">float</span> az)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">float</span> normFactor;</span><br><span class="line">	<span class="type">float</span> halfvx, halfvy, halfvz;	<span class="comment">// 估计的重力加速度矢量，half表示半值</span></span><br><span class="line">	<span class="type">float</span> halfex, halfey, halfez; <span class="comment">// 误差向量</span></span><br><span class="line">	<span class="type">float</span> q0 = q[<span class="number">0</span>],q1 = q[<span class="number">1</span>], q2 = q[<span class="number">2</span>], q3 = q[<span class="number">3</span>];</span><br><span class="line">	</span><br><span class="line">	<span class="type">float</span> q0q0 = q[<span class="number">0</span>]*q[<span class="number">0</span>];</span><br><span class="line">	<span class="type">float</span> q0q1 = q[<span class="number">0</span>]*q[<span class="number">1</span>];</span><br><span class="line">	<span class="type">float</span> q0q2 = q[<span class="number">0</span>]*q[<span class="number">2</span>];</span><br><span class="line">	<span class="type">float</span> q0q3 = q[<span class="number">0</span>]*q[<span class="number">3</span>];</span><br><span class="line">	<span class="type">float</span> q1q1 = q[<span class="number">1</span>]*q[<span class="number">1</span>];</span><br><span class="line">	<span class="type">float</span> q1q2 = q[<span class="number">1</span>]*q[<span class="number">2</span>];</span><br><span class="line">	<span class="type">float</span> q1q3 = q[<span class="number">1</span>]*q[<span class="number">3</span>];</span><br><span class="line">	<span class="type">float</span> q2q2 = q[<span class="number">2</span>]*q[<span class="number">2</span>];   </span><br><span class="line">	<span class="type">float</span> q2q3 = q[<span class="number">2</span>]*q[<span class="number">3</span>];</span><br><span class="line">	<span class="type">float</span> q3q3 = q[<span class="number">3</span>]*q[<span class="number">3</span>];  </span><br><span class="line"></span><br><span class="line">	<span class="comment">// 只在加速度计数据有效时才进行运算</span></span><br><span class="line">	<span class="keyword">if</span>((ax != <span class="number">0.0f</span>) || (ay != <span class="number">0.0f</span>) || (az != <span class="number">0.0f</span>)) </span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">// 将加速度计得到的实际重力加速度向量v单位化</span></span><br><span class="line">		normFactor = inv_sqrt(ax * ax + ay * ay + az * az); <span class="comment">//向量模长倒数</span></span><br><span class="line">		ax *= normFactor;</span><br><span class="line">		ay *= normFactor;</span><br><span class="line">		az *= normFactor;        </span><br><span class="line"></span><br><span class="line">		<span class="comment">// 通过四元数（旋转矩阵）得到理论重力加速度在机体坐标系下的向量值 </span></span><br><span class="line">		<span class="comment">// 注意，这里实际上是矩阵第三列*1/2，在开头对Kp Ki的宏定义均为2*增益，这样处理目的是减少乘法运算量</span></span><br><span class="line">		halfvx = q1q3 - q0q2;</span><br><span class="line">		halfvy = q0q1 + q2q3;</span><br><span class="line">		halfvz = q0q0 - <span class="number">0.5f</span> + q3q3;	<span class="comment">// q0q0 - q1q1 - q2q2 + q3q3 的优化版（|q| =1）</span></span><br><span class="line">	</span><br><span class="line">		<span class="comment">// 求误差：实际重力加速度向量（测量值）与理论重力加速度向量（估计值）做外积</span></span><br><span class="line">		halfex = (ay * halfvz - az * halfvy);</span><br><span class="line">		halfey = (az * halfvx - ax * halfvz);</span><br><span class="line">		halfez = (ax * halfvy - ay * halfvx);</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span>(twoKi &gt; <span class="number">0.0f</span>) </span><br><span class="line">		&#123;</span><br><span class="line">			<span class="comment">// 积分过程</span></span><br><span class="line">			integralFBx += twoKi * halfex * (<span class="number">1.0f</span> / sampleFreq);	</span><br><span class="line">			integralFBy += twoKi * halfey * (<span class="number">1.0f</span> / sampleFreq);</span><br><span class="line">			integralFBz += twoKi * halfez * (<span class="number">1.0f</span> / sampleFreq);</span><br><span class="line"></span><br><span class="line">			<span class="comment">// 积分项</span></span><br><span class="line">			gx += integralFBx;</span><br><span class="line">			gy += integralFBy;</span><br><span class="line">			gz += integralFBz;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> &#123;</span><br><span class="line">			integralFBx = <span class="number">0.0f</span>;	</span><br><span class="line">			integralFBy = <span class="number">0.0f</span>;</span><br><span class="line">			integralFBz = <span class="number">0.0f</span>;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 比例项</span></span><br><span class="line">		gx += twoKp * halfex;</span><br><span class="line">		gy += twoKp * halfey;</span><br><span class="line">		gz += twoKp * halfez;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 四元数 微分方程</span></span><br><span class="line">	gx *= (<span class="number">0.5f</span> * (<span class="number">1.0f</span> / sampleFreq));</span><br><span class="line">	gy *= (<span class="number">0.5f</span> * (<span class="number">1.0f</span> / sampleFreq));</span><br><span class="line">	gz *= (<span class="number">0.5f</span> * (<span class="number">1.0f</span> / sampleFreq));</span><br><span class="line">	</span><br><span class="line">	q[<span class="number">0</span>] += (-q1 * gx - q2 * gy - q3 * gz);</span><br><span class="line">	q[<span class="number">1</span>] += (q0 * gx + q2 * gz - q3 * gy);</span><br><span class="line">	q[<span class="number">2</span>] += (q0 * gy - q1 * gz + q3 * gx);</span><br><span class="line">	q[<span class="number">3</span>] += (q0 * gz + q1 * gy - q2 * gx); </span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 单位化四元数</span></span><br><span class="line">	normFactor = inv_sqrt(q[<span class="number">0</span>] * q[<span class="number">0</span>] + q[<span class="number">1</span>] * q[<span class="number">1</span>] + q[<span class="number">2</span>] * q[<span class="number">2</span>] + q[<span class="number">3</span>] * q[<span class="number">3</span>]);</span><br><span class="line">	q[<span class="number">0</span>] *= normFactor;</span><br><span class="line">	q[<span class="number">1</span>] *= normFactor;</span><br><span class="line">	q[<span class="number">2</span>] *= normFactor;</span><br><span class="line">	q[<span class="number">3</span>] *= normFactor;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>迭代得到的四元数，可以需要时用来解欧拉角：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * @brief  四元数转欧拉角</span></span><br><span class="line"><span class="comment">  * @note   函数内不校验四元数的准确性</span></span><br><span class="line"><span class="comment">  * @param  pIMU : 标准单位制的陀螺仪数据区</span></span><br><span class="line"><span class="comment">  * @retval None</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">trans_quaternionToEulerAngle</span><span class="params">(imu_rawData_t* pIMU)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">float</span> q[<span class="number">4</span>];</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i =<span class="number">0</span>; i &lt;<span class="number">4</span>; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		q[i] = pIMU-&gt;quaternion_body2Earth[i];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">/* yaw    -pi----pi */</span></span><br><span class="line">	pIMU-&gt;yaw = -<span class="built_in">atan2</span>(<span class="number">2</span>*q[<span class="number">1</span>]*q[<span class="number">2</span>] + <span class="number">2</span>*q[<span class="number">0</span>]*q[<span class="number">3</span>], <span class="number">-2</span>*q[<span class="number">2</span>]*q[<span class="number">2</span>] - <span class="number">2</span>*q[<span class="number">3</span>]*q[<span class="number">3</span>] + <span class="number">1</span>)* <span class="number">57.3</span>; </span><br><span class="line">	<span class="comment">/* pitch  -pi/2----pi/2 */</span></span><br><span class="line">	pIMU-&gt;pitch = -<span class="built_in">asin</span>(<span class="number">-2</span>*q[<span class="number">1</span>]*q[<span class="number">3</span>] + <span class="number">2</span>*q[<span class="number">0</span>]*q[<span class="number">2</span>])* <span class="number">57.3</span>;   </span><br><span class="line">	<span class="comment">/* roll   -pi----pi  */</span>	</span><br><span class="line">	pIMU-&gt;roll =  <span class="built_in">atan2</span>(<span class="number">2</span>*q[<span class="number">2</span>]*q[<span class="number">3</span>] + <span class="number">2</span>*q[<span class="number">0</span>]*q[<span class="number">1</span>], <span class="number">-2</span>*q[<span class="number">1</span>]*q[<span class="number">1</span>] - <span class="number">2</span>*q[<span class="number">2</span>]*q[<span class="number">2</span>] + <span class="number">1</span>)* <span class="number">57.3</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="MEMS陀螺仪工作原理"><a href="#MEMS陀螺仪工作原理" class="headerlink" title="MEMS陀螺仪工作原理"></a>MEMS陀螺仪工作原理</h2><p><img src="https://blog-img-goryj.oss-rg-china-mainland.aliyuncs.com/blogpost/20220728-ICM42688SPI-8.jpg" alt="科里奥利力"></p>
<p>首先介绍物理学中的科里奥利力（Coriolis force），是对旋转体系中进行直线运动的质点由于惯性相对于旋转体系产生的直线运动的偏移的一种描述。科里奥利力来自于物体运动所具有的惯性。说白了，其实就是射击游戏里的<strong>打提前量，但是目标是旋转的</strong>。这玩意的发现来源于炮弹射不准问题，因为地球是有自转的（旋转系），所以在某个时刻瞄准目标打炮时，炮弹只会直着飞出去（相对于宇宙这个静止惯性系），然而在飞的过程中目标跟着地球转走了，就打不准；从地面上受害者的角度来看，就是炮弹自己慢慢拐弯走了？？？🤣聪明的炮兵就因此就请出了科里奥利力来算射击提前量：</p>
<p>$$<br>\vec F_c &#x3D; -2m(\vec \omega \times \vec v)<br>$$<br>式中，$m$是炮弹的质量，$\vec v$是炮弹的飞行速度，$\vec \omega$是受害者所在旋转系的角速度。</p>
<p><img src="https://blog-img-goryj.oss-rg-china-mainland.aliyuncs.com/blogpost/20220728-ICM42688SPI-9.gif" alt="MEMS陀螺仪原理"></p>
<p>MEMS陀螺仪也是这么个道理，内部有一个微机电（Micro-Electro-Mechanical）谐振腔，腔内有一个小振子受到交替电压驱动作振动，当外壳带着谐振腔旋转时，里面的振子因为科里奥利力导致振动方向偏移，测量这个方向偏移就可以得到<em>旋转速度</em>了。</p>
<h2 id="MEMS加速度计原理"><a href="#MEMS加速度计原理" class="headerlink" title="MEMS加速度计原理"></a>MEMS加速度计原理</h2><p>加速度计的不同类型原理有：</p>
<ul>
<li>压电式：里面有个质量块以及用来测量的压电元件，加减速时由于压力不同导致压电元件产生的电压不同：<br>  $$<br>  F &#x3D; ma \\<br>  V &#x3D; kF<br>  $$</li>
<li>电容式：内部一样有一个质量块，加减速时拉动电容的极板，通过测量电容量即可</li>
<li>热感式：没有任何质量块，它的中央有一个加热体，周边是温度传感器，里面是密闭的气腔，工作时在加热体的作用下，气体在内部形成一个热气团，热气团的比重和周围的冷气是有差异的，通过惯性热气团的移动形成的热场变化让感应器感应到加速度值</li>
</ul>
<h2 id="初始化（信号链配置）详解"><a href="#初始化（信号链配置）详解" class="headerlink" title="初始化（信号链配置）详解"></a>初始化（信号链配置）详解</h2><p>在上面我们给出了使用<code>ICM42688</code>芯片的应用硬件电路和高速<code>SPI</code>驱动的相关工作，以及将陀螺仪数据与加速度计数据进行融合的入门级<code>Mahony</code>算法。在最后补充对ICM42688的初始化过程，在上电&#x2F;复位后需要依次初始化的有：</p>
<ol>
<li>软件复位</li>
<li>设置外部时钟源与PLL</li>
<li>配置陀螺仪信号链</li>
<li>配置加速度计信号链</li>
<li>配置中断</li>
<li>配置FIFO</li>
<li>使能供电</li>
</ol>
<p>所有功能的描述在数据手册上都能找到，这里着重讲解信号链（下图）的配置，因为这关系到采集数据的有效性和可靠性问题。陀螺仪由于上方讨论的振子结构问题，所以输出信号的噪声比较大；因此相比于加速度计的信号链，陀螺仪加入了一级“限波器”（Notch Filter），用来消除振子的工作频率噪声。随后是两级通用的滤波器：抗混叠滤波器（Anti-Alias Filter）和用户接口滤波器（UI Filter），中间夹着一个硬件的偏置补偿。</p>
<p><img src="https://blog-img-goryj.oss-rg-china-mainland.aliyuncs.com/blogpost/20220728-ICM42688SPI-10.png" alt="ICM426XX信号链结构"></p>
<p>UIF是由输出数据率（ODR：output data rate）、阶数（Order）、带宽（Bandwidth）或群延迟（Group Delay）三个指标进行配置，主要作用是输出系统需要的数据到寄存器中；因为MEMS传感器的带宽非常大，所以根据奈归斯特采样定理，需要将进入UIF的信号带宽限制为ODR的一半，因此AAF的作用就是这个了。</p>
<p>下图是使用AAF前后的信号波形情况，可以看出对于陀螺仪来说效果非常明显，而加速度计本身噪声就比较少。</p>
<p><img src="https://blog-img-goryj.oss-rg-china-mainland.aliyuncs.com/blogpost/20220728-ICM42688SPI-11.png" alt="启用AAF前后对比"></p>
<p>以下是初始化的实现代码：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * @brief  ICM426XX设备初始化</span></span><br><span class="line"><span class="comment">  *         软复位、配置外部时钟和RTC、配置信号链参数、</span></span><br><span class="line"><span class="comment">  *         加载预准数据、配置中断、配置FIFO</span></span><br><span class="line"><span class="comment">  * @note   需要预先配置好处理器的SPI接口、中断引脚、RTC时钟输出</span></span><br><span class="line"><span class="comment">  * @param  None</span></span><br><span class="line"><span class="comment">  * @retval None</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">icm426xx_deviceInit</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="meta">#<span class="keyword">ifndef</span> _RAWSIGNAL_ANALYSIS_ICM426XX_</span></span><br><span class="line">	<span class="comment">// 陀螺仪抗混叠滤波器（AAF）带宽，更改配置需查手册中的参数表</span></span><br><span class="line">	<span class="type">uint16_t</span> gyro_aaf_delta = <span class="number">2</span>;		<span class="comment">/* 84 Hz（3dB） */</span></span><br><span class="line">	<span class="type">uint16_t</span> gyro_aaf_deltasqr = gyro_aaf_delta*gyro_aaf_delta;</span><br><span class="line">	<span class="type">uint8_t</span> gyro_aaf_bitshift = <span class="number">13</span>;</span><br><span class="line">	<span class="comment">// 加速度计抗混叠滤波器（AAF）带宽</span></span><br><span class="line">	<span class="type">uint16_t</span> accel_aaf_delta = <span class="number">2</span>;		<span class="comment">/* 84 Hz（3dB） */</span></span><br><span class="line">	<span class="type">uint16_t</span> accel_aaf_deltasqr = gyro_aaf_delta*gyro_aaf_delta;</span><br><span class="line">	<span class="type">uint8_t</span> accel_aaf_bitshift = <span class="number">13</span>;</span><br><span class="line">	<span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">	</span><br><span class="line">	imuStatus = ICM426XX_STATUS_NOREADY;	<span class="comment">// 标志设备还没准备好</span></span><br><span class="line">	</span><br><span class="line">	imu.quaternion_body2Earth[<span class="number">0</span>] = <span class="number">1</span>;	<span class="comment">// 初始化四元数</span></span><br><span class="line">	imu.quaternion_body2Earth[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">	imu.quaternion_body2Earth[<span class="number">2</span>] = <span class="number">0</span>;</span><br><span class="line">	imu.quaternion_body2Earth[<span class="number">3</span>] = <span class="number">0</span>;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// - 等待设备上电安全完成</span></span><br><span class="line">	HAL_Delay(<span class="number">3</span>);	<span class="comment">// 3ms</span></span><br><span class="line">	</span><br><span class="line">	<span class="comment">// - 复位设备--------------------------------------------------------------------------</span></span><br><span class="line">	icm426xx_spi_master_write_register(MPUREG_REG_BANK_SEL, <span class="number">0</span>);	<span class="comment">// 切换至寄存器BANK 0</span></span><br><span class="line">	icm426xx_spi_master_write_register(MPUREG_DEVICE_CONFIG, ICM426XX_DEVICE_CONFIG_RESET_EN);	<span class="comment">// 软件复位</span></span><br><span class="line">	HAL_Delay(<span class="number">2</span>);	<span class="comment">// 等待内部复位操作完成，最少1ms</span></span><br><span class="line">	</span><br><span class="line">	<span class="comment">// - 设置外部时钟源（32.768kHz）和RTC时间戳---------------------------------------------</span></span><br><span class="line">	</span><br><span class="line">	icm426xx_spi_master_write_register(MPUREG_REG_BANK_SEL,<span class="number">1</span>);	<span class="comment">// 切换至寄存器BANK 1</span></span><br><span class="line">	icm426xx_spi_master_write_register(MPUREG_INTF_CONFIG5_B1,</span><br><span class="line">	                                   ICM426XX_INTF_CONFIG5_PIN9_asCLKIN</span><br><span class="line">	                                   ); <span class="comment">// 配置9脚为 外部时钟输入模式</span></span><br><span class="line">	</span><br><span class="line">	icm426xx_spi_master_write_register(MPUREG_REG_BANK_SEL,<span class="number">0</span>);	<span class="comment">// 切换至寄存器BANK 0</span></span><br><span class="line">	<span class="comment">// 低功耗模式下加速度计使用内部RC震荡器；使能PLL 和  RTC</span></span><br><span class="line">	icm426xx_spi_master_write_register(MPUREG_INTF_CONFIG1,</span><br><span class="line">	                                   (ICM426XX_INTF_CONFIG1_ACCEL_LP_CLK_RCOSC | \</span><br><span class="line">																		 ICM426XX_INTF_CONFIG1_RTC_MODE_EN | \</span><br><span class="line">																		 <span class="number">0x01</span>)</span><br><span class="line">	                                   ); </span><br><span class="line">	<span class="comment">// 时间戳设置：时间戳导入可读寄存器、精度1个标准RTC周期、帧同步使能、使能时间戳</span></span><br><span class="line">	icm426xx_spi_master_write_register(MPUREG_TMST_CONFIG,</span><br><span class="line">	                                   (ICM426XX_TMST_CONFIG_TMST_TO_REGS_EN | \</span><br><span class="line">																		  ICM426XX_TMST_CONFIG_RESOL_16us       | \</span><br><span class="line">																			ICM426XX_TMST_CONFIG_TMST_FSYNC_EN   | \</span><br><span class="line">																			ICM426XX_TMST_CONFIG_TMST_EN</span><br><span class="line">																			)</span><br><span class="line">																		);</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// - 设置陀螺仪的信号链参数------------------------------------------------------------</span></span><br><span class="line">	</span><br><span class="line">	<span class="comment">// -- 陀螺仪的陷波器（NotchFilter）参数配置，根据实际情况选用</span></span><br><span class="line">	<span class="comment">//icm426xx_Gyro_ConfigNotchFilter(2,ICM426XX_GYRO_NF_BW_680Hz);</span></span><br><span class="line">	</span><br><span class="line">	<span class="comment">// -- 陀螺仪的抗混叠滤波器（Anti-Alias Filter）配置</span></span><br><span class="line">	icm426xx_spi_master_write_register(MPUREG_REG_BANK_SEL,<span class="number">1</span>);	<span class="comment">// 切换至寄存器BANK 1</span></span><br><span class="line">	</span><br><span class="line">	<span class="meta">#<span class="keyword">ifndef</span> _RAWSIGNAL_ANALYSIS_ICM426XX_</span></span><br><span class="line">		icm426xx_spi_master_write_register(MPUREG_GYRO_CONFIG_STATIC3_B1,</span><br><span class="line">																			 (gyro_aaf_delta &amp; <span class="number">0x3f</span>)</span><br><span class="line">																			);</span><br><span class="line">		icm426xx_spi_master_write_register(MPUREG_GYRO_CONFIG_STATIC4_B1,</span><br><span class="line">																			 (gyro_aaf_deltasqr &amp; <span class="number">0xff</span>)</span><br><span class="line">																			);</span><br><span class="line">		icm426xx_spi_master_write_register(MPUREG_GYRO_CONFIG_STATIC5_B1,</span><br><span class="line">																			 ( ((gyro_aaf_deltasqr&gt;&gt;<span class="number">8</span>) &amp; <span class="number">0x0f</span>) | (gyro_aaf_bitshift&lt;&lt;<span class="number">4</span>) )</span><br><span class="line">																			);</span><br><span class="line">																		</span><br><span class="line">		<span class="meta">#<span class="keyword">ifdef</span> _DONT_USE_NOTCHFILTER_ICM426XX_</span></span><br><span class="line">			<span class="comment">// ---- 使能AAF，不使用NF</span></span><br><span class="line">			icm426xx_spi_master_write_register(MPUREG_GYRO_CONFIG_STATIC2_B1,</span><br><span class="line">																				 (ICM426XX_GYRO_AAF_EN | ICM426XX_GYRO_NF_DIS)</span><br><span class="line">																				);</span><br><span class="line">		<span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">			<span class="comment">// ---- 使能AAF和NF</span></span><br><span class="line">			icm426xx_spi_master_write_register(MPUREG_GYRO_CONFIG_STATIC2_B1,</span><br><span class="line">																				 (ICM426XX_GYRO_AAF_EN | ICM426XX_GYRO_NF_EN)</span><br><span class="line">																				);</span><br><span class="line">		<span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">	<span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">		<span class="comment">// ---- 关闭AAF和NF，从而收集原始数据</span></span><br><span class="line">		icm426xx_spi_master_write_register(MPUREG_GYRO_CONFIG_STATIC2_B1,</span><br><span class="line">																			 (ICM426XX_GYRO_AAF_DIS | ICM426XX_GYRO_NF_DIS)</span><br><span class="line">																			);</span><br><span class="line">	<span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">																		</span><br><span class="line">	<span class="comment">// -- 设置用户接口滤波器（UI Filter）和量程（FSR）</span></span><br><span class="line">	icm426xx_spi_master_write_register(MPUREG_REG_BANK_SEL,  <span class="number">0</span>);	<span class="comment">// 切换至寄存器BANK 0</span></span><br><span class="line">	<span class="comment">// 3阶，200Hz 数据率（ODR），带宽104.8Hz（群延时3.8ms）；量程500dps</span></span><br><span class="line">	icm426xx_spi_master_write_register(MPUREG_GYRO_CONFIG0,</span><br><span class="line">	                                   (_USER_GYRO_FULLSCALE_ | ICM426XX_GYRO_CONFIG0_ODR_200_HZ)</span><br><span class="line">																		 ); <span class="comment">// FSR 和 ODR</span></span><br><span class="line">	icm426xx_spi_master_write_register(MPUREG_GYRO_CONFIG1,</span><br><span class="line">	                                   (ICM426XX_GYRO_CONFIG_GYRO_UI_FILT_ORD_3RD_ORDER | (<span class="number">2</span>&lt;&lt;<span class="number">1</span>))</span><br><span class="line">																		 );	<span class="comment">// 阶数</span></span><br><span class="line">	icm426xx_spi_master_write_register(MPUREG_ACCEL_GYRO_CONFIG0,</span><br><span class="line">	                                   (ICM426XX_GYRO_ACCEL_CONFIG0_ACCEL_FILT_BW_14 | ICM426XX_GYRO_ACCEL_CONFIG0_GYRO_FILT_BW_14)</span><br><span class="line">																		 ); <span class="comment">// 带宽（加速度计和陀螺仪）</span></span><br><span class="line">				 </span><br><span class="line">	</span><br><span class="line">	<span class="comment">// - 设置加速度计的信号链--------------------------------------------------------------</span></span><br><span class="line">	</span><br><span class="line">	icm426xx_spi_master_write_register(MPUREG_REG_BANK_SEL,<span class="number">2</span>);	<span class="comment">// 切换至寄存器BANK2</span></span><br><span class="line">	<span class="comment">// -- 加速度计的抗混叠滤波器（Anti-Alias Filter）配置</span></span><br><span class="line">	<span class="meta">#<span class="keyword">ifndef</span> _RAWSIGNAL_ANALYSIS_ICM426XX_</span></span><br><span class="line">		icm426xx_spi_master_write_register(MPUREG_ACCEL_CONFIG_STATIC2_B2,</span><br><span class="line">																			 ((accel_aaf_delta &lt;&lt; BIT_ACCEL_AAF_DELT_POS) | \</span><br><span class="line">																			  ICM426XX_ACCEL_AAF_EN)</span><br><span class="line">																			);	<span class="comment">// 这里顺带使能了AAF</span></span><br><span class="line">		icm426xx_spi_master_write_register(MPUREG_ACCEL_CONFIG_STATIC3_B2,</span><br><span class="line">																			 (accel_aaf_deltasqr &amp; <span class="number">0xff</span>)</span><br><span class="line">																			);</span><br><span class="line">		icm426xx_spi_master_write_register(MPUREG_ACCEL_CONFIG_STATIC4_B2,</span><br><span class="line">																			 ( ((accel_aaf_deltasqr&gt;&gt;<span class="number">8</span>) &amp; <span class="number">0x0f</span>) | (accel_aaf_bitshift&lt;&lt;<span class="number">4</span>) )</span><br><span class="line">																			);</span><br><span class="line">	<span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">		<span class="comment">// 关闭AAF，从而收集原始数据</span></span><br><span class="line">		icm426xx_spi_master_write_register(MPUREG_ACCEL_CONFIG_STATIC2_B2,</span><br><span class="line">																			 ICM426XX_ACCEL_AAF_DIS);</span><br><span class="line">	<span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">																		</span><br><span class="line">	<span class="comment">// -- 设置用户接口滤波器（UI Filter）和量程（FSR）</span></span><br><span class="line">	icm426xx_spi_master_write_register(MPUREG_REG_BANK_SEL,  <span class="number">0</span>);	<span class="comment">// 切换至寄存器BANK 0</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// 3阶，200Hz 数据率（ODR），带宽104.8Hz（群延时3.8ms）；量程500dps	</span></span><br><span class="line">	icm426xx_spi_master_write_register(MPUREG_ACCEL_CONFIG0,</span><br><span class="line">	                                   (_USER_ACCL_FULLSCALE_ | ICM426XX_ACCEL_CONFIG0_ODR_200_HZ)</span><br><span class="line">																		 ); <span class="comment">// FSR 和 ODR</span></span><br><span class="line">	icm426xx_spi_master_write_register(MPUREG_ACCEL_CONFIG1,</span><br><span class="line">	                                   (ICM426XX_ACCEL_CONFIG_ACCEL_UI_FILT_ORD_3RD_ORDER | (<span class="number">2</span>&lt;&lt;<span class="number">1</span>))</span><br><span class="line">																		 );	<span class="comment">// 阶数</span></span><br><span class="line">																		 <span class="comment">// <span class="doctag">NOTE:</span> 这里不操作带宽，因为在陀螺仪配置时一起配了</span></span><br><span class="line">	</span><br><span class="line">	<span class="comment">// - 加载预先校准好的6轴偏置数据-------------------------------------------------------</span></span><br><span class="line">		<span class="comment">// 外部加载！</span></span><br><span class="line">	</span><br><span class="line">	<span class="comment">// - 配置中断 并启动中断输出-----------------------------------------------------------</span></span><br><span class="line">	</span><br><span class="line">	icm426xx_spi_master_write_register(MPUREG_REG_BANK_SEL,  <span class="number">0</span>);	<span class="comment">// 切换至寄存器BANK 0</span></span><br><span class="line">	<span class="comment">// 配置INT1的输出模式：推挽（Push Pull），高电平有效，脉冲型中断输出</span></span><br><span class="line">	icm426xx_spi_master_write_register(MPUREG_INT_CONFIG,</span><br><span class="line">	                                    (ICM426XX_INT_CONFIG_INT1_DRIVE_CIRCUIT_PP | \</span><br><span class="line">																			 ICM426XX_INT_CONFIG_INT1_POLARITY_HIGH)</span><br><span class="line">																		);</span><br><span class="line">	<span class="comment">// 配置中断源</span></span><br><span class="line">	<span class="meta">#<span class="keyword">ifdef</span> _USER_USE_ICM426XX_FIFO_</span></span><br><span class="line">	<span class="comment">// 可触发的中断源：FIFO阈值、FIFO满</span></span><br><span class="line">	icm426xx_spi_master_write_register(MPUREG_INT_SOURCE0,</span><br><span class="line">	                                   (BIT_INT_SOURCE0_FIFO_THS_INT1_EN  | \</span><br><span class="line">																		BIT_INT_SOURCE0_FIFO_FULL_INT1_EN</span><br><span class="line">																			 )</span><br><span class="line">																		);</span><br><span class="line">	<span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">	<span class="comment">// 可触发的中断源：UI滤波器 数据可读</span></span><br><span class="line">	icm426xx_spi_master_write_register(MPUREG_INT_SOURCE0,</span><br><span class="line">	                                   BIT_INT_SOURCE0_UI_DRDY_INT1_EN</span><br><span class="line">																		);</span><br><span class="line">	<span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">	<span class="comment">// 配置清除中断方式</span></span><br><span class="line">	icm426xx_spi_master_write_register(MPUREG_INT_CONFIG0,</span><br><span class="line">	                                    (ICM426XX_UI_DRDY_INT_CLEAR_ON_STATUS_READ | \</span><br><span class="line">																			 ICM426XX_FIFO_THS_INT_CLEAR_ON_STATUS_READ | \</span><br><span class="line">																			 ICM426XX_FIFO_FULL_INT_CLEAR_ON_STATUS_READ</span><br><span class="line">																			)</span><br><span class="line">																		);</span><br><span class="line">	<span class="comment">// 配置中断信号的脉冲宽度：100us宽度脉冲，使能中断有效抑制；最后异步复位中断脚</span></span><br><span class="line">	icm426xx_spi_master_write_register(MPUREG_INT_CONFIG1,</span><br><span class="line">	                                    (ICM426XX_INT_TPULSE_DURATION_100_US | \</span><br><span class="line">																			 ICM426XX_INT_TDEASSERT_ENABLED | \</span><br><span class="line">																			 ICM426XX_INT_CONFIG1_ASY_RST_ENABLED)</span><br><span class="line">																		);</span><br><span class="line">																			 </span><br><span class="line">	<span class="comment">// - 配置FIFO的数据格式 并启动FIFO-----------------------------------------------------</span></span><br><span class="line">	</span><br><span class="line">	icm426xx_spi_master_write_register(MPUREG_REG_BANK_SEL,  <span class="number">0</span>);	<span class="comment">// 切换至寄存器BANK 0</span></span><br><span class="line">	</span><br><span class="line">	<span class="comment">//复位FIFO</span></span><br><span class="line">	icm426xx_spi_master_write_register(MPUREG_FIFO_CONFIG,</span><br><span class="line">	                                   ICM426XX_FIFO_CONFIG_MODE_BYPASS</span><br><span class="line">																		);</span><br><span class="line">	</span><br><span class="line">	<span class="meta">#<span class="keyword">ifdef</span> _USER_USE_ICM426XX_FIFO_</span></span><br><span class="line">	<span class="comment">//配置FIFO的无效数据报告方式、计数方式、数据字端</span></span><br><span class="line">	<span class="comment">//// -32768或-32767表示无效数据； 按包计数； FIFO计数器和传感器数据包按“小字端”组织</span></span><br><span class="line">	icm426xx_spi_master_write_register(MPUREG_INTF_CONFIG0,</span><br><span class="line">	                                    (ICM426XX_INTF_CONFIG0_FIFO_SREG_INVALID_IND_EN | \</span><br><span class="line">																			 ICM426XX_INTF_CONFIG0_FIFO_COUNT_REC_RECORD | \</span><br><span class="line">																			 ICM426XX_INTF_CONFIG0_FIFO_COUNT_LITTLE_ENDIAN | \</span><br><span class="line">																			 ICM426XX_INTF_CONFIG0_DATA_LITTLE_ENDIAN</span><br><span class="line">																			 )</span><br><span class="line">																		);</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//配置FIFO包格式为 “Packet 3”：Header（1Byte）+Accel（6Byte）+Gyro（6Byte）+Temp（1Byte）+Time（2Byte）</span></span><br><span class="line">	<span class="comment">/* 允许断包读取、使能包数量过多中断、不用高精度扩展、使能时间戳、使能温度数据、使能陀螺仪、使能加速度计*/</span></span><br><span class="line">	icm426xx_spi_master_write_register(MPUREG_FIFO_CONFIG1,</span><br><span class="line">	                                    (ICM426XX_FIFO_CONFIG1_RESUME_PARTIAL_RD_EN | \</span><br><span class="line">																			 ICM426XX_FIFO_CONFIG1_WM_GT_TH_EN           | \</span><br><span class="line">																			 ICM426XX_FIFO_CONFIG1_HIRES_DIS             | \</span><br><span class="line">																			 ICM426XX_FIFO_CONFIG1_TMST_FSYNC_EN         | \</span><br><span class="line">																			 ICM426XX_FIFO_CONFIG1_TEMP_EN               | \</span><br><span class="line">																			 ICM426XX_FIFO_CONFIG1_GYRO_EN               | \</span><br><span class="line">																			 ICM426XX_FIFO_CONFIG1_ACCEL_EN) </span><br><span class="line">																		 );</span><br><span class="line">	<span class="comment">// FIFO计数报警值（WaterMark）为4个 包！</span></span><br><span class="line">	icm426xx_spi_master_write_register(MPUREG_FIFO_CONFIG2,   <span class="number">4</span>);</span><br><span class="line">	icm426xx_spi_master_write_register(MPUREG_FIFO_CONFIG2+<span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//配置FIFO为连续数据流模式，（满时新数据会覆盖旧数据）</span></span><br><span class="line">	icm426xx_spi_master_write_register(MPUREG_FIFO_CONFIG,</span><br><span class="line">	                                   ICM426XX_FIFO_CONFIG_MODE_STOP_ON_FULL</span><br><span class="line">																		);</span><br><span class="line">	<span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">	</span><br><span class="line">	<span class="comment">// - 电源管理配置（给陀螺仪和加速度计上电）--------------------------------------------</span></span><br><span class="line">	</span><br><span class="line">	icm426xx_spi_master_write_register(MPUREG_REG_BANK_SEL,  <span class="number">0</span>);	<span class="comment">// 切换至寄存器BANK 0</span></span><br><span class="line">	icm426xx_spi_master_write_register(MPUREG_PWR_MGMT_0,</span><br><span class="line">	                                    (ICM426XX_PWR_MGMT_0_TEMP_EN | \</span><br><span class="line">																			 ICM426XX_PWR_MGMT_0_IDLE_EN | \</span><br><span class="line">																			 ICM426XX_PWR_MGMT_0_GYRO_MODE_LN | \</span><br><span class="line">																			 ICM426XX_PWR_MGMT_0_ACCEL_MODE_LN</span><br><span class="line">																			 )</span><br><span class="line">																		);</span><br><span class="line">	HAL_Delay(<span class="number">50</span>);	<span class="comment">// 官方要求陀螺仪切换模式后，必须等最少45ms，这里保险起见50ms</span></span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// - 配置完成------------------------------------------------------------------------</span></span><br><span class="line"></span><br><span class="line">	icm426xx_spi_master_write_register(MPUREG_REG_BANK_SEL,  <span class="number">0</span>);	<span class="comment">// 切换至寄存器BANK 0</span></span><br><span class="line">	imuStatus = ICM426XX_STATUS_NORMAL;</span><br><span class="line">	<span class="keyword">return</span>;</span><br><span class="line">	 </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>考虑到系统在工作的过程中，环境因素的变化，因此将加载偏置的接口单独放在初始化接口的外部：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * @brief  加载各轴偏置量</span></span><br><span class="line"><span class="comment">  * @note   偏置量在复杂环境下要不断调整</span></span><br><span class="line"><span class="comment">  * @param  pOffset : 加载的偏置量数据区指针（遵照ICM426XX寄存器格式）</span></span><br><span class="line"><span class="comment">  * @retval None</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">icm426xx_load6AxisOffset</span><span class="params">(<span class="type">uint8_t</span> pOffset[<span class="number">9</span>])</span></span><br><span class="line">&#123;</span><br><span class="line">	icm426xx_spi_master_write_register(MPUREG_REG_BANK_SEL, <span class="number">4</span>);	<span class="comment">// 切换至寄存器BANK 0</span></span><br><span class="line">	</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> addr=<span class="number">0</span>; addr &lt; <span class="number">9</span>; addr ++)</span><br><span class="line">	&#123;</span><br><span class="line">		icm426xx_spi_master_write_register(MPUREG_OFFSET_USER_0_B4 + addr,</span><br><span class="line">		                                   pOffset[addr]);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	icm426xx_spi_master_write_register(MPUREG_REG_BANK_SEL, <span class="number">0</span>);	<span class="comment">// 切换至寄存器BANK 0</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * @brief  求解各轴偏置量（平均法）</span></span><br><span class="line"><span class="comment">  * @note   在接收数据中断中调用</span></span><br><span class="line"><span class="comment">  * @param  pOffset : 存储解算出的偏置数据寄存器格式</span></span><br><span class="line"><span class="comment">  * @retval None</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">icm426xx_getAverageOffset</span><span class="params">(<span class="type">uint8_t</span> pOffset[<span class="number">9</span>])</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> addr =<span class="number">0</span>; addr &lt; <span class="number">3</span>; addr++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">// 求平均量</span></span><br><span class="line">		gyroAxisSum[addr] = gyroAxisSum[addr] &gt;&gt;<span class="number">9</span> ;	<span class="comment">// log2(512) = 9</span></span><br><span class="line">		accelAxisSum[addr] = accelAxisSum[addr] &gt;&gt;<span class="number">9</span>;</span><br><span class="line">		</span><br><span class="line">		<span class="comment">// <span class="doctag">NOTE:</span>陀螺仪偏置精度固定为 (1/32dps)/LSB（±64dps补偿范围），这里做比例变换</span></span><br><span class="line">		gyroAxisSum[addr] = -(gyroAxisSum[addr] * <span class="number">500</span>) &gt;&gt; (<span class="number">6</span>+<span class="number">4</span>);	<span class="comment">// log2(64)=6是目标FSR，另外的4是16位精度到12位精度的损失</span></span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// <span class="doctag">NOTE:</span>加速度计偏置精度为：(0.5mg)/LSB （±1g补偿范围）</span></span><br><span class="line">	accelAxisSum[<span class="number">0</span>] = -(accelAxisSum[<span class="number">0</span>] * <span class="number">4</span>) &gt;&gt; <span class="number">4</span>;		<span class="comment">// X轴补偿为 0</span></span><br><span class="line">	accelAxisSum[<span class="number">1</span>] = -(accelAxisSum[<span class="number">1</span>] * <span class="number">4</span>) &gt;&gt; <span class="number">4</span>;		<span class="comment">// Y轴补偿为 0</span></span><br><span class="line">	accelAxisSum[<span class="number">2</span>] = -((accelAxisSum[<span class="number">2</span>] * <span class="number">4</span>) &gt;&gt; <span class="number">4</span>) + <span class="number">1000</span>;		<span class="comment">// Z轴补偿为 1g</span></span><br><span class="line"></span><br><span class="line">	</span><br><span class="line">	pOffset[<span class="number">0</span>] = gyroAxisSum[<span class="number">0</span>]  &amp; <span class="number">0x00ff</span>;	<span class="comment">// X轴陀螺仪低位</span></span><br><span class="line">	pOffset[<span class="number">1</span>] = ((gyroAxisSum[<span class="number">1</span>]&amp; <span class="number">0x0f00</span>) &gt;&gt; <span class="number">4</span>) | ((gyroAxisSum[<span class="number">0</span>]&amp;<span class="number">0x0f00</span>) &gt;&gt; <span class="number">8</span>);	<span class="comment">// Y和X的高位</span></span><br><span class="line">	pOffset[<span class="number">2</span>] = gyroAxisSum[<span class="number">1</span>]  &amp; <span class="number">0x00ff</span>;	<span class="comment">// Y轴陀螺仪低位</span></span><br><span class="line">	pOffset[<span class="number">3</span>] = gyroAxisSum[<span class="number">2</span>]  &amp; <span class="number">0x00ff</span>;	<span class="comment">// Z轴陀螺仪低位</span></span><br><span class="line">	</span><br><span class="line">	pOffset[<span class="number">4</span>] = ((accelAxisSum[<span class="number">0</span>]&amp; <span class="number">0x0f00</span>) &gt;&gt; <span class="number">4</span>) | \</span><br><span class="line">	             ((gyroAxisSum[<span class="number">2</span>] &amp; <span class="number">0x0f00</span>) &gt;&gt; <span class="number">8</span>);	<span class="comment">// X轴加速度计高位，Z轴陀螺仪高位</span></span><br><span class="line">	</span><br><span class="line">	pOffset[<span class="number">5</span>] = accelAxisSum[<span class="number">0</span>]  &amp; <span class="number">0x00ff</span>;	<span class="comment">// X轴加速度计低位</span></span><br><span class="line">	pOffset[<span class="number">6</span>] = accelAxisSum[<span class="number">1</span>]  &amp; <span class="number">0x00ff</span>;	<span class="comment">// Y轴加速度计低位</span></span><br><span class="line">	pOffset[<span class="number">7</span>] = ((accelAxisSum[<span class="number">2</span>]&amp; <span class="number">0x0f00</span>) &gt;&gt; <span class="number">4</span>) | ((accelAxisSum[<span class="number">1</span>]&amp;<span class="number">0x0f00</span>) &gt;&gt; <span class="number">8</span>);	<span class="comment">// Z和Y的高位</span></span><br><span class="line">	pOffset[<span class="number">8</span>] = accelAxisSum[<span class="number">2</span>]  &amp; <span class="number">0x00ff</span>;	<span class="comment">// Z轴加速度计低位</span></span><br><span class="line">	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>若使用了中断引脚，则可以按如下进行中断处理：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * @brief  中断解析回调函数</span></span><br><span class="line"><span class="comment">  * @note   在MCU中断引脚对应的EXTI函数中调用</span></span><br><span class="line"><span class="comment">  *         只需调用 icm426xx_deviceInit() 接口该函数即可自动触发</span></span><br><span class="line"><span class="comment">  * @param  None</span></span><br><span class="line"><span class="comment">  * @retval None</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">icm426xx_callback_interrupt1</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">uint8_t</span> regVal_int_status;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// - 检验芯片状态</span></span><br><span class="line">	<span class="keyword">if</span>(imuStatus != ICM426XX_STATUS_NORMAL)</span><br><span class="line">		<span class="keyword">return</span>;	<span class="comment">// 芯片不工作退出</span></span><br><span class="line">	</span><br><span class="line">	<span class="comment">// - 读取中断状态/标志寄存器</span></span><br><span class="line">	icm426xx_spi_master_read_register(MPUREG_INT_STATUS,</span><br><span class="line">	                                 &amp;regVal_int_status, <span class="number">1</span>);</span><br><span class="line">	</span><br><span class="line">	<span class="meta">#<span class="keyword">ifdef</span> _USER_USE_ICM426XX_FIFO_		<span class="comment">// 仅在使用FIFO的情况下，使用这两个中断</span></span></span><br><span class="line">	<span class="keyword">if</span>(regVal_int_status &amp; BIT_INT_STATUS_FIFO_FULL)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">/* 中断优先级最高：处理FIFO满状态 */</span></span><br><span class="line">		icm426xx_readFIFOPacket(<span class="literal">NULL</span>);	<span class="comment">// 按需要调用 包处理回调函数</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span>(regVal_int_status &amp; BIT_INT_STATUS_FIFO_THS)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">/* 处理FIFO达到阈值状态 */</span></span><br><span class="line">		icm426xx_readFIFOPacket(<span class="literal">NULL</span>);	<span class="comment">// 按需要调用 包处理回调函数</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	<span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">		<span class="keyword">if</span>(regVal_int_status &amp; BIT_INT_STATUS_DRDY)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">/* 数据准备好了 */</span></span><br><span class="line">		icm426xx_getRawData(&amp;imuData);	<span class="comment">// 读取原始数据</span></span><br><span class="line">		</span><br><span class="line">		<span class="keyword">if</span> (sumNum &lt; <span class="number">512</span>)	<span class="comment">// 存储采样数据</span></span><br><span class="line">		&#123;</span><br><span class="line">			<span class="comment">// --- 陀螺仪采样数据 累加</span></span><br><span class="line">			transCache.byte[<span class="number">0</span>] = imuData.gyro_x_L;   transCache.byte[<span class="number">1</span>] = imuData.gyro_x_H;</span><br><span class="line">			gyroAxisSum[<span class="number">0</span>] += transCache.getSign;</span><br><span class="line">			</span><br><span class="line">			transCache.byte[<span class="number">0</span>] = imuData.gyro_y_L;   transCache.byte[<span class="number">1</span>] = imuData.gyro_y_H;</span><br><span class="line">			gyroAxisSum[<span class="number">1</span>] += transCache.getSign;</span><br><span class="line">			</span><br><span class="line">			transCache.byte[<span class="number">0</span>] = imuData.gyro_z_L;   transCache.byte[<span class="number">1</span>] = imuData.gyro_z_H;</span><br><span class="line">			gyroAxisSum[<span class="number">2</span>] += transCache.getSign;</span><br><span class="line">			</span><br><span class="line">			<span class="comment">// --- 加速度计采样数据 累加</span></span><br><span class="line">			transCache.byte[<span class="number">0</span>] = imuData.accel_x_L;   transCache.byte[<span class="number">1</span>] = imuData.accel_x_H;</span><br><span class="line">			accelAxisSum[<span class="number">0</span>] += transCache.getSign;</span><br><span class="line">			</span><br><span class="line">			transCache.byte[<span class="number">0</span>] = imuData.accel_y_L;   transCache.byte[<span class="number">1</span>] = imuData.accel_y_H;</span><br><span class="line">			accelAxisSum[<span class="number">1</span>] += transCache.getSign;</span><br><span class="line">			</span><br><span class="line">			transCache.byte[<span class="number">0</span>] = imuData.accel_z_L;   transCache.byte[<span class="number">1</span>] = imuData.accel_z_H;</span><br><span class="line">			accelAxisSum[<span class="number">2</span>] += transCache.getSign;</span><br><span class="line">			</span><br><span class="line">			sumNum ++;</span><br><span class="line">			<span class="keyword">if</span> (sumNum &gt;= <span class="number">512</span>)</span><br><span class="line">			&#123;</span><br><span class="line">				icm426xx_getAverageOffset(Offset6Axis);	<span class="comment">// 求解偏置</span></span><br><span class="line">				icm426xx_load6AxisOffset(Offset6Axis);	<span class="comment">// 加载偏置</span></span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span>&#123;</span><br><span class="line">			icm426xx_trans_RawDataToStandardData(&amp;imuData, &amp;imu);	<span class="comment">// 解析为标准单位</span></span><br><span class="line"><span class="comment">//			print_IMU_data(&amp;imu);</span></span><br><span class="line">			</span><br><span class="line">			<span class="comment">// Mahony滤波器</span></span><br><span class="line">			MahonyFilter_6Axis(imu.quaternion_body2Earth,</span><br><span class="line">			                   imu.gyro_x, imu.gyro_y, imu.gyro_z,</span><br><span class="line">			                   imu.accel_x, imu.accel_y, imu.accel_z);</span><br><span class="line">			trans_quaternionToEulerAngle(&amp;imu);	<span class="comment">// 把四元数转为欧拉角</span></span><br><span class="line">			</span><br><span class="line">			<span class="comment">// 打印数据</span></span><br><span class="line">			print_AHRS_data(&amp;imu);</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		<span class="meta">#<span class="keyword">ifdef</span> _RAWSIGNAL_ANALYSIS_ICM426XX_</span></span><br><span class="line">		<span class="comment">/*记录数据*/</span></span><br><span class="line">		<span class="comment">// 注意：测量时应该把设备放在水平、静止的台上</span></span><br><span class="line">		<span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">if</span>(regVal_int_status &amp; BIT_INT_STATUS_RESET_DONE)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">/* 复位完成 */</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(regVal_int_status &amp; BIT_INT_STATUS_PLL_RDY)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">/* PLL准备完成 */</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(regVal_int_status &amp; BIT_INT_STATUS_AGC_RDY)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">/* AGC控制器准备完成 */</span></span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><ul>
<li><a href="https://hal.archives-ouvertes.fr/hal-00488376/document">Mahony滤波算法原论文</a></li>
<li><a href="https://ahrs.readthedocs.io/en/latest/index.html">AHRS项目</a>：一个包含了常用定位、姿态算法的Python开源工具包</li>
<li>全权.多旋翼飞行器设计与控制[M]，电子工业出版社，2018</li>
</ul>
]]></content>
      <categories>
        <category>嵌入式&amp;控制算法</category>
      </categories>
      <tags>
        <tag>SPI</tag>
        <tag>IMU</tag>
        <tag>STM32H7</tag>
        <tag>Mahony Filter</tag>
      </tags>
  </entry>
</search>
